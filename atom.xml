<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NiTaogeTech</title>
  
  <subtitle>Focus on Java, BD and Linux. </subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tech.nitaoge.com/"/>
  <updated>2019-04-15T15:59:23.590Z</updated>
  <id>http://tech.nitaoge.com/</id>
  
  <author>
    <name>中华郑六</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>看破Redis 1.快速安装及使用</title>
    <link href="http://tech.nitaoge.com/p/906310c9/"/>
    <id>http://tech.nitaoge.com/p/906310c9/</id>
    <published>2019-03-24T05:31:02.000Z</published>
    <updated>2019-04-15T15:59:23.590Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公司要用Redis做数据库缓存双写，虽然不是我搞，但我不会多没有牌面啊……<br>正所谓不积跬步无以至千里，不会原理下一个坑的就是你。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>我这里装了三个虚拟机，并做了域名映射。</p><blockquote><p>Centos7.6_1810<br>vhost1、vhost2、vhost3<br>每个都是1核2G 40G(系统盘)+60G(数据盘-挂到/disk1)<br>为以后搭集群做准备。</p></blockquote><p><strong><em>不多哔哔，直接在虚拟机上开干，注意每次搞虚拟机前先拍快照。</em></strong></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://redis.io/download" target="_blank" rel="noopener">Redis官网下载地址</a><br>我本次下载最新版为redis-5.0.4.tar.gz</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="把包传到虚拟机"><a href="#把包传到虚拟机" class="headerlink" title="把包传到虚拟机"></a>把包传到虚拟机</h3><p><code>scp redis-5.0.4.tar.gz root@vhost1:/disk1/pack</code></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><code>tar xzf redis-5.0.4.tar.gz</code><br><code>cd redis-5.0.4</code></p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>make clean &amp;&amp; make</code></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="备份原配置文件"><a href="#备份原配置文件" class="headerlink" title="备份原配置文件"></a>备份原配置文件</h3><p><code>cp redis.conf redis.conf.bk</code></p><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p><code>vi redis.conf</code><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绑定地址（开外部访问）</span></span><br><span class="line">bind vhost1</span><br><span class="line"><span class="comment"># 解除保护模式</span></span><br><span class="line">protected-mode <span class="literal">no</span></span><br><span class="line"><span class="comment"># 绑定端口</span></span><br><span class="line">port 6379</span><br></pre></td></tr></table></figure></p><h2 id="启动（守护进程）"><a href="#启动（守护进程）" class="headerlink" title="启动（守护进程）"></a>启动（守护进程）</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/redis-<span class="keyword">server</span></span><br><span class="line">或指定配置文件位置</span><br><span class="line">nohup src/redis-<span class="keyword">server</span> redis.conf &amp;</span><br></pre></td></tr></table></figure><p><img src="/images/redis/1553409282510.png" alt="启动redis"><br><em>这里可以把服务作为系统服务启动，后面再讲。</em></p><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p>每个服务启动都是作为一个系统进程并且有进程号(pid)的。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span> -ef | <span class="keyword">grep</span> -v <span class="string">'grep'</span> | <span class="keyword">grep</span> redis</span><br></pre></td></tr></table></figure></p><p><img src="/images/redis/Jietu20190324-143856.png" alt="进程"><br>其中2991就是进程号。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> 2991</span><br></pre></td></tr></table></figure></p><h2 id="命令行客户端连接"><a href="#命令行客户端连接" class="headerlink" title="命令行客户端连接"></a>命令行客户端连接</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">src/redis-cli</span><br><span class="line">redis&gt; <span class="builtin-name">set</span> foo bar</span><br><span class="line">OK</span><br><span class="line">redis&gt; <span class="builtin-name">get</span> foo</span><br><span class="line"><span class="string">"bar"</span></span><br></pre></td></tr></table></figure><h2 id="java连接"><a href="#java连接" class="headerlink" title="java连接"></a>java连接</h2><h3 id="集成jedis"><a href="#集成jedis" class="headerlink" title="集成jedis"></a>集成jedis</h3><p>// TODO<br><del>等有时间写个jedis客户端工具</del></p><h3 id="集成spring-boot-starter-data-redis"><a href="#集成spring-boot-starter-data-redis" class="headerlink" title="集成spring-boot-starter-data-redis"></a>集成spring-boot-starter-data-redis</h3><p>引包<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">group:</span> <span class="string">'org.springframework.boot'</span>, <span class="string">name:</span> <span class="string">'spring-boot-starter-data-redis'</span>, <span class="string">version:</span> <span class="string">'2.1.3.RELEASE'</span></span><br></pre></td></tr></table></figure></p><p>加配置<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis:</span> <span class="comment"># redis</span></span><br><span class="line"><span class="attr">  host:</span> <span class="string">vhost1</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">  password:</span></span><br><span class="line"><span class="attr">  jedis:</span></span><br><span class="line"><span class="attr">    pool:</span></span><br><span class="line"><span class="attr">      max-active:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      max-wait:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">      max-idle:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      min-idle:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>注入RedisTemplate或StringRedisTemplate直接使用，后续会仔细剖析二者区别<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure></p><p>封装工具可参考<a href="https://github.com/whvcse/RedisUtil" target="_blank" rel="noopener">whvcse/RedisUtil</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>确定你刚装的虚拟机上有gcc，没有就装yum install -y gcc</li></ul><p><img src="/images/redis/1553407100861.png" alt="没装gcc"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="redis" scheme="http://tech.nitaoge.com/categories/redis/"/>
    
    
      <category term="看破Redis" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4Redis/"/>
    
  </entry>
  
  <entry>
    <title>看破Apollo 1.快速安装及使用</title>
    <link href="http://tech.nitaoge.com/p/21135a2b/"/>
    <id>http://tech.nitaoge.com/p/21135a2b/</id>
    <published>2019-03-24T05:16:24.000Z</published>
    <updated>2019-04-16T02:36:42.029Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="opensource" scheme="http://tech.nitaoge.com/categories/opensource/"/>
    
    
      <category term="Apollo ctrip" scheme="http://tech.nitaoge.com/tags/Apollo-ctrip/"/>
    
      <category term="看破开源组件" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>看破MySQL 2.基本概念</title>
    <link href="http://tech.nitaoge.com/p/da0fe888/"/>
    <id>http://tech.nitaoge.com/p/da0fe888/</id>
    <published>2019-03-22T12:42:13.000Z</published>
    <updated>2019-04-15T15:59:23.589Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="mysql" scheme="http://tech.nitaoge.com/categories/mysql/"/>
    
    
      <category term="看破MySQL" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4MySQL/"/>
    
  </entry>
  
  <entry>
    <title>看破设计模式 2. 创建型模式 - 单例模式(Singleton)</title>
    <link href="http://tech.nitaoge.com/p/c9a4fbc9/"/>
    <id>http://tech.nitaoge.com/p/c9a4fbc9/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-16T02:36:42.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>Ensure a class has only one instance, and provide a global point of access to it.</p></blockquote><p>确保某一个类只有一个实例， 而且自行实例化并向整个系统提供这个实例。 </p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>饿汉式<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class HungrySingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static final HungrySingleton<span class="built_in"> instance </span>= new HungrySingleton();</span><br><span class="line"></span><br><span class="line">    private HungrySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static HungrySingleton instance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>懒汉式（加锁禁止重排序保证线程安全）<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class LazySingleton &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile LazySingleton<span class="built_in"> instance </span>= <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    private LazySingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static LazySingleton instance() &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            synchronized (LazySingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                   <span class="built_in"> instance </span>= new LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然Effective java推荐枚举式<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    private EnumSingleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private enum Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        private final EnumSingleton instance;</span><br><span class="line"></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">           <span class="built_in"> instance </span>= new EnumSingleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public EnumSingleton getInstance() &#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static EnumSingleton instance() &#123;</span><br><span class="line">        return Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我选择静态内部类式<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NiceSingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NiceSingleton</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">InstanceHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> final <span class="keyword">static</span> NiceSingleton instance = <span class="keyword">new</span> NiceSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NiceSingleton <span class="title">instance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ul><li>为什么懒汉式单例要双重校验？</li></ul><blockquote><p>当两个线程同时调用instance()方法时，由于singleton==null，两个线程都可以通过第一个校验，<br>然后线程A持有锁，线程B等待。当线程A执行完实例化、释放锁，线程B进入代码块。</p></blockquote><blockquote><p>如果不加第二个校验，线程B又会实例化一个对象。就会违反单例模式设计原则。</p></blockquote><blockquote><p>如果不加第一个校验，也能实现单例，但多个线程反复竞争锁会增加系统开销，严重影响性能。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://product.dangdang.com/71052.html" target="_blank" rel="noopener">设计模式 GOF</a></p><p><a href="http://product.dangdang.com/20079096.html" target="_blank" rel="noopener">研磨设计模式</a></p><p><a href="http://product.dangdang.com/24157561.html" target="_blank" rel="noopener">图解设计模式</a></p><p><a href="http://cmsblogs.com/?p=3396" target="_blank" rel="noopener">设计模式读书笔记文集</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="design" scheme="http://tech.nitaoge.com/categories/design/"/>
    
    
      <category term="看破设计模式" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>看破设计模式 3. 结构型模式 - 适配器模式(Adapter)</title>
    <link href="http://tech.nitaoge.com/p/a718df1a/"/>
    <id>http://tech.nitaoge.com/p/a718df1a/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-16T02:36:42.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://product.dangdang.com/71052.html" target="_blank" rel="noopener">设计模式 GOF</a></p><p><a href="http://product.dangdang.com/20079096.html" target="_blank" rel="noopener">研磨设计模式</a></p><p><a href="http://product.dangdang.com/24157561.html" target="_blank" rel="noopener">图解设计模式</a></p><p><a href="http://cmsblogs.com/?p=3396" target="_blank" rel="noopener">设计模式读书笔记文集</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="design" scheme="http://tech.nitaoge.com/categories/design/"/>
    
    
      <category term="看破设计模式" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>看破设计模式 4. 行为型模式 - 职责链模式(Chain of Responsibility)</title>
    <link href="http://tech.nitaoge.com/p/baaf222c/"/>
    <id>http://tech.nitaoge.com/p/baaf222c/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-16T02:36:42.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://product.dangdang.com/71052.html" target="_blank" rel="noopener">设计模式 GOF</a></p><p><a href="http://product.dangdang.com/20079096.html" target="_blank" rel="noopener">研磨设计模式</a></p><p><a href="http://product.dangdang.com/24157561.html" target="_blank" rel="noopener">图解设计模式</a></p><p><a href="http://cmsblogs.com/?p=3396" target="_blank" rel="noopener">设计模式读书笔记文集</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="design" scheme="http://tech.nitaoge.com/categories/design/"/>
    
    
      <category term="看破设计模式" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>看破Git 1.快速安装及使用</title>
    <link href="http://tech.nitaoge.com/p/2ab4ec8e/"/>
    <id>http://tech.nitaoge.com/p/2ab4ec8e/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-16T02:36:42.028Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="devtool" scheme="http://tech.nitaoge.com/categories/devtool/"/>
    
    
      <category term="看破Git" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4Git/"/>
    
  </entry>
  
  <entry>
    <title>看破IDEA 安装、使用、配置</title>
    <link href="http://tech.nitaoge.com/p/24280e36/"/>
    <id>http://tech.nitaoge.com/p/24280e36/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-16T02:36:42.027Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="为什么我改用IDEA？"><a href="#为什么我改用IDEA？" class="headerlink" title="为什么我改用IDEA？"></a>为什么我改用IDEA？</h1><p>就eclipse每次打开都需要rebuild all projects，在网络环境及其恶劣的情况下，总是无故卡死，我就不想用它了。<br>就这么倔！</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IDEA下载地址</a></p><p>这里有很多开发工具供你选择，我开发前后端分别用到了WebStorm和IDEA。<br><img src="/images/idea/Snipaste_2019-04-15_19-05-29.png" alt="产品列表"></p><p>点击download来到下载选择页面，左边付费功能多，右边免费开源功能少。<br><img src="/images/idea/Snipaste_2019-04-15_19-08-37.png" alt="下载页面"></p><p>windows程序目录如下，Mac的Contents结构也类似：<br><img src="/images/idea/Snipaste_2019-04-15_19-16-28.png" alt="程序目录"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="开始一个项目"><a href="#开始一个项目" class="headerlink" title="开始一个项目"></a>开始一个项目</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>TODO</p><h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><p>TODO</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="程序配置文件参数"><a href="#程序配置文件参数" class="headerlink" title="程序配置文件参数"></a>程序配置文件参数</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-Xms128m   <span class="comment">// 初始内存</span></span><br><span class="line">-Xmx750m   <span class="comment">// 最大内存</span></span><br><span class="line">-XX:ReservedCodeCacheSize=<span class="number">240</span>m  <span class="comment">// 代码恢复缓存</span></span><br><span class="line">-XX:+UseConcMarkSweepGC   <span class="comment">// 设置老年代为并发收集</span></span><br><span class="line">-XX:SoftRefLRUPolicyMSPerMB=<span class="number">50</span></span><br><span class="line">-ea</span><br><span class="line">-Dsun<span class="selector-class">.io</span><span class="selector-class">.useCanonCaches</span>=false</span><br><span class="line">-Djava<span class="selector-class">.net</span><span class="selector-class">.preferIPv4Stack</span>=true</span><br><span class="line">-Djdk<span class="selector-class">.http</span><span class="selector-class">.auth</span><span class="selector-class">.tunneling</span><span class="selector-class">.disabledSchemes</span>=<span class="string">""</span></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:-OmitStackTraceInFastThrow</span><br><span class="line">-Dfile.encoding=UTF-<span class="number">8</span>   <span class="comment">// 文件编码集，解决控制台输出乱码问题</span></span><br><span class="line">-Deditable<span class="selector-class">.java</span><span class="selector-class">.test</span><span class="selector-class">.console</span>=true   <span class="comment">// 解决Junit @Test不能使用控制台输入问题</span></span><br></pre></td></tr></table></figure><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>常用快捷键</li></ul><p>TODO</p><ul><li>自定义快捷键</li></ul><p>Settings -&gt; Keymap</p><h2 id="代码模版"><a href="#代码模版" class="headerlink" title="代码模版"></a>代码模版</h2><ul><li>自定义代码模版</li></ul><p>Settings -&gt; Editor -&gt; Live Templates</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="devtool" scheme="http://tech.nitaoge.com/categories/devtool/"/>
    
    
      <category term="看破IDEA" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4IDEA/"/>
    
  </entry>
  
  <entry>
    <title>看破Java 1.核心语法</title>
    <link href="http://tech.nitaoge.com/p/195fb869/"/>
    <id>http://tech.nitaoge.com/p/195fb869/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-15T15:59:23.586Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>重新梳理一下JAVA开发中常用到的核心语法，随遇到随补充……</p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>将变量和方法封装成一个类，通过实例化的方式赋予其为对象。</p><p>可以看下八大基本数据类型的包装类加深理解：</p><ul><li>怎么包装成类的？</li><li>怎么继承Number实现obj.xxxValue()的？</li><li>怎么实现自动拆箱装箱的？</li></ul><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>子类继承超类允许的属性和方法。</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>在类的内部声明类，就是内部类。<br>特性：</p><ul><li>可以通过声明多个内部类，实现多继承。</li><li>内部类可直接访问外部类成员变量和方法，但外部类访问内部类的成员需要实例化内部类。</li><li>提供更好的封装。</li></ul><h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><p>{<br>}<br>在类中跟构造方法类似，都是在实例化对象时执行。</p><h2 id="实例化内部类"><a href="#实例化内部类" class="headerlink" title="实例化内部类"></a>实例化内部类</h2><p>没什么好说的，直接上代码……<br>拥有内部类的类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelf</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySelf</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实例化：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MySelf mySelf = new MySelf();</span><br><span class="line">MySelf.<span class="builtin-name">Info</span> myInfo = mySelf.new <span class="builtin-name">Info</span>(12);</span><br><span class="line">LogUtils.<span class="builtin-name">info</span>(myInfo.getAge());</span><br></pre></td></tr></table></figure></p><p>为MySelf.Info加上static修饰，实例化：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MySelf.<span class="builtin-name">Info</span> myInfo = new MySelf.<span class="builtin-name">Info</span>(12);</span><br><span class="line">LogUtils.<span class="builtin-name">info</span>(myInfo.getAge());</span><br></pre></td></tr></table></figure></p><h2 id="继承内部类"><a href="#继承内部类" class="headerlink" title="继承内部类"></a>继承内部类</h2><p>需要通过外部类实例引用外部类构造器，才能继承内部类，没这么玩的。太反人类……<br>父类：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelf</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySelf</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>子类：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MySon</span> <span class="keyword">extends</span> <span class="title">MySelf</span>.<span class="title">Info</span> </span>&#123;</span><br><span class="line">    public <span class="type">MySon</span>(<span class="type">MySelf</span> mySelf) &#123;</span><br><span class="line">        mySelf.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>在实例化前内部继承抽象类并实现抽象方法，或内部实现接口并实现接口所有方法。<br>类似这样：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MySelf son = <span class="keyword">new</span> <span class="type">MySon</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> void <span class="keyword">set</span>(<span class="keyword">String</span> id) &#123;</span><br><span class="line"><span class="built_in">this</span>.setId(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">LogUtils.info(((MySon) son).<span class="keyword">get</span>());</span><br></pre></td></tr></table></figure></p><h2 id="this-和-super"><a href="#this-和-super" class="headerlink" title="this 和 super"></a>this 和 super</h2><p>this指当前对象本身<br>super指当前对象最近超（父）类</p><p>在构造方法中使用super()和this()应该注意：</p><ul><li>super()调用父类的构造方法，this()调用当前类的其它构造方法。</li><li>每个子类构造方法的第一条语句，都隐式调用super()，如果父类没有这种形式的构造函数，会编译报错。</li><li>super()和this()均需放在构造方法内第一行，一个构造方法内只能调用其中一个。</li><li>this()和super()都指向对象，所以不能在static方法，static语句块中使用。</li></ul><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h2><p>在编译阶段就能确定调用哪个方法的方式，叫静态绑定机制。</p><h2 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h2><p>根据实际创建的对象类型来确定方法所在位置，通过动态创建的对象方法表来定位方法的方式，叫动态绑定机制。</p><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><p>Java修饰符中用来控制访问权限的，分为以下四种：</p><ul><li>类内可访问（private）</li><li>包内可访问 (缺省。有人说是default，但在jdk8中default用于修饰接口默认方法，写在代码里尝试过确实不是)</li><li>子类可访问 (protected)</li><li>均可访问 (public)</li></ul><p>以下用表格说明各修饰符区别：</p><table><thead><tr><th style="text-align:left">修饰符</th><th style="text-align:center">当前类</th><th style="text-align:center">包内</th><th style="text-align:center">子孙类（包内）</th><th style="text-align:center">子孙类（不同包）</th><th style="text-align:center">其他包</th></tr></thead><tbody><tr><td style="text-align:left">public</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr><tr><td style="text-align:left">protected</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y/N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:left">缺省</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:left">private</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr></tbody></table><blockquote><p>这里要特别说明protected作用，也就是上面那个Y/N：</p><ul><li>允许同一包内的类任意调用。</li><li>不在同一包内的类，只允许子孙类调用，不在家谱上的类不能调用</li></ul></blockquote><p>默认缺省值：</p><ul><li>类中的变量和方法都是<code>public</code>，构造函数为<code>缺省</code>。</li><li>接口中的变量为<code>public static final</code>，方法为<code>public</code>。</li></ul><p>访问控制的继承：</p><ul><li>父类声明为public的变量和方法，子类也必须声明为public。</li><li>父类声明为protected的变量和方法，子类可以声明为protected或public。</li><li>父类声明为private的方法，不能被继承。</li></ul><h2 id="非访问控制修饰符"><a href="#非访问控制修饰符" class="headerlink" title="非访问控制修饰符"></a>非访问控制修饰符</h2><h3 id="静态修饰符static"><a href="#静态修饰符static" class="headerlink" title="静态修饰符static"></a>静态修饰符static</h3><p>用于修饰静态方法和静态变量。</p><ul><li>一个类无论实例化了多少个对象，类的静态变量和静态方法都指向一块固定的内存区，修改任意实例中的静态变量都为最终修改值。</li><li>静态方法中只能使用静态变量。</li><li>二者可以通过Class.member，Class.method()的方式直接调用。</li><li>可以修饰静态内部类</li></ul><h3 id="static-代码块"><a href="#static-代码块" class="headerlink" title="static{} 代码块"></a>static{} 代码块</h3><p>在JVM的生命周期中只被加载一次，是伴随类加载执行的。<br>不管怎么实例化这个类，都只执行一次。</p><h3 id="最终修饰符final"><a href="#最终修饰符final" class="headerlink" title="最终修饰符final"></a>最终修饰符final</h3><p>修饰常量、修饰不可继承类，修饰可继承但不能重写的方法。</p><h3 id="抽象类修饰符abstract"><a href="#抽象类修饰符abstract" class="headerlink" title="抽象类修饰符abstract"></a>抽象类修饰符abstract</h3><p>抽象类不能被final修饰，可以包含抽象方法和非抽象方法。<br>抽象方法不能被final和static修饰，不能有方法体，继承抽象类的子类必须实现父类的所有抽象方法，除非子类也是抽象类。</p><p>注意：抽象类是不能被实例化的！！！<br>除非你使用匿名内部类的方式实现它的抽象方法，然后实例化这个匿名内部类，比如：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MySelf son = <span class="keyword">new</span> <span class="type">MySon</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> void <span class="keyword">set</span>(<span class="keyword">String</span> id) &#123;</span><br><span class="line"><span class="built_in">this</span>.setId(id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">LogUtils.info(((MySon) son).<span class="keyword">get</span>());</span><br></pre></td></tr></table></figure></p><p>但是！这么写属于<em><strong><em>反人类</em></strong></em>设计模式，不推荐这样写。</p><h3 id="接口默认实现方法default-jdk8"><a href="#接口默认实现方法default-jdk8" class="headerlink" title="接口默认实现方法default (jdk8)"></a>接口默认实现方法default (jdk8)</h3><p>在interface中实现默认方法需要加default修饰，必须为public公有<br>这和抽象类中可以有protected抽象方法和private成员变量有区别</p><h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><p>实现了Serilizable接口的POJO，在不需要对类中某个成员变量进行序列化时，可以使用transient修饰该成员变量。反序列化时该成员变量无法获得访问，值为null。</p><blockquote><p>在实际开发过程中，有些属性需要序列化，有些不需要，比如一些敏感信息（如身份证，密码，银行卡号等）不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p></blockquote><ul><li>只能修饰成员变量，类、方法、本地变量均不能修饰。</li><li>静态变量不能被序列化。</li></ul><h3 id="synchronized和volatile"><a href="#synchronized和volatile" class="headerlink" title="synchronized和volatile"></a>synchronized和volatile</h3><p>synchronized修饰多线程中的同步锁<br>volatile修饰多线程中的共享变量</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><img src="https://user-gold-cdn.xitu.io/2018/8/10/165242e52c2beee2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="异常继承关系"></p><ul><li>Error</li></ul><p>Error一般表示编译时或者系统错误，例如：虚拟机相关的错误，系统崩溃（例如：OutOfMemoryError）等。这种错误无法恢复或不可捕获,将导致应用程序中断,通常应用程序无法处理这些错误,因此也不应该试图用catch来进行捕获。</p><ul><li>Exception</li></ul><p>Exception分为<strong>受检查异常</strong>和<strong>运行时异常</strong>（不受检查异常）。</p><p>编译器在编译时，对于<strong>受检查异常</strong>必须进行try…catch或throws处理,否则无法通过编译。常见的受检查异常包括：IO操作、ClassNotFoundException、线程操作等。</p><p>RuntimeException及其子类都统称为<strong>非受检查异常</strong>，例如：NullPointExecrption、NumberFormatException（字符串转换为数字）、ArrayIndexOutOfBoundsException（数组越界）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）等。</p><h2 id="try-with-resources-jdk7"><a href="#try-with-resources-jdk7" class="headerlink" title="try-with-resources(jdk7)"></a>try-with-resources(jdk7)</h2><p>在try()括号中打开的资源会在语句执行结束时关闭。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> <span class="type">BufferedReader</span>(<span class="keyword">new</span> <span class="type">FileReader</span>(path));</span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> <span class="type">BufferedWriter</span>(<span class="keyword">new</span> <span class="type">FileWriter</span>(path));</span><br><span class="line">)&#123;</span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h2><p>首先看这段代码<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ++x;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ++x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果是2而不是3，finally到底执行了吗？<br>经打断点运行确认，finally执行后x为3，又执行到return，返回结果为2。</p><p>查阅<a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html" target="_blank" rel="noopener">官方finally语句说明</a>，对这个特殊情况有说明：</p><blockquote><p>The finally block always executes when the try block exits. This ensures that the finally block is executed even if an unexpected exception occurs. But finally is useful for more than just exception handling — it allows the programmer to avoid having cleanup code accidentally bypassed by a return, continue, or break. Putting cleanup code in a finally block is always a good practice, even when no exceptions are anticipated.</p></blockquote><blockquote><blockquote><p>Note: If the JVM exits while the try or catch code is being executed, then the finally block may not execute. Likewise, if the thread executing the try or catch code is interrupted or killed, the finally block may not execute even though the application as a whole continues.</p></blockquote></blockquote><p>翻译：</p><blockquote><p>当try语句退出时肯定会执行finally语句。这确保了即使发了一个意想不到的异常也会执行finally语句块。但是finally的用处不仅是用来处理异常——它可以让程序员不会因为return、continue、或者break语句而忽略了清理代码。把清理代码放在finally语句块里是一个很好的做法，即便可能不会有异常发生也要这样做。</p><blockquote><p>注意，当try或者catch的代码在运行的时候，JVM退出了。那么finally语句块就不会执行。同样，如果线程在运行try或者catch的代码时被中断了或者被杀死了(killed)，那么finally语句可能也不会执行了，即使整个运用还会继续执行。</p></blockquote></blockquote><p>这说明只要进程(jvm)不死,线程(thread)不被中断，finally就必须执行。</p><ul><li>那么为什么返回结果为2呢？</li></ul><p>查阅<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.10.2.5" target="_blank" rel="noopener">官方jvm文档</a>，</p><blockquote><p>If the try clause executes a return, the compiled code does the following:</p><blockquote><p>1.Saves the return value (if any) in a local variable.<br>2.Executes a jsr to the code for the finally clause.<br>3.Upon return from the finally clause, returns the value saved in the local variable.</p></blockquote></blockquote><p>翻译：</p><blockquote><p>如果try语句里有return，那么代码的行为如下：</p><blockquote><p>1.如果有返回值，就把返回值保存到局部变量中<br>2.执行jsr指令跳到finally语句里执行<br>3.执行完finally语句后，返回之前保存在局部变量表里的值</p></blockquote></blockquote><p>根据上面的说明就可以明白为什么是2了。<br>当执行到return ++x;时，jvm在执行完++x后会在局部变量表里另外分配一个空间来保存当前x的值。<br>注意，现在还没把值返回，而是继续执行finally语句里的语句。等执行完后再把之前保存的值（是2不是x）返回。<br>所以就有了返回结果是2不是3的情况。</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>类型参数化，可以看下集合的实现。</p><p>未知泛型参数方法需要在返回值类型前声明泛型。</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>修饰构造器、成员变量类型、成员方法、方法参数等，用于反射拿值逻辑处理。</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><ul><li>@Target （作用域）</li></ul><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line"><span class="built_in">   TYPE,</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line"><span class="built_in">   FIELD,</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Method declaration */</span></span><br><span class="line"><span class="built_in">   METHOD,</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line"><span class="built_in">   PARAMETER,</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Constructor declaration */</span></span><br><span class="line"><span class="built_in">   CONSTRUCTOR,</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Local variable declaration */</span></span><br><span class="line"><span class="built_in">   LOCAL_VARIABLE,</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Annotation type declaration */</span></span><br><span class="line"><span class="built_in">   ANNOTATION_TYPE,</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Package declaration */</span></span><br><span class="line"><span class="built_in">   PACKAGE,</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Type parameter declaration</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @since 1.8</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="built_in">   TYPE_PARAMETER,</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Use of a type</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @since 1.8</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   TYPE_USE</span><br></pre></td></tr></table></figure><ul><li>@Retention （保留策略）</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Annotations are <span class="keyword">to</span> be discarded <span class="keyword">by</span> <span class="keyword">the</span> compiler.</span><br><span class="line">    */</span><br><span class="line">   SOURCE,</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Annotations are <span class="keyword">to</span> be recorded <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">class</span> <span class="built_in">file</span> <span class="keyword">by</span> <span class="keyword">the</span> compiler</span><br><span class="line">    * <span class="keyword">but</span> need <span class="keyword">not</span> be retained <span class="keyword">by</span> <span class="keyword">the</span> VM <span class="keyword">at</span> <span class="built_in">run</span> <span class="built_in">time</span>.  This <span class="keyword">is</span> <span class="keyword">the</span> default</span><br><span class="line">    * behavior.</span><br><span class="line">    */</span><br><span class="line">   CLASS,</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * Annotations are <span class="keyword">to</span> be recorded <span class="keyword">in</span> <span class="keyword">the</span> <span class="built_in">class</span> <span class="built_in">file</span> <span class="keyword">by</span> <span class="keyword">the</span> compiler <span class="keyword">and</span></span><br><span class="line">    * retained <span class="keyword">by</span> <span class="keyword">the</span> VM <span class="keyword">at</span> <span class="built_in">run</span> <span class="built_in">time</span>, so they may be <span class="built_in">read</span> reflectively.</span><br><span class="line">    *</span><br><span class="line">    * @see java.lang.reflect.AnnotatedElement</span><br><span class="line">    */</span><br><span class="line">   RUNTIME</span><br></pre></td></tr></table></figure><p>比如Lombok的所有注解都是保留在源码阶段的，</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line">public <span class="variable">@interface</span> Data &#123;</span><br></pre></td></tr></table></figure><ul><li>@Repeatable （重复注解）</li></ul><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Indicates the &lt;em&gt;containing <span class="keyword">annotation</span> <span class="title">type</span>&lt;/<span class="title">em</span>&gt; <span class="title">for</span> <span class="title">the</span></span><br><span class="line"> * repeatable <span class="keyword">annotation</span> <span class="title">type</span>.</span><br><span class="line"> * @<span class="keyword">return</span> the containing <span class="keyword">annotation</span> <span class="title">type</span></span><br><span class="line"> *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">Class&lt;? extends Annotation&gt; value();</span></span><br></pre></td></tr></table></figure><h2 id="重复注解-jdk8"><a href="#重复注解-jdk8" class="headerlink" title="重复注解(jdk8)"></a>重复注解(jdk8)</h2><p>注解容器：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> MyAnnotations &#123;</span><br><span class="line">    <span class="selector-tag">MyAnnotation</span><span class="selector-attr">[]</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">Target</span>(&#123;<span class="selector-tag">ElementType</span><span class="selector-class">.CONSTRUCTOR</span>, <span class="selector-tag">ElementType</span><span class="selector-class">.METHOD</span>, <span class="selector-tag">ElementType</span><span class="selector-class">.PARAMETER</span>, <span class="selector-tag">ElementType</span><span class="selector-class">.FIELD</span>, <span class="selector-tag">ElementType</span><span class="selector-class">.ANNOTATION_TYPE</span>&#125;)</span><br><span class="line">@<span class="keyword">Retention</span>(<span class="keyword">RetentionPolicy</span>.<span class="keyword">RUNTIME</span>)</span><br><span class="line">@<span class="keyword">Repeatable</span>(<span class="keyword">MyAnnotations</span>.<span class="keyword">class</span>)</span><br><span class="line"><span class="keyword">public</span> @interface MyAnnotation &#123;</span><br><span class="line">    <span class="selector-tag">String</span> <span class="selector-tag">value</span>() <span class="selector-tag">default</span> "<span class="selector-tag">aaa</span>";</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@MyAnnotation</span>(<span class="string">"bbb"</span>)</span><br><span class="line">   <span class="variable">@MyAnnotation</span>(<span class="string">"ccc"</span>)</span><br><span class="line">   public void callback() &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="提取注解属性"><a href="#提取注解属性" class="headerlink" title="提取注解属性"></a>提取注解属性</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;AnnotationTest&gt; clazz = AnnotationTest.class;</span><br><span class="line">   Method m1 = clazz.getMethod(<span class="string">"callback"</span>);</span><br><span class="line">   MyAnnotation[] ans = m1.getAnnotationsByType(MyAnnotation.class);</span><br><span class="line">   Arrays.asList<span class="function"><span class="params">(ans)</span>.<span class="title">forEach</span><span class="params">((a) -&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">      System.out.println(a.value());</span></span></span><br><span class="line"><span class="function"><span class="params">   &#125;)</span>;</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bbb</span></span><br><span class="line"><span class="keyword">ccc</span></span><br></pre></td></tr></table></figure><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><h2 id="强引用（StrongReference）"><a href="#强引用（StrongReference）" class="headerlink" title="强引用（StrongReference）"></a>强引用（StrongReference）</h2><p>如果一个对象具有强引用，那垃圾回收器绝不会回收它。<br>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，<br>也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>[] arr = <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="软引用（SoftReference）"><a href="#软引用（SoftReference）" class="headerlink" title="软引用（SoftReference）"></a>软引用（SoftReference）</h2><p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；<br>如果内存空间不足了，就会回收这些对象的内存。<br>只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;<span class="keyword">String</span>[]&gt; referenceQueue = <span class="keyword">new</span> <span class="type">ReferenceQueue</span>&lt;<span class="keyword">String</span>[]&gt;();</span><br><span class="line">SoftReference&lt;<span class="keyword">String</span>[]&gt; softBean = <span class="keyword">new</span> <span class="type">SoftReference</span>&lt;<span class="keyword">String</span>[]&gt;(<span class="keyword">new</span> <span class="type">String</span>[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</span><br></pre></td></tr></table></figure><h2 id="弱引用（WeakReference）"><a href="#弱引用（WeakReference）" class="headerlink" title="弱引用（WeakReference）"></a>弱引用（WeakReference）</h2><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，<br>不管当前内存空间足够与否，都会回收它的内存。<br>不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;<span class="keyword">String</span>[]&gt; referenceQueue = <span class="keyword">new</span> <span class="type">ReferenceQueue</span>&lt;<span class="keyword">String</span>[]&gt;();</span><br><span class="line">WeakReference&lt;<span class="keyword">String</span>[]&gt; softBean = <span class="keyword">new</span> <span class="type">WeakReference</span>&lt;<span class="keyword">String</span>[]&gt;(<span class="keyword">new</span> <span class="type">String</span>[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</span><br></pre></td></tr></table></figure><h2 id="虚引用（PhantomReference）"><a href="#虚引用（PhantomReference）" class="headerlink" title="虚引用（PhantomReference）"></a>虚引用（PhantomReference）</h2><p>与其他几种引用都不同，虚引用并不会决定对象的生命周期。<br>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br>虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p><p>虚引用必须和引用队列 （ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;<span class="keyword">String</span>[]&gt; referenceQueue = <span class="keyword">new</span> <span class="type">ReferenceQueue</span>&lt;<span class="keyword">String</span>[]&gt;();</span><br><span class="line">PhantomReference&lt;<span class="keyword">String</span>[]&gt; referent = <span class="keyword">new</span> <span class="type">PhantomReference</span>&lt;<span class="keyword">String</span>&gt;(<span class="keyword">new</span> <span class="type">String</span>[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>详细内容及基本语法请参考：</p><p><a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">JAVA | 菜鸟教程</a></p><p><a href="http://product.dangdang.com/1395624125.html" target="_blank" rel="noopener">Java编程思想</a></p><p><a href="http://product.dangdang.com/1294027177.html" target="_blank" rel="noopener">Java核心技术卷I基础知识 | Java核心技术卷II高级特性</a></p><p><a href="http://product.dangdang.com/26437835.html" target="_blank" rel="noopener">Effective Java中文版</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java" scheme="http://tech.nitaoge.com/categories/java/"/>
    
    
      <category term="看破Java" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4Java/"/>
    
  </entry>
  
  <entry>
    <title>看破Elastic-Job 1.快速安装及使用</title>
    <link href="http://tech.nitaoge.com/p/75509985/"/>
    <id>http://tech.nitaoge.com/p/75509985/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-16T02:36:42.026Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="opensource" scheme="http://tech.nitaoge.com/categories/opensource/"/>
    
    
      <category term="看破开源组件" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4%E5%BC%80%E6%BA%90%E7%BB%84%E4%BB%B6/"/>
    
      <category term="Elastic-Job" scheme="http://tech.nitaoge.com/tags/Elastic-Job/"/>
    
  </entry>
  
  <entry>
    <title>看破Gradle 1.快速安装及使用</title>
    <link href="http://tech.nitaoge.com/p/18a22795/"/>
    <id>http://tech.nitaoge.com/p/18a22795/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-15T15:59:23.585Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="gradle" scheme="http://tech.nitaoge.com/categories/gradle/"/>
    
    
      <category term="看破Gradle" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4Gradle/"/>
    
  </entry>
  
  <entry>
    <title>看破Java 2.知其所以然</title>
    <link href="http://tech.nitaoge.com/p/bafefb6b/"/>
    <id>http://tech.nitaoge.com/p/bafefb6b/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-15T15:59:23.586Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals()的区别"></a>== 和 equals()的区别</h1><h2 id><a href="#" class="headerlink" title="=="></a>==</h2><ul><li>基本数据类型比较的是：值是否相等。</li><li>复合数据类型比较的是：引用实例是否相同，即实例在堆内存中存放地址是否相同。</li></ul><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><ul><li><p>Object基类中比较的是：存放地址是否相同（是否为同一对象实例）。</p><blockquote><p>Object.equals()方法中是这么写的： <code>return (this == obj);</code></p></blockquote></li><li><p>其他类重写了equals()方法，就看具体怎么写了。</p><blockquote><p>由以下方法实现，可以看出基本数据类型的包装类都是通过内置基本数据类型的成员变量value做==比较的，<br>  而字符串的比较可以看成是字符数组的比较。</p></blockquote></li></ul><h3 id="Byte的equals"><a href="#Byte的equals" class="headerlink" title="Byte的equals()"></a>Byte的equals()</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj instanceof <span class="built_in">Byte</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value == ((<span class="built_in">Byte</span>)obj).byteValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="Short的equals"><a href="#Short的equals" class="headerlink" title="Short的equals()"></a>Short的equals()</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj instanceof <span class="built_in">Short</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value == ((<span class="built_in">Short</span>)obj).shortValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="Integer的equals"><a href="#Integer的equals" class="headerlink" title="Integer的equals()"></a>Integer的equals()</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj instanceof <span class="keyword">Integer</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">value</span> == ((<span class="keyword">Integer</span>)obj).intValue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> false;</span><br></pre></td></tr></table></figure><h3 id="Long的equals"><a href="#Long的equals" class="headerlink" title="Long的equals()"></a>Long的equals()</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj instanceof <span class="built_in">Long</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> value == ((<span class="built_in">Long</span>)obj).longValue();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="Float的equals"><a href="#Float的equals" class="headerlink" title="Float的equals()"></a>Float的equals()</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return (<span class="name">obj</span> instanceof Float)</span><br><span class="line">             &amp;&amp; (<span class="name">floatToIntBits</span>(((<span class="name">Float</span>)obj).value) == floatToIntBits(<span class="name">value</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="Double的equals"><a href="#Double的equals" class="headerlink" title="Double的equals()"></a>Double的equals()</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return (<span class="name">obj</span> instanceof Double)</span><br><span class="line">       &amp;&amp; (<span class="name">doubleToLongBits</span>(((<span class="name">Double</span>)obj).value) ==</span><br><span class="line">              doubleToLongBits(<span class="name">value</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>注意Float和Double的计算值是通过native方法调用系统本地接口实现的，这里先不用管它，以后学了JNI再说。</p><h3 id="Boolean的equals"><a href="#Boolean的equals" class="headerlink" title="Boolean的equals()"></a>Boolean的equals()</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj instanceof <span class="built_in">Boolean</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value == ((<span class="built_in">Boolean</span>)obj).booleanValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="Character的equals"><a href="#Character的equals" class="headerlink" title="Character的equals()"></a>Character的equals()</h3><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj instanceof <span class="keyword">Character</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span> == ((<span class="keyword">Character</span>)obj).charValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> false;</span><br></pre></td></tr></table></figure><h3 id="String的equals"><a href="#String的equals" class="headerlink" title="String的equals()"></a>String的equals()</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (anObject instanceof String) &#123;</span><br><span class="line">          String anotherString = (String)anObject;</span><br><span class="line">          <span class="keyword">int</span> n = <span class="keyword">value</span>.length;</span><br><span class="line">          <span class="keyword">if</span> (n == anotherString.<span class="keyword">value</span>.length) &#123;</span><br><span class="line">              <span class="keyword">char</span> v1[] = <span class="keyword">value</span>;</span><br><span class="line">              <span class="keyword">char</span> v2[] = anotherString.<span class="keyword">value</span>;</span><br><span class="line">              <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                  i++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>先比较引用变量指向的内存地址，然后判断类型，再比较字符串长度，再转成字符数组挨个字符比较。</p><h1 id="hashCode-的计算"><a href="#hashCode-的计算" class="headerlink" title="hashCode()的计算"></a>hashCode()的计算</h1><p>Object提供的hashCode()方法的计算依赖于本地接口，暂且理解为实例对象的内存地址。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>所有类都可以重写Object的hashCode()方法，但重写hashCode()方法的基本规则：</p><blockquote><ol><li>两个对象通过equals()方法比较返回true时，那么两个对象的hashCode必须相等。</li><li>hashCode相等的两个对象，不必保证它们必须相同。（因为再优的哈希算法也避免不了哈希冲突）</li></ol></blockquote><p>看下基础数据类型包装类是怎么计算hashCode的：</p><ul><li><p>Boolean</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> value ? <span class="number">1231</span> : 1237;</span><br></pre></td></tr></table></figure></li><li><p>Character</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Byte</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)<span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></li><li><p>Short</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)<span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></li><li><p>Integer</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></li><li><p>Long</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return (<span class="name">int</span>)(<span class="name">value</span> ^ (<span class="name">value</span> &gt;&gt;&gt; <span class="number">32</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>Float</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">floatToIntBits</span><span class="params">(value)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>Double</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long bits = doubleToLongBits(<span class="name">value</span>)<span class="comment">;</span></span><br><span class="line">return (<span class="name">int</span>)(<span class="name">bits</span> ^ (<span class="name">bits</span> &gt;&gt;&gt; <span class="number">32</span>))<span class="comment">;L</span></span><br></pre></td></tr></table></figure></li><li><p>再看看String，池里有就直接拿，池里没有才计算累加</p></li></ul><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">int</span> h = hash;</span><br><span class="line">       <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; <span class="keyword">value</span>.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">char</span> val[] = <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">value</span>.length; i++) &#123;</span><br><span class="line">               h = <span class="number">31</span> * h + val[i];</span><br><span class="line">           &#125;</span><br><span class="line">           hash = h;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="由equals和-引出的问题-A-pool-of-strings（字符串池）"><a href="#由equals和-引出的问题-A-pool-of-strings（字符串池）" class="headerlink" title="由equals和==引出的问题 - A pool of strings（字符串池）"></a>由equals和==引出的问题 - A pool of strings（字符串池）</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"引用同一实例："</span>)<span class="comment">;</span></span><br><span class="line">String a = <span class="string">"abcd"</span><span class="comment">;</span></span><br><span class="line">String <span class="keyword">b </span>= <span class="string">"abcd"</span><span class="comment">;</span></span><br><span class="line">System.out.println(a == <span class="keyword">b);</span></span><br><span class="line"><span class="keyword">System.out.println(a.equals(b));</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">System.out.println("创建新实例：");</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">a1</span> = new String(<span class="string">"abcd"</span>)<span class="comment">;</span></span><br><span class="line">String <span class="keyword">b1 </span>= new String(<span class="string">"abcd"</span>)<span class="comment">;</span></span><br><span class="line">System.out.println(<span class="built_in">a1</span> == <span class="keyword">b1);</span></span><br><span class="line"><span class="keyword">System.out.println(a1.equals(b1));</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">System.out.println("从字符串池中拿对象：");</span></span><br><span class="line"><span class="keyword">String </span><span class="built_in">a2</span> = <span class="string">"abcd"</span><span class="comment">;</span></span><br><span class="line">String <span class="keyword">b2 </span>= new String(<span class="string">"abcd"</span>)<span class="comment">;</span></span><br><span class="line"><span class="keyword">b2 </span>= <span class="keyword">b2.intern();</span></span><br><span class="line"><span class="keyword">System.out.println(a2 </span>== <span class="keyword">b2);</span></span><br><span class="line"><span class="keyword">System.out.println(a2.equals(b2));</span></span><br></pre></td></tr></table></figure><p><em>运行结果</em></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">引用同一实例：</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="string">创建新实例：</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="string">从字符串池中拿对象：</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这说明非创建新实例的操作，会从字符串池中拿对象。</p><p>看一下intern()方法的注释，</p><blockquote></blockquote><pre><code>Returns a canonical representation for the string object.* &lt;p&gt;* A pool of strings, initially empty, is maintained privately by the* class {@code String}.* &lt;p&gt;* When the intern method is invoked, if the pool already contains a* string equal to this {@code String} object as determined by* the {@link #equals(Object)} method, then the string from the pool is* returned. Otherwise, this {@code String} object is added to the* pool and a reference to this {@code String} object is returned.* &lt;p&gt;* It follows that for any two strings {@code s} and {@code t},* {@code s.intern() == t.intern()} is {@code true}* if and only if {@code s.equals(t)} is {@code true}.* &lt;p&gt;* All literal strings and string-valued constant expressions are* interned. String literals are defined in section 3.10.5 of the* &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.** @return  a string that has the same contents as this string, but is*          guaranteed to be from a pool of unique strings.</code></pre><p>翻译大致如下：</p><blockquote></blockquote><pre><code>String类自己维护了一个字符串池，在初始化时是空的。当intern方法被调用时，如果池中包含一个与传入字符串相等的字符串，那么直接返回该字符串。对于任意两个相等(equals)的字符串，他们的intern()都相等(==)。所有的字面声明（双引号声明）字符串和常量字符串都会维护在字符串池中。字面声明字符串在Java语言规范的第3.10.5节中声明。保证从唯一的字符串池中返回一个与该字符串内容相同的字符串。</code></pre><h1 id="String，StringBuffer和StringBuilder的区别"><a href="#String，StringBuffer和StringBuilder的区别" class="headerlink" title="String，StringBuffer和StringBuilder的区别"></a>String，StringBuffer和StringBuilder的区别</h1><ul><li>String是不可变的，char[] value是被final修饰，所以是线程安全的。</li><li>他们都实现了CharSequence接口，而StringBuffer和StringBuilder继承了AbstractStringBuilder类并实现了Appendable接口。</li><li>StringBuffer和StringBuilder的append()方法都是调父类AbstractStringBuilder中的append()方法，StringBuffer的append()方法加了synchronized同步锁，所以线程安全，效率低。</li></ul><p><em>StringBuffer:</em><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">       toStringCache = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p><em>StringBuilder:</em><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="built_in">append</span>(<span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="built_in">append</span>(<span class="built_in">str</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>那么为什么String的 + 这种运算效率非常低呢？</li></ul><p>1.常量相加 - 虚拟机是会优化成常量返回的。</p><p>2.变量相加 - 虚拟机是会优化成创建StringBuilder对象的append()方法操作的，一般所说的 String 采用连接运算符（+）效率低下主要产生在以下的情况中：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">100</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">    s += <span class="string">"a"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每做一次 + 就产生个 StringBuilder 对象，然后 append 后就扔掉。下次循环再到达时重新产生个 StringBuilder 对象，然后 append 字符串，如此循环直至结束。<br>如果我们直接采用 StringBuilder 对象进行 append 的话，我们可以节省 N - 1 次创建和销毁对象的时间。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java" scheme="http://tech.nitaoge.com/categories/java/"/>
    
    
      <category term="看破Java" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4Java/"/>
    
  </entry>
  
  <entry>
    <title>看破Java 3.JDK8 Core</title>
    <link href="http://tech.nitaoge.com/p/c46700a5/"/>
    <id>http://tech.nitaoge.com/p/c46700a5/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-15T15:59:23.586Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java" scheme="http://tech.nitaoge.com/categories/java/"/>
    
    
      <category term="看破Java" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4Java/"/>
    
  </entry>
  
  <entry>
    <title>看破Java 5.IO、Socket</title>
    <link href="http://tech.nitaoge.com/p/6a43eebc/"/>
    <id>http://tech.nitaoge.com/p/6a43eebc/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-16T02:36:42.025Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java" scheme="http://tech.nitaoge.com/categories/java/"/>
    
    
      <category term="看破Java" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4Java/"/>
    
  </entry>
  
  <entry>
    <title>看破Java 6.NIO</title>
    <link href="http://tech.nitaoge.com/p/e269c416/"/>
    <id>http://tech.nitaoge.com/p/e269c416/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-16T02:36:42.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java" scheme="http://tech.nitaoge.com/categories/java/"/>
    
    
      <category term="看破Java" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4Java/"/>
    
  </entry>
  
  <entry>
    <title>看破Java 7.AIO</title>
    <link href="http://tech.nitaoge.com/p/d455aa9b/"/>
    <id>http://tech.nitaoge.com/p/d455aa9b/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-16T02:36:42.018Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="java" scheme="http://tech.nitaoge.com/categories/java/"/>
    
    
      <category term="看破Java" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4Java/"/>
    
  </entry>
  
  <entry>
    <title>看破Jenkins 1.快速安装及使用</title>
    <link href="http://tech.nitaoge.com/p/17293ae1/"/>
    <id>http://tech.nitaoge.com/p/17293ae1/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-15T15:59:23.587Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="jenkins" scheme="http://tech.nitaoge.com/categories/jenkins/"/>
    
    
      <category term="看破Jenkins" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>看破JVM 1.</title>
    <link href="http://tech.nitaoge.com/p/fc61a33c/"/>
    <id>http://tech.nitaoge.com/p/fc61a33c/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-15T15:59:23.587Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="jvm" scheme="http://tech.nitaoge.com/categories/jvm/"/>
    
    
      <category term="看破JVM" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4JVM/"/>
    
  </entry>
  
  <entry>
    <title>看破设计模式 1.设计原则</title>
    <link href="http://tech.nitaoge.com/p/3e610103/"/>
    <id>http://tech.nitaoge.com/p/3e610103/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-16T02:36:42.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="单一职责原则（Single-Responsibility-Principle）SRP"><a href="#单一职责原则（Single-Responsibility-Principle）SRP" class="headerlink" title="单一职责原则（Single Responsibility Principle）SRP"></a>单一职责原则（Single Responsibility Principle）SRP</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p>There should never be more than one reason for a class to change.</p></blockquote><p>一个类只干一个事儿。 </p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>类的复杂性降低，职责清晰，增强可读性。</li><li>解耦，提高可维护性。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个原则同样适用于类和方法。</p><h1 id="里氏替换原则（Liskov-Substitution-Principle）LSP"><a href="#里氏替换原则（Liskov-Substitution-Principle）LSP" class="headerlink" title="里氏替换原则（Liskov Substitution Principle）LSP"></a>里氏替换原则（Liskov Substitution Principle）LSP</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote><p>If for each object o1 of type S there is an object o2 of<br>type T such that for all programs P defined in terms of T,<br>the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</p></blockquote><p>如果对每一个类型为S的对象o1， 都有类型为T的对象o2，<br>使得以T定义的所有程序P在所有的对象o1都代换成o2时，<br>程序P的行为没有发生变化， 那么类型S是类型T的子类型。 </p><p>换句人话讲，所有引用基类的地方必须能透明地使用其子类的对象。</p><p>包含以下4层含义：</p><ul><li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul><li>明确类的定义和方法的行为，有利于复用，而且保证父子类行为一致。</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>里氏替换原则的提出主要是为了解决因继承不当导致的父子类行为不一致、运行结果与预期不符的问题。</p><p>说白了，就是父类的方法尽量别动。</p><h1 id="依赖倒置原则（Dependence-Inversion-Principle）DIP"><a href="#依赖倒置原则（Dependence-Inversion-Principle）DIP" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle）DIP"></a>依赖倒置原则（Dependence Inversion Principle）DIP</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><blockquote><p>High level modules should not depend upon low level modules.Both should depend upon<br>abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.</p></blockquote><p>包含以下3层含义：</p><ul><li>高层模块不应该依赖低层模块， 两者都应该依赖其抽象；</li><li>抽象不应该依赖细节；</li><li>细节应该依赖抽象。</li></ul><p>底层模块：每一个逻辑的实现都是由不可分割的原子逻辑组成的，不可分割的原子逻辑就是底层模块。<br>高层模块：由原子逻辑再组装就是高层模块。<br>抽象：即抽象类或接口，两者是不能够实例化的。<br>细节：即具体的实现类，实现接口或者继承抽象类所产生的类，两者可以通过关键字new直接被实例化。</p><p>最灵活的方式就是Setter方法传递依赖对象，当然如果不想提供灵活变更，可以在构造体中注入，参考代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDriver</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">implements</span> <span class="title">IDriver</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> ICar car;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(ICar car)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.car.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICar</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">implements</span> <span class="title">ICar</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"奔驰汽车开始运行..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BMW</span> <span class="keyword">implements</span> <span class="title">ICar</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"宝马汽车开始运行..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">IDriver driver = <span class="keyword">new</span> Driver();</span><br><span class="line">ICar benz = <span class="keyword">new</span> Benz();</span><br><span class="line">driver.drive(benz);</span><br><span class="line">ICar benz = <span class="keyword">new</span> BMW();</span><br><span class="line">driver.drive(benz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h2><ul><li>解耦，避免动一处而伤全身。</li></ul><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>目的就是为了解耦，封装工具类和建立管道模型就遵循这种原则。</p><h1 id="接口隔离原则（Interface-Segregation-Principles）ISP"><a href="#接口隔离原则（Interface-Segregation-Principles）ISP" class="headerlink" title="接口隔离原则（Interface Segregation Principles）ISP"></a>接口隔离原则（Interface Segregation Principles）ISP</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><blockquote><p>Clients should not be forced to depend upon interfaces that they don’t use.</p></blockquote><blockquote><p>The dependency of one class to another one should depend on the smallest possible interface.</p></blockquote><p>包含以下2层含义：</p><ul><li>客户端不应该强行依赖它不需要的接口。</li><li>类间的依赖关系应该建立在最小的接口上。</li></ul><p>含义比较明确，尽量把接口拆得足够细，参考代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">I3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">I1</span>,<span class="title">I2</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Class A - method1()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Class A - method2()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I2</span>,<span class="title">I3</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Class B - method2()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Class B - method3()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h2><ul><li>减少代码量，避免实现无必要的方法。</li></ul><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>与单一职责原则很像，但还是有些区别的。</p><p>单一职责原则针对的是类和方法；而接口隔离原则针对的是接口。</p><h1 id="迪米特法则（Least-Knowledge-Principle）LKP"><a href="#迪米特法则（Least-Knowledge-Principle）LKP" class="headerlink" title="迪米特法则（Least Knowledge Principle）LKP"></a>迪米特法则（Least Knowledge Principle）LKP</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><blockquote><p>Only talk to your immediate friends.</p></blockquote><p>一个类只和朋友交流。</p><p>意思就是尽量减少与其他类的依赖，像这样：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span> B b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">b.sayHello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">b.flyInTheSky();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h2><ul><li>解耦，不用管其他方法的实现，我只要用你提供的方法就行了。</li></ul><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>太简单不说了。</p><h1 id="开闭原则（Open-Closed-Principle）OCP"><a href="#开闭原则（Open-Closed-Principle）OCP" class="headerlink" title="开闭原则（Open-Closed Principle）OCP"></a>开闭原则（Open-Closed Principle）OCP</h1><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><blockquote><p>Software entities like classes,modules and functions should be open for extension but closed for<br>modifications.</p></blockquote><p>一个软件实体如类、 模块和函数应该对扩展开放，对修改关闭。</p><p>也就是说，当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p><p>上代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBook</span> &#123;</span><br><span class="line"><span class="comment">//书籍有名称</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">//书籍有售价</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">//书籍有作者</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NovelBook</span> <span class="title">implements</span> <span class="title">IBook</span> &#123;</span><br><span class="line"><span class="comment">//书籍名称</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//书籍的价格</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> price;</span><br><span class="line"><span class="comment">//书籍的作者</span></span><br><span class="line"><span class="keyword">private</span> String author;</span><br><span class="line"><span class="comment">//通过构造函数传递书籍数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NovelBook</span>(<span class="params">String _name,<span class="keyword">int</span> _price,String _author</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = _name;</span><br><span class="line"><span class="keyword">this</span>.price = _price;</span><br><span class="line"><span class="keyword">this</span>.author = _author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得作者是谁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//书籍叫什么名字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获得书籍的价格</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookStore</span> &#123;</span><br><span class="line"><span class="keyword">private</span> final <span class="keyword">static</span> ArrayList&lt;IBook&gt; bookList = <span class="keyword">new</span> ArrayList&lt;IBook&gt;();</span><br><span class="line"><span class="comment">//static静态模块初始化数据， 实际项目中一般是由持久层完成</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">bookList.<span class="keyword">add</span>(<span class="keyword">new</span> NovelBook(<span class="string">"天龙八部"</span>,<span class="number">3200</span>,<span class="string">"金庸"</span>));</span><br><span class="line">bookList.<span class="keyword">add</span>(<span class="keyword">new</span> NovelBook(<span class="string">"巴黎圣母院"</span>,<span class="number">5600</span>,<span class="string">"雨果"</span>));</span><br><span class="line">bookList.<span class="keyword">add</span>(<span class="keyword">new</span> NovelBook(<span class="string">"悲惨世界"</span>,<span class="number">3500</span>,<span class="string">"雨果"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟书店买书</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">NumberFormat formatter = NumberFormat.getCurrencyInstance();</span><br><span class="line">formatter.setMaximumFractionDigits(<span class="number">2</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"-----------书店卖出去的书籍记录如下： -----------"</span>);</span><br><span class="line"><span class="keyword">for</span>(IBook book:bookList)&#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"书籍名称： "</span> + book.getName()+<span class="string">"\t书籍作者： "</span></span><br><span class="line">book.getAuthor()+<span class="string">"\t书籍价格： "</span>+ formatter.format (book.getPrice()/</span><br><span class="line"><span class="number">100.0</span>)+<span class="string">"元"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OffNovelBook</span> <span class="title">extends</span> <span class="title">NovelBook</span> &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OffNovelBook</span>(<span class="params">String _name,<span class="keyword">int</span> _price,String _author</span>)</span>&#123;</span><br><span class="line">super(_name,_price,_author);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//覆写销售价格</span></span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//原价</span></span><br><span class="line"><span class="keyword">int</span> selfPrice = super.getPrice();</span><br><span class="line"><span class="keyword">int</span> offPrice=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(selfPrice&gt;<span class="number">4000</span>)&#123; <span class="comment">//原价大于40元， 则打9折</span></span><br><span class="line">offPrice = selfPrice * <span class="number">90</span> /<span class="number">100</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">offPrice = selfPrice * <span class="number">80</span> /<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> offPrice;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BookStore</span> &#123;</span><br><span class="line"><span class="keyword">private</span> final <span class="keyword">static</span> ArrayList&lt;IBook&gt; bookList = <span class="keyword">new</span> ArrayList&lt;IBook&gt;();</span><br><span class="line"><span class="comment">//static静态模块初始化数据， 实际项目中一般是由持久层完成</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">bookList.<span class="keyword">add</span>(<span class="keyword">new</span> OffNovelBook(<span class="string">"天龙八部"</span>,<span class="number">3200</span>,<span class="string">"金庸"</span>));</span><br><span class="line">bookList.<span class="keyword">add</span>(<span class="keyword">new</span> OffNovelBook(<span class="string">"巴黎圣母院"</span>,<span class="number">5600</span>,<span class="string">"雨果"</span>));</span><br><span class="line">bookList.<span class="keyword">add</span>(<span class="keyword">new</span> OffNovelBook(<span class="string">"悲惨世界"</span>,<span class="number">3500</span>,<span class="string">"雨果"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟书店买书</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">NumberFormat formatter = NumberFormat.getCurrencyInstance();</span><br><span class="line">formatter.setMaximumFractionDigits(<span class="number">2</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"-----------书店卖出去的书籍记录如下： -----------"</span>);</span><br><span class="line"><span class="keyword">for</span>(IBook book:bookList)&#123;</span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="string">"书籍名称： "</span> + book.getName()+<span class="string">"\t书籍作者： "</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h2><ul><li>减少出现不必要问题的几率，避免节外生枝。</li></ul><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>设计模式不必局限于这六大原则，要活学活用。</p><p>在读过一些优秀的开源框架源码之后，潜移默化地形成这种设计思维，运用到开发中即可。</p><h1 id="合成复用原则（Composite-Reuse-Principle）CRP"><a href="#合成复用原则（Composite-Reuse-Principle）CRP" class="headerlink" title="合成复用原则（Composite Reuse Principle）CRP"></a>合成复用原则（Composite Reuse Principle）CRP</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p>要尽量使用合成和聚合，尽量不要使用继承。</p><h2 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h2><ul><li>不使用继承，不破坏类的封装性。</li><li>可扩展性强，修改单一模块对全局影响不大。</li></ul><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://product.dangdang.com/23427545.html" target="_blank" rel="noopener">设计模式之禅（第2版）</a></p><p>设计模式之禅这本书，我读到第9章抽象工厂的时候，就发现作者有点开始扯犊子了。<br>他的思路并不清晰，人的思路一旦不清晰就容易含糊其辞，<br>试图通过列举怪力乱神、妖魔鬼怪等反科学、伪实践的例子来说服读者……果断扔了</p><p><a href="http://cmsblogs.com/?p=3396" target="_blank" rel="noopener">设计模式读书笔记文集</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="design" scheme="http://tech.nitaoge.com/categories/design/"/>
    
    
      <category term="看破设计模式" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>看破并发 1.基本概念</title>
    <link href="http://tech.nitaoge.com/p/71b6f09d/"/>
    <id>http://tech.nitaoge.com/p/71b6f09d/</id>
    <published>2019-03-22T12:06:26.000Z</published>
    <updated>2019-04-16T02:36:42.015Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p># </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="concurrent" scheme="http://tech.nitaoge.com/categories/concurrent/"/>
    
    
      <category term="看破并发" scheme="http://tech.nitaoge.com/tags/%E7%9C%8B%E7%A0%B4%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
