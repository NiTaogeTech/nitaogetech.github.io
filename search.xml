<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[看破Nginx 1.快速安装及使用]]></title>
    <url>%2Fp%2F2cd31133%2F</url>
    <content type="text"><![CDATA[准备安装使用yum安装（默认有些模块不会安装，所以推荐编译源码安装）设置yum源，添加以下内容：12345678910111213# vim /etc/yum.repos.d/nginx.repo[nginx-stable] name = nginx stable repo baseurl = http：//nginx.org/packages/centos/$releasever/$basearch/gpgcheck = 1 enabled = 1 gpgkey = https://nginx.org/keys/nginx_signing。 key [nginx-mainline] name = nginx mainline repo baseurl = http：//nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck = 1 enabled = 0 gpgkey = https://nginx.org/keys /nginx_signing.key 安装：1# yum install nginx -y 默认情况启用稳定版nginx的yum源。如果要使用主线nginx的yum源，执行：1# yum-config-manager --enable nginx-mainline 使用源码安装从nginx官方下载页下载指定版本的包，通过configure文件配置指定参数，使用make编译。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254# wget http://nginx.org/download/nginx-1.16.0.tar.gz# tar -zxf nginx-1.16.0.tar.gz -C /disk1/app/# cd /disk1/app/nginx-1.16.0# ./configure --sbin-path=/usr/local/nginx/nginx --conf-path=/usr/local/nginx/nginx.conf --pid-path=/usr/local/nginx/nginx.pid --with-http_ssl_module --with-pcre=../pcre-8.42 --with-zlib=../zlib-1.2.11# makeconfigure命令支持以下参数：--help打印帮助信息。--prefix=path定义将保留服务器文件的目录。同一目录也将用于设置的所有相对路径 configure（库源路径除外）和nginx.conf配置文件中。它/usr/local/nginx默认设置为目录。--sbin-path=path设置nginx可执行文件的名称。此名称仅在安装期间使用。默认情况下，该文件已命名 prefix/sbin/nginx。--modules-path=path定义将安装nginx动态模块的目录。默认情况下，prefix/modules使用该目录。--conf-path=path设置nginx.conf配置文件的名称。如果需要，可以始终使用不同的配置文件启动nginx，方法是在命令行参数中指定它 。默认情况下，该文件已命名 。 -c fileprefix/conf/nginx.conf--error-log-path=path设置主要错误，警告和诊断文件的名称。安装后，可以nginx.conf使用error_log指令在配置文件中 更改文件名 。默认情况下，该文件已命名 prefix/logs/error.log。--pid-path=path设置nginx.pid将存储主进程的进程ID 的文件的名称。安装后，可以nginx.conf使用pid指令在配置文件中 更改文件名 。默认情况下，该文件已命名 prefix/logs/nginx.pid。--lock-path=path为锁定文件的名称设置前缀。安装后，可以nginx.conf使用lock_file指令在配置文件中 始终更改该值 。默认情况下，该值为 prefix/logs/nginx.lock。--user=name设置非特权用户的名称，其凭据将由工作进程使用。安装后，可以nginx.conf使用user指令在配置文件中 更改名称 。默认用户名是nobody。--group=name设置工作进程将使用其凭据的组的名称。安装后，可以nginx.conf使用user指令在配置文件中 更改名称 。默认情况下，组名称设置为非特权用户的名称。--build=name设置可选的nginx构建名称。--builddir=path设置构建目录。--with-select_module--without-select_module启用或禁用构建允许服务器使用该select()方法的模块。如果平台似乎不支持更合适的方法（如kqueue，epoll或/ dev / poll），则会自动构建此模块。--with-poll_module--without-poll_module启用或禁用构建允许服务器使用该poll()方法的模块。如果平台似乎不支持更合适的方法（如kqueue，epoll或/ dev / poll），则会自动构建此模块。--with-threads允许使用 线程池。--with-file-aio允许 在FreeBSD和Linux上使用 异步文件I / O（AIO）。--with-http_ssl_module允许构建一个模块，将HTTPS协议支持添加 到HTTP服务器。默认情况下不构建此模块。需要OpenSSL库来构建和运行此模块。--with-http_v2_module可以构建一个支持HTTP / 2的模块 。默认情况下不构建此模块。--with-http_realip_module允许构建ngx_http_realip_module 模块，该 模块将客户端地址更改为在指定的头字段中发送的地址。默认情况下不构建此模块。--with-http_addition_module允许构建ngx_http_addition_module 模块，该 模块在响应之前和之后添加文本。默认情况下不构建此模块。--with-http_xslt_module--with-http_xslt_module=dynamic允许构建 使用一个或多个XSLT样式表转换XML响应的 ngx_http_xslt_module模块。默认情况下不构建此模块。该libxml2的和 的libxslt库需要构建和运行此模块。--with-http_image_filter_module--with-http_image_filter_module=dynamic可以构建ngx_http_image_filter_module 模块，该 模块可以转换JPEG，GIF，PNG和WebP格式的图像。默认情况下不构建此模块。--with-http_geoip_module--with-http_geoip_module=dynamic允许构建ngx_http_geoip_module 模块，该 模块根据客户端IP地址和预编译的MaxMind数据库创建变量 。默认情况下不构建此模块。--with-http_sub_module允许构建ngx_http_sub_module 模块，该 模块通过将一个指定的字符串替换为另一个来修改响应。默认情况下不构建此模块。--with-http_dav_module支持构建ngx_http_dav_module 模块，该 模块通过WebDAV协议提供文件管理自动化。默认情况下不构建此模块。--with-http_flv_module支持构建ngx_http_flv_module 模块，该 模块为Flash Video（FLV）文件提供伪流服务器端支持。默认情况下不构建此模块。--with-http_mp4_module支持构建ngx_http_mp4_module 模块，该 模块为MP4文件提供伪流服务器端支持。默认情况下不构建此模块。--with-http_gunzip_module对于不支持“gzip”编码方法的客户端， 可以构建ngx_http_gunzip_module 模块，该 模块使用“ Content-Encoding: gzip” 解压缩响应。默认情况下不构建此模块。--with-http_gzip_static_module允许构建ngx_http_gzip_static_module 模块，该 模块允许使用“ .gz”文件扩展名而不是常规文件发送预压缩文件。默认情况下不构建此模块。--with-http_auth_request_module允许构建ngx_http_auth_request_module 模块，该 模块基于子请求的结果实现客户端授权。默认情况下不构建此模块。--with-http_random_index_module允许构建ngx_http_random_index_module 模块，该 模块处理以斜杠字符（' /'）结尾的请求，并选择目录中的随机文件作为索引文件。默认情况下不构建此模块。--with-http_secure_link_module可以构建 ngx_http_secure_link_module 模块。默认情况下不构建此模块。--with-http_degradation_module可以构建 ngx_http_degradation_module模块。默认情况下不构建此模块。--with-http_slice_module允许构建 将请求拆分为子请求的 ngx_http_slice_module模块，每个模块都返回一定范围的响应。该模块提供了更有效的大响应缓存。默认情况下不构建此模块。--with-http_stub_status_module可以构建ngx_http_stub_status_module 模块，该 模块提供对基本状态信息的访问。默认情况下不构建此模块。--without-http_charset_module禁用构建ngx_http_charset_module 模块，该 模块将指定的字符集添加到“Content-Type”响应头字段，并且还可以将数据从一个字符集转换为另一个字符集。--without-http_gzip_module禁用构建压缩 HTTP服务器响应的模块。zlib库是构建和运行此模块所必需的。--without-http_ssi_module禁用构建ngx_http_ssi_module 模块，该 模块在通过它的响应中处理SSI（服务器端包含）命令。--without-http_userid_module禁用构建ngx_http_userid_module 模块，该 模块设置适合客户端识别的cookie。--without-http_access_module禁用构建ngx_http_access_module 模块，该 模块允许限制对某些客户端地址的访问。--without-http_auth_basic_module禁用构建ngx_http_auth_basic_module 模块，该 模块允许通过使用“HTTP基本身份验证”协议验证用户名和密码来限制对资源的访问。--without-http_mirror_module禁用构建ngx_http_mirror_module 模块，该 模块通过创建后台镜像子请求来实现原始请求的镜像。--without-http_autoindex_module禁用构建ngx_http_autoindex_module 模块，该 模块处理以斜杠字符（' /'）结尾的请求，并在ngx_http_index_module模块找不到索引文件的情况下生成目录列表 。--without-http_geo_module禁用构建ngx_http_geo_module 模块，该 模块使用取决于客户端IP地址的值创建变量。--without-http_map_module禁用构建ngx_http_map_module 模块，该 模块使用取决于其他变量值的值创建变量。--without-http_split_clients_module禁用构建ngx_http_split_clients_module 模块，该 模块为A / B测试创建变量。--without-http_referer_module禁用构建ngx_http_referer_module 模块，该 模块可以阻止对“Referer”头字段中具有无效值的请求访问站点。--without-http_rewrite_module禁用构建允许HTTP服务器 重定向请求和更改请求URI的模块。需要PCRE库来构建和运行此模块。--without-http_proxy_module禁用构建HTTP服务器 代理模块。--without-http_fastcgi_module禁用构建 将请求传递给FastCGI服务器的 ngx_http_fastcgi_module模块。--without-http_uwsgi_module禁用构建 将请求传递给uwsgi服务器的 ngx_http_uwsgi_module模块。--without-http_scgi_module禁用构建 将请求传递给SCGI服务器的 ngx_http_scgi_module模块。--without-http_grpc_module禁用构建 将请求传递给gRPC服务器的 ngx_http_grpc_module模块。--without-http_memcached_module禁用构建ngx_http_memcached_module 模块，该 模块从memcached服务器获取响应。--without-http_limit_conn_module禁用构建ngx_http_limit_conn_module 模块，该 模块限制每个密钥的连接数，例如，来自单个IP地址的连接数。--without-http_limit_req_module禁用构建ngx_http_limit_req_module 模块，该 模块限制每个密钥的请求处理速率，例如，来自单个IP地址的请求的处理速率。--without-http_empty_gif_module禁用构建发出单像素透明GIF的模块 。--without-http_browser_module禁用构建ngx_http_browser_module 模块，该 模块创建的值的变量值取决于“User-Agent”请求标头字段的值。--without-http_upstream_hash_module禁用构建实现散列 负载平衡方法的模块 。--without-http_upstream_ip_hash_module禁用构建实现ip_hash 负载平衡方法的模块 。--without-http_upstream_least_conn_module禁用构建实现least_conn 负载平衡方法的模块 。--without-http_upstream_keepalive_module禁用构建一个模块，该模块提供 到上游服务器的连接缓存。--without-http_upstream_zone_module禁用构建模块，该模块可以将上游组的运行时状态存储在共享内存 区域中。--with-http_perl_module--with-http_perl_module=dynamic可以构建 嵌入式Perl模块。默认情况下不构建此模块。--with-perl_modules_path=path定义一个将保留Perl模块的目录。--with-perl=path设置Perl二进制文件的名称。--http-log-path=path设置HTTP服务器的主要请求日志文件的名称。安装后，可以nginx.conf使用access_log指令在配置文件中 更改文件名 。默认情况下，该文件已命名 prefix/logs/access.log。--http-client-body-temp-path=path定义用于存储保存客户端请求主体的临时文件的目录。安装后，可以nginx.conf使用client_body_temp_path 指令在配置文件中 更改目录 。默认情况下，该目录已命名 prefix/client_body_temp。--http-proxy-temp-path=path定义一个目录，用于存储临时文件和从代理服务器接收的数据。安装后，可以nginx.conf使用proxy_temp_path 指令在配置文件中 更改目录 。默认情况下，该目录已命名 prefix/proxy_temp。--http-fastcgi-temp-path=path定义一个目录，用于存储从FastCGI服务器接收的数据的临时文件。安装后，可以nginx.conf使用fastcgi_temp_path 指令在配置文件中 更改目录 。默认情况下，该目录已命名 prefix/fastcgi_temp。--http-uwsgi-temp-path=path定义一个目录，用于存储从uwsgi服务器接收的数据的临时文件。安装后，可以nginx.conf使用uwsgi_temp_path 指令在配置文件中 更改目录 。默认情况下，该目录已命名 prefix/uwsgi_temp。--http-scgi-temp-path=path定义用于存储临时文件的目录，其中包含从SCGI服务器接收的数据。安装后，可以nginx.conf使用scgi_temp_path 指令始终在配置文件中 更改目录 。默认情况下，该目录已命名 prefix/scgi_temp。--without-http禁用HTTP服务器。--without-http-cache禁用HTTP缓存。--with-mail--with-mail=dynamic启用POP3 / IMAP4 / SMTP 邮件代理服务器。--with-mail_ssl_module允许构建一个模块，将 SSL / TLS协议支持添加 到邮件代理服务器。默认情况下不构建此模块。需要OpenSSL库来构建和运行此模块。--without-mail_pop3_module禁用邮件代理服务器中的POP3协议。--without-mail_imap_module禁用邮件代理服务器中的IMAP协议。--without-mail_smtp_module禁用邮件代理服务器中的SMTP协议。--with-stream--with-stream=dynamic允许构建 流模块 以进行通用TCP / UDP代理和负载平衡。默认情况下不构建此模块。--with-stream_ssl_module可以构建一个模块， 为流模块添加 SSL / TLS协议支持。默认情况下不构建此模块。需要OpenSSL库来构建和运行此模块。--with-stream_realip_module启用构建ngx_stream_realip_module 模块，该 模块将客户端地址更改为PROXY协议头中发送的地址。默认情况下不构建此模块。--with-stream_geoip_module--with-stream_geoip_module=dynamic允许构建ngx_stream_geoip_module 模块，该 模块根据客户端IP地址和预编译的MaxMind数据库创建变量 。默认情况下不构建此模块。--with-stream_ssl_preread_module允许构建ngx_stream_ssl_preread_module 模块，该 模块允许从ClientHello 消息中提取信息 而不终止SSL / TLS。默认情况下不构建此模块。--without-stream_limit_conn_module禁用构建ngx_stream_limit_conn_module 模块，该 模块限制每个密钥的连接数，例如，来自单个IP地址的连接数。--without-stream_access_module禁用构建ngx_stream_access_module 模块，该 模块允许限制对某些客户端地址的访问。--without-stream_geo_module禁用构建ngx_stream_geo_module 模块，该 模块使用取决于客户端IP地址的值创建变量。--without-stream_map_module禁用构建ngx_stream_map_module 模块，该 模块根据其他变量的值创建值。--without-stream_split_clients_module禁用构建ngx_stream_split_clients_module 模块，该 模块为A / B测试创建变量。--without-stream_return_module禁用构建ngx_stream_return_module 模块，该 模块将一些指定值发送到客户端，然后关闭连接。--without-stream_upstream_hash_module禁用构建实现散列 负载平衡方法的模块 。--without-stream_upstream_least_conn_module禁用构建实现least_conn 负载平衡方法的模块 。--without-stream_upstream_zone_module禁用构建模块，该模块可以将上游组的运行时状态存储在共享内存 区域中。--with-google_perftools_module可以构建ngx_google_perftools_module 模块，该 模块可以使用Google Performance Tools分析nginx工作进程 。该模块适用于nginx开发人员，默认情况下不构建。--with-cpp_test_module可以构建 ngx_cpp_test_module模块。--add-module=path启用外部模块。--add-dynamic-module=path启用外部动态模块。--with-compat实现动态模块兼容性。--with-cc=path设置C编译器的名称。--with-cpp=path设置C预处理器的名称。--with-cc-opt=parameters设置将添加到CFLAGS变量的其他参数。在FreeBSD下使用系统PCRE库时， --with-cc-opt="-I /usr/local/include" 应该指定。如果select()需要增加支持的文件数，也可以在此处指定，例如： --with-cc-opt="-D FD_SETSIZE=2048"。--with-ld-opt=parameters设置将在链接期间使用的其他参数。在FreeBSD下使用系统PCRE库时， --with-ld-opt="-L /usr/local/lib" 应该指定。--with-cpu-opt=cpu支持按指定的CPU建设： pentium，pentiumpro， pentium3，pentium4， athlon，opteron， sparc32，sparc64， ppc64。--without-pcre禁用PCRE库的使用。--with-pcre强制使用PCRE库。--with-pcre=path设置PCRE库源的路径。需要从PCRE站点下载库分发（版本4.4 - 8.42） 并将其解压缩。其余的由nginx ./configure和 make。完成。该位置指令和 ngx_http_rewrite_module 模块中的正则表达式支持需要该库 。--with-pcre-opt=parameters为PCRE设置其他构建选项。--with-pcre-jit使用“即时编译”支持（1.1.12，pcre_jit指令）构建PCRE库 。--with-zlib=path设置zlib库源的路径。需要从zlib站点下载并提取库分发（版本1.1.3 - 1.2.11） 。其余的由nginx ./configure和 make。完成。ngx_http_gzip_module模块需要该库 。--with-zlib-opt=parameters为zlib设置其他构建选项。--with-zlib-asm=cpu使得能够使用指定的CPU中的一个优化的zlib汇编源程序： pentium，pentiumpro。--with-libatomic强制libatomic_ops库使用。--with-libatomic=path设置libatomic_ops库源的路径。--with-openssl=path设置OpenSSL库源的路径。--with-openssl-opt=parameters为OpenSSL设置其他构建选项。--with-debug启用调试日志。 配置启动参考资料 官方文档 《Nginx高性能Web服务器详解》 《精通Nginx(第2版)》 《深入理解Nginx模块开发与架构解析-第2版》]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>看破Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Docker 7.数据存储]]></title>
    <url>%2Fp%2F8c86c83d%2F</url>
    <content type="text"><![CDATA[启动方式]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>看破Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Docker 3.命令详解]]></title>
    <url>%2Fp%2F8491e96f%2F</url>
    <content type="text"><![CDATA[查看命令帮助查看docker所有子命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778$ docker --helpUsage: docker [OPTIONS] COMMANDA self-sufficient runtime for containersOptions: --config string Location of client config files (default "/home/nitaoge/.docker") -D, --debug Enable debug mode -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level ("debug"|"info"|"warn"|"error"|"fatal") (default "info") --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default "/home/nitaoge/.docker/ca.pem") --tlscert string Path to TLS certificate file (default "/home/nitaoge/.docker/cert.pem") --tlskey string Path to TLS key file (default "/home/nitaoge/.docker/key.pem") --tlsverify Use TLS and verify the remote -v, --version Print version information and quitManagement Commands: builder Manage builds config Manage Docker configs container Manage containers engine Manage the docker engine image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumesCommands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codesRun 'docker COMMAND --help' for more information on a command. 查看docker container所有子命令12345678910111213141516171819202122232425262728293031323334$ docker container --helpUsage: docker container COMMANDManage containersCommands: attach Attach local standard input, output, and error streams to a running container commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem exec Run a command in a running container export Export a container's filesystem as a tar archive inspect Display detailed information on one or more containers kill Kill one or more running containers logs Fetch the logs of a container ls List containers pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container prune Remove all stopped containers rename Rename a container restart Restart one or more containers rm Remove one or more containers run Run a command in a new container start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers wait Block until one or more containers stop, then print their exit codesRun 'docker container COMMAND --help' for more information on a command. 查看子命令12345678910$ docker start --helpUsage: docker start [OPTIONS] CONTAINER [CONTAINER...]Start one or more stopped containersOptions: -a, --attach Attach STDOUT/STDERR and forward signals --detach-keys string Override the key sequence for detaching a container -i, --interactive Attach container's STDIN 子命令分类 容器、镜像、仓库的操作关系 使用docker命令容器管理docker run（创建容器）1$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Options: –add-host list Add a custom host-to-IP mapping (host:ip) -a, –attach list Attach to STDIN, STDOUT or STDERR –blkio-weight uint16 Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0) –blkio-weight-device list Block IO weight (relative device weight) (default []) –cap-add list Add Linux capabilities –cap-drop list Drop Linux capabilities –cgroup-parent string Optional parent cgroup for the container –cidfile string Write the container ID to the file –cpu-period int Limit CPU CFS (Completely Fair Scheduler) period –cpu-quota int Limit CPU CFS (Completely Fair Scheduler) quota –cpu-rt-period int Limit CPU real-time period in microseconds –cpu-rt-runtime int Limit CPU real-time runtime in microseconds -c, –cpu-shares int CPU shares (relative weight) –cpus decimal Number of CPUs –cpuset-cpus string CPUs in which to allow execution (0-3, 0,1) –cpuset-mems string MEMs in which to allow execution (0-3, 0,1) -d, –detach Run container in background and print container ID –detach-keys string Override the key sequence for detaching a container –device list Add a host device to the container –device-cgroup-rule list Add a rule to the cgroup allowed devices list –device-read-bps list Limit read rate (bytes per second) from a device (default []) –device-read-iops list Limit read rate (IO per second) from a device (default []) –device-write-bps list Limit write rate (bytes per second) to a device (default []) –device-write-iops list Limit write rate (IO per second) to a device (default []) –disable-content-trust Skip image verification (default true) –dns list Set custom DNS servers –dns-option list Set DNS options –dns-search list Set custom DNS search domains –entrypoint string Overwrite the default ENTRYPOINT of the image -e, –env list Set environment variables –env-file list Read in a file of environment variables –expose list Expose a port or a range of ports –group-add list Add additional groups to join –health-cmd string Command to run to check health –health-interval duration Time between running the check (ms|s|m|h) (default 0s) –health-retries int Consecutive failures needed to report unhealthy –health-start-period duration Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s) –health-timeout duration Maximum time to allow one check to run (ms|s|m|h) (default 0s) –help Print usage -h, –hostname string Container host name –init Run an init inside the container that forwards signals and reaps processes -i, –interactive Keep STDIN open even if not attached –ip string IPv4 address (e.g., 172.30.100.104) –ip6 string IPv6 address (e.g., 2001:db8::33) –ipc string IPC mode to use –isolation string Container isolation technology –kernel-memory bytes Kernel memory limit -l, –label list Set meta data on a container –label-file list Read in a line delimited file of labels –link list Add link to another container –link-local-ip list Container IPv4/IPv6 link-local addresses –log-driver string Logging driver for the container –log-opt list Log driver options –mac-address string Container MAC address (e.g., 92:d0:c6:0a:29:33) -m, –memory bytes Memory limit –memory-reservation bytes Memory soft limit –memory-swap bytes Swap limit equal to memory plus swap: ‘-1’ to enable unlimited swap –memory-swappiness int Tune container memory swappiness (0 to 100) (default -1) –mount mount Attach a filesystem mount to the container –name string Assign a name to the container –network string Connect a container to a network (default “default”) –network-alias list Add network-scoped alias for the container –no-healthcheck Disable any container-specified HEALTHCHECK –oom-kill-disable Disable OOM Killer –oom-score-adj int Tune host’s OOM preferences (-1000 to 1000) –pid string PID namespace to use –pids-limit int Tune container pids limit (set -1 for unlimited) –privileged Give extended privileges to this container -p, –publish list Publish a container’s port(s) to the host -P, –publish-all Publish all exposed ports to random ports –read-only Mount the container’s root filesystem as read only –restart string Restart policy to apply when a container exits (default “no”) –rm Automatically remove the container when it exits –runtime string Runtime to use for this container –security-opt list Security Options –shm-size bytes Size of /dev/shm –sig-proxy Proxy received signals to the process (default true) –stop-signal string Signal to stop a container (default “SIGTERM”) –stop-timeout int Timeout (in seconds) to stop a container –storage-opt list Storage driver options for the container –sysctl map Sysctl options (default map[]) –tmpfs list Mount a tmpfs directory -t, –tty Allocate a pseudo-TTY –ulimit ulimit Ulimit options (default []) -u, –user string Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;]) –userns string User namespace to use –uts string UTS namespace to use -v, –volume list Bind mount a volume –volume-driver string Optional volume driver for the container –volumes-from list Mount volumes from the specified container(s) -w, –workdir string Working directory inside the container 比如： 12$ docker run -it -d --name testubt ubuntu /bin/bash$ docker run -d -p 80:80 --name ng1 nginx -i 进行交互模式-t 以伪终端模式-d 容器后台运行-p 端口映射 docker ps（查看容器进程状态）1$ docker ps [OPTIONS] Options: -a, –all Show all containers (default shows just running) -f, –filter filter Filter output based on conditions provided –format string Pretty-print containers using a Go template -n, –last int Show n last created containers (includes all states) (default -1) -l, –latest Show the latest created container (includes all states) –no-trunc Don’t truncate output -q, –quiet Only display numeric IDs -s, –size Display total file sizes docker start/stop/restart/kill（容器启停）1$ docker start [OPTIONS] CONTAINER [CONTAINER...] Options: -a, –attach Attach STDOUT/STDERR and forward signals –detach-keys string Override the key sequence for detaching a container -i, –interactive Attach container’s STDIN 1$ docker stop [OPTIONS] CONTAINER [CONTAINER...] Options: -t, –time int Seconds to wait for stop before killing it (default 10) 1$ docker restart [OPTIONS] CONTAINER [CONTAINER...] Options: -t, –time int Seconds to wait for stop before killing the container (default 10) 1$ docker kill [OPTIONS] CONTAINER [CONTAINER...] Options: -s, –signal string Signal to send to the container (default “KILL”) stop是优雅关闭，kill是发送kill信号。 docker logs（查看容器日志）1$ docker logs [OPTIONS] CONTAINER Options: –details Show extra details provided to logs -f, –follow Follow log output –since string Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) –tail string Number of lines to show from the end of the logs (default “all”) -t, –timestamps Show timestamps –until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) docker exec（在容器中执行命令）1$ docker exec [OPTIONS] CONTAINER COMMAND [ARG...] Options: -d, –detach Detached mode: run command in the background –detach-keys string Override the key sequence for detaching a container -e, –env list Set environment variables -i, –interactive Keep STDIN open even if not attached –privileged Give extended privileges to the command -t, –tty Allocate a pseudo-TTY -u, –user string Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;]) -w, –workdir string Working directory inside the container 比如： 1$ docker exec -it ng1 /bin/bash 在容器中安装应用 12$ apt update$ apt install vim -y docker rm（删除容器）1$ docker rm [OPTIONS] CONTAINER [CONTAINER...] Options: -f, –force Force the removal of a running container (uses SIGKILL) -l, –link Remove the specified link -v, –volumes Remove the volumes associated with the container docker commit（将容器制作为新镜像）1$ docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] Options: -a, –author string Author (e.g., “John Hannibal Smith &#104;&#97;&#110;&#x6e;&#105;&#98;&#x61;&#108;&#x40;&#x61;&#x2d;&#x74;&#x65;&#x61;&#109;&#x2e;&#99;&#111;&#109;“) -c, –change list Apply Dockerfile instruction to the created image -m, –message string Commit message -p, –pause Pause container during commit (default true) 比如： 1$ docker commit ng1 new-nginx 镜像管理docker pull/push（镜像推拉）1$ docker pull [OPTIONS] NAME[:TAG|@DIGEST] Options: -a, –all-tags Download all tagged images in the repository –disable-content-trust Skip image verification (default true) 1$ docker push [OPTIONS] NAME[:TAG] Options: –disable-content-trust Skip image signing (default true) docker search（查找镜像）1$ docker search [OPTIONS] TERM Options: -f, –filter filter Filter output based on conditions provided –format string Pretty-print search using a Go template –limit int Max number of search results (default 25) –no-trunc Don’t truncate output docker tag（制作版本标签）1$ docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] docker build（根据Dockerfile制作镜像）1$ docker build [OPTIONS] PATH | URL | - Options: –add-host list Add a custom host-to-IP mapping (host:ip) –build-arg list Set build-time variables –cache-from strings Images to consider as cache sources –cgroup-parent string Optional parent cgroup for the container –compress Compress the build context using gzip –cpu-period int Limit the CPU CFS (Completely Fair Scheduler) period –cpu-quota int Limit the CPU CFS (Completely Fair Scheduler) quota -c, –cpu-shares int CPU shares (relative weight) –cpuset-cpus string CPUs in which to allow execution (0-3, 0,1) –cpuset-mems string MEMs in which to allow execution (0-3, 0,1) –disable-content-trust Skip image verification (default true) -f, –file string Name of the Dockerfile (Default is ‘PATH/Dockerfile’) –force-rm Always remove intermediate containers –iidfile string Write the image ID to the file –isolation string Container isolation technology –label list Set metadata for an image -m, –memory bytes Memory limit –memory-swap bytes Swap limit equal to memory plus swap: ‘-1’ to enable unlimited swap –network string Set the networking mode for the RUN instructions during build (default “default”) –no-cache Do not use cache when building the image –pull Always attempt to pull a newer version of the image -q, –quiet Suppress the build output and print image ID on success –rm Remove intermediate containers after a successful build (default true) –security-opt strings Security options –shm-size bytes Size of /dev/shm -t, –tag list Name and optionally a tag in the ‘name:tag’ format –target string Set the target build stage to build. –ulimit ulimit Ulimit options (default []) docker rmi（删除镜像）1$ docker rmi [OPTIONS] IMAGE [IMAGE...] Options: -f, –force Force removal of the image –no-prune Do not delete untagged parents]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>看破Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Docker 6.网络]]></title>
    <url>%2Fp%2F1dfdbb87%2F</url>
    <content type="text"><![CDATA[启动方式]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>看破Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Docker 5.容器]]></title>
    <url>%2Fp%2F19fe1117%2F</url>
    <content type="text"><![CDATA[启动方式]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>看破Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Docker 1.基本概念及快速安装]]></title>
    <url>%2Fp%2F2a951b2f%2F</url>
    <content type="text"><![CDATA[基本概念Docker是什么？Docker是一个开发，运输和运行应用程序的开放平台。Docker使您可以将应用程序与基础架构分离，以便快速交付软件。使用Docker，您可以像管理应用程序一样管理基础架构。通过利用Docker的方法快速发送，测试和部署代码，您可以显着减少编写代码和在生产中运行代码之间的延迟。 总之Docker结合k8s用于自动化构建微服务架构。 Docker架构为了一统容器江山，Google、CoreOS、Docker等公司成立了一个名为Open Container Initiative（OCI）的组织，来制定容器规范，保证不同厂商开发的容器可移植。 目前OCI发布了两个规范：runtime spec（运行机制）和image format spec（镜像格式）。 Docker使用C/S架构。Docker客户端与Docker守护进程通信，后者负责构建，运行和分发Docker容器。Docker客户端和守护程序可以在同一系统上运行，也可以将Docker客户端连接到远程Docker守护程序。Docker客户端和守护程序使用REST API，通过UNIX套接字或网络接口进行通信。 架构包括： Docker守护进程（dockerd） Docker客户端（docker client） Docker镜像仓库（Registry） Docker容器对象（docker objects） 镜像 (images) 容器（containers） 容器API（services） 底层使用技术 namespaces cgroups UnionFS libcontainer 我的环境docker版本: 18.09.5内核版本: 3.10.0-862.el7.x86_64系统版本: CentOS Linux release 7.6.1810 (Core)CPU: Intel(R) Core(TM) i3-8100 CPU @ 3.60GHz 4核Memory: 16GDisk: 128G SSD(/)+1T SATA(/disk1) 安装准备内核支持Docker 对 Linux 内核版本的最低要求是3.10，如果内核版本低于 3.10 会缺少一些运行 Docker 容器的功能。这些比较旧的内核，在一定条件下会导致数据丢失和频繁恐慌错误。 推荐使用版本号为（3.x.y）的 3.10 Linux 内核版本（或者新的维护版本），保持跟上内核的次要版本更新来确保内核的BUG已经被修复。 系统要求 To install Docker CE, you need a maintained version of CentOS 7. Archived versions aren’t supported or tested.The centos-extras repository must be enabled. This repository is enabled by default, but if you have disabled it, you need to re-enable it. The overlay2 storage driver is recommended. centos-extras repository CentOS7默认是开启的，不用管它。 官方推荐的 overlay2 是一种文件存储驱动，CentOS老版本内核是不支持的，必须升到3.10以上，CentOS7.6默认是支持的，具体原理以后再深入。 卸载老版本 Older versions of Docker were called docker or docker-engine. If these are installed, uninstall them, along with associated dependencies.12345678$ sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine It’s OK if yum reports that none of these packages are installed. The contents of /var/lib/docker/, including images, containers, volumes, and networks, are preserved. The Docker CE package is now called docker-ce. 官方提供docker-ee（企业版）和docker-ce（社区版）两个版本，我选择docker-ce进行安装。 安装方式 You can install Docker CE in different ways, depending on your needs: Most users set up Docker’s repositories and install from them, for ease of installation and upgrade tasks. This is the recommended approach. Some users download the RPM package and install it manually and manage upgrades completely manually. This is useful in situations such as installing Docker on air-gapped systems with no access to the internet. In testing and development environments, some users choose to use automated convenience scripts to install Docker. 可以通过yum源安装，可以下载RPM包安装，也可以使用自动构建脚本安装。既然官方推荐使用yum源方式安装，那就听他的，本文使用yum源安装。 Before you install Docker CE for the first time on a new host machine, you need to set up the Docker repository. Afterward, you can install and update Docker from the repository. SET UP THE REPOSITORYInstall required packages. yum-utils provides the yum-config-manager utility, and device-mapper-persistent-data and lvm2 are required by the devicemapper storage driver.123$ sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 Use the following command to set up the stable repository.123$ sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo 确保系统中有yum-utils、device-mapper-persistent-data、lvm2工具，CentOS7.6默认是有的，然后添加docker的yum源即可（官方yum源有可能连接失败，可以使用阿里云的）。123# sudo yum-config-manager \ --add-repo \ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 添加持续集成和测试的版本库 Optional: Enable the nightly or test repositories. These repositories are included in the docker.repo file above but are disabled by default. You can enable them alongside the stable repository. The following command enables the nightly repository.1$ sudo yum-config-manager --enable docker-ce-nightly To enable the test channel, run the following command:1$ sudo yum-config-manager --enable docker-ce-test You can disable the nightly or test repository by running the yum-config-manager command with the –disable flag. To re-enable it, use the –enable flag. The following command disables the nightly repository.1$ sudo yum-config-manager --disable docker-ce-nightly Learn about nightly and test channels. 默认持续集成的版本和测试的版本在yum源配置文件中是禁用的。我不添加，我只用稳定版…… 安装 1.install the latest version of Docker CE and containerd, or go to the next step to install a specific version:1$ sudo yum install docker-ce docker-ce-cli containerd.io If prompted to accept the GPG key, verify that the fingerprint matches 060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35, and if so, accept it. Got multiple Docker repositories? If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command always installs the highest possible version, which may not be appropriate for your stability needs. Docker is installed but not started. The docker group is created, but no users are added to the group. 2.To install a specific version of Docker CE, list the available versions in the repo, then select and install: a. List and sort the versions available in your repo. This example sorts results by version number, highest to lowest, and is truncated:1$ sudo yum list docker-ce --showduplicates | sort -r docker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable The list returned depends on which repositories are enabled, and is specific to your version of CentOS (indicated by the .el7 suffix in this example). b. Install a specific version by its fully qualified package name, which is the package name (docker-ce) plus the version string (2nd column) starting at the first colon (:), up to the first hyphen, separated by a hyphen (-). For example, docker-ce-18.09.1.1$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io Docker is installed but not started. The docker group is created, but no users are added to the group. 可以查看可用版本，然后指定版本安装，安装完是不会启动的，创建了docker组，但是没有用户。 这里我选择安装最新版。 1$ sudo yum install docker-ce docker-ce-cli containerd.io 启动 3.Start Docker.1$ sudo systemctl start docker 4.Verify that Docker CE is installed correctly by running the hello-world image.1$ sudo docker run hello-world This command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits. Docker CE is installed and running. You need to use sudo to run Docker commands. Continue to Linux postinstall to allow non-privileged users to run Docker commands and for other optional configuration steps. 注意此处启动docker是使用的root用户，以后重点研究一下docker安全问题。 启动和测试，默认下载个test镜像然后在容器中运行它。 这里也可以不急着启动，先到Linux postinstall页面查看如何处理安装善后工作。 我启动之后拉不下来hello-world镜像，所以得配置国内镜像加速。 善后配置国内镜像加速1234567891011sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; "registry-mirrors": [ "https://需自己注册阿里云账号.mirror.aliyuncs.com", "https://registry.docker-cn.com" ]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 用普通用户管理docker Manage Docker as a non-root user The Docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo. The Docker daemon always runs as the root user.If you don’t want to preface the docker command with sudo, create a Unix group called docker and add users to it. When the Docker daemon starts, it creates a Unix socket accessible by members of the docker group. 默认情况下，docker守护进程绑定了一个unix套接字文件来代替tcp套接字，unix套接字属于root用户，其他用户访问必须使用sudo。docker守护进程总是使用root用户启动。如果你不想使用sudo，就建一个docker用户和组（安装后默认建完了），这样当Docker守护进程启动之后，就会创建一个可以让docker组成员访问的unix套接字文件。 Warning The docker group grants privileges equivalent to the root user. For details on how this impacts security in your system, see Docker Daemon Attack Surface. docker组被授予root同样的权限，如果使用tcp套接字对外开放端口，存在XSS问题。如果您明确决定这样做，也可以通过HTTP公开REST API。但是，如果您这样做，请注意上述安全隐患。确保只能从受信任的网络或VPN访问它，或者使用stunnel和客户端SSL证书等机制进行保护。您还可以使用HTTPS和证书保护API端点。 守护程序也可能容易受到其他输入的攻击，例如从带有docker load的磁盘加载映像，或者使用docker pull从网络加载。从Docker 1.3.2开始，图像现在在Linux / Unix平台上的chrooted子流程中提取，是更广泛地实现权限分离的第一步。从Docker 1.10.0开始，所有图像都通过其内容的加密校验和进行存储和访问，从而限制了攻击者与现有图像发生冲突的可能性。 最后，如果您在服务器上运行Docker，建议在服务器上独占运行Docker，并将所有其他服务移动到Docker控制的容器中。当然，保留您喜欢的管理工具（可能至少是SSH服务器）以及现有的监控/监督流程（例如NRPE和collectd）都可以。 To create the docker group and add your user: 1.Create the docker group.1$ sudo groupadd docker 这步可以略过。 2.Add your user to the docker group.1$ sudo usermod -aG docker $USER 添加当前登录用户到docker组。 3.Log out and log back in so that your group membership is re-evaluated. If testing on a virtual machine, it may be necessary to restart the virtual machine for changes to take effect.On a desktop Linux environment such as X Windows, log out of your session completely and then log back in. 注销重新登录。 4.Verify that you can run docker commands without sudo.1$ docker run hello-world This command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits. 测试是否正常运行。 If you initially ran Docker CLI commands using sudo before adding your user to the docker group, you may see the following error, which indicates that your ~/.docker/ directory was created with incorrect permissions due to the sudo commands. WARNING: Error loading config file: /home/user/.docker/config.json -stat /home/user/.docker/config.json: permission deniedTo fix this problem, either remove the ~/.docker/ directory (it is recreated automatically, but any custom settings are lost), or change its ownership and permissions using the following commands:12$ sudo chown "$USER":"$USER" /home/"$USER"/.docker -R$ sudo chmod g+rwx "$HOME/.docker" -R 如果出现权限问题，给刚加进docker组的当前登录普通用户赋权就完事。 配置开机启动 Most current Linux distributions (RHEL, CentOS, Fedora, Ubuntu 16.04 and higher) use systemd to manage which services start when the system boots. systemd1$ sudo systemctl enable docker To disable this behavior, use disable instead.1$ sudo systemctl disable docker CentOS7以后使用systemd做系统服务管理，配置简单。 配置Docker守护程序侦听连接的位置 By default, the Docker daemon listens for connections on a UNIX socket to accept requests from local clients. It is possible to allow Docker to accept requests from remote hosts by configuring it to listen on an IP address and port as well as the UNIX socket. For more detailed information on this configuration option take a look at “Bind Docker to another host/port or a unix socket” section of the Docker CLI Reference article. 默认情况下，Docker守护程序侦听UNIX套接字上的连接以接受来自本地客户端的请求。通过将Docker配置为侦听IP地址和端口以及UNIX套接字，可以允许Docker接受来自远程主机的请求。有关此配置选项的更多详细信息，请参阅Docker CLI参考文章中的“将Docker绑定到另一个主机/端口或unix套接字”部分。 Before configuring Docker to accept connections from remote hosts it is critically important that you understand the security implications of opening docker to the network. If steps are not taken to secure the connection, it is possible for remote non-root users to gain root access on the host. For more information on how to use TLS certificates to secure this connection, check this article on how to protect the Docker daemon socket. 在配置Docker以接受来自远程主机的连接之前，了解打开docker到网络的安全隐患至关重要。 如果不采取步骤来保护连接，则远程非root用户可以在主机上获得root访问权限。 有关如何使用TLS证书保护此连接的更多信息，请查看有关如何保护Docker守护程序套接字的文章。 Configuring Docker to accept remote connections can be done with the docker.service systemd unit file for Linux distributions using systemd, such as recent versions of RedHat, CentOS, Ubuntu and SLES, or with the daemon.json file which is recommended for Linux distributions that do not use systemd. 配置Docker以接受远程连接可以使用systemd的Linux发行版的docker.service systemd单元文件来完成，例如RedHat，CentOS，Ubuntu和SLES的最新版本，或者推荐用于Linux发行版的daemon.json文件。 不要使用systemd。 systemd vs daemon.jsonConfiguring Docker to listen for connections using both the systemd unit file and the daemon.json file causes a conflict that prevents Docker from starting. 同时使用systemd和daemon.json会使docker启动冲突。 既然官方推荐修改daemon.json开启远程访问，就听他的。 1.Set the hosts array in the /etc/docker/daemon.json to connect to the UNIX socket and an IP address, as follows:123&#123;"hosts": ["unix:///var/run/docker.sock", "tcp://127.0.0.1:2375"]&#125; 2.Restart Docker.12sudo systemctl daemon-reloadsudo systemctl restart docker 3.Check to see whether the change was honored by reviewing the output of netstat to confirm dockerd is listening on the configured port.12$ sudo netstat -lntp | grep dockerdtcp 0 0 127.0.0.1:2375 0.0.0.0:* LISTEN 3758/dockerd 这里使用不修改服务脚本的话，启动会失败，请参考2.服务配置。 内核兼容性检查 Docker cannot run correctly if your kernel is older than version 3.10 or if it is missing some modules. To check kernel compatibility, you can download and run the check-config.sh script.The script only works on Linux, not macOS. 123$ curl https://raw.githubusercontent.com/docker/docker/master/contrib/check-config.sh &gt; check-config.sh$ bash ./check-config.sh 更新 To upgrade Docker CE, follow the installation instructions, choosing the new version you want to install. 使用指定版本安装即可更新。 卸载 Uninstall the Docker package:1$ sudo yum remove docker-ce Images, containers, volumes, or customized configuration files on your host are not automatically removed. To delete all images, containers, and volumes:1$ sudo rm -rf /var/lib/docker 参考资料 docker官方文档 《每天5分钟玩转Docker容器技术》 k8s官方文档 《每天5分钟玩转Kubernetes》 《基于Kubernetes的容器云平台实战》]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>看破Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Docker 4.镜像]]></title>
    <url>%2Fp%2Ff6ac48d9%2F</url>
    <content type="text"><![CDATA[镜像结构 镜像是分层结构，目的是为了共享资源。 构建容器运行时镜像属于容器层，可读写；仓库中镜像属于镜像层，只读。 FROM scratch是从零开始构建，属于基础镜像。 docker运行的linux镜像都是独立用户空间，共享宿主机内核。 镜像构建docker commit（官方不推荐）详细参考3.命令详解。 Dockfile（推荐）]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>看破Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Docker 2.玩转配置]]></title>
    <url>%2Fp%2F24f59f15%2F</url>
    <content type="text"><![CDATA[服务配置查看服务状态123456789101112$ sudo systemctl status docker● docker.service - Docker Application Container Engine Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled) Active: active (running) since 日 2019-04-21 17:23:07 CST; 34min ago Docs: https://docs.docker.com Main PID: 20760 (dockerd) Tasks: 22 Memory: 251.7M CGroup: /system.slice/docker.service ├─20760 /usr/bin/dockerd -H fd:// -H tcp://192.168.1.60 └─20958 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 80 -container-ip 172.17.0.2 -container-port 80 我的docker服务启动脚本位置为/usr/lib/systemd/system/docker.service。 添加外网访问编辑服务脚本，添加允许外网访问（非安全的）：12345$ sudo vim /usr/lib/systemd/system/docker.service#ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sockExecStart=/usr/bin/dockerdExecReload=/bin/kill -s HUP $MAINPID 编辑daemon.json，添加一条配置：123$ sudo vim /etc/docker/daemon.json"hosts": ["unix:///var/run/docker.sock", "tcp://127.0.0.1:2375"] 重启12$ sudo systemctl daemon-reload$ sudo systemctl restart docker 查看连接12$ sudo netstat -lntp | grep dockerdtcp 0 0 192.168.1.60:2375 0.0.0.0:* LISTEN 6918/dockerd 修改镜像保存目录迁移原docker到新目录1$ mkdir -p /disk1/data &amp;&amp; mv /var/lib/docker /disk1/data 编辑daemon.json，添加一条配置：123$ sudo vim /etc/docker/daemon.json"data-root": "/disk1/data/docker" ##]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>看破Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Docker 8.XXXXX]]></title>
    <url>%2Fp%2Fa2e86a42%2F</url>
    <content type="text"><![CDATA[启动方式]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>看破Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Redis 1.快速安装及使用]]></title>
    <url>%2Fp%2F906310c9%2F</url>
    <content type="text"><![CDATA[背景公司要用Redis做数据库缓存双写，虽然不是我搞，但我不会多没有牌面啊……正所谓不积跬步无以至千里，不会原理下一个坑的就是你。 准备我这里装了三个虚拟机，并做了域名映射。 Centos7.6_1810vhost1、vhost2、vhost3每个都是1核2G 40G(系统盘)+60G(数据盘-挂到/disk1)为以后搭集群做准备。 不多哔哔，直接在虚拟机上开干，注意每次搞虚拟机前先拍快照。 快速开始下载Redis官网下载地址我本次下载最新版为redis-5.0.4.tar.gz 安装把包传到虚拟机scp redis-5.0.4.tar.gz root@vhost1:/disk1/pack 解压tar xzf redis-5.0.4.tar.gzcd redis-5.0.4 编译make clean &amp;&amp; make 配置备份原配置文件cp redis.conf redis.conf.bk 编辑配置文件vi redis.conf123456# 绑定地址（开外部访问）bind vhost1# 解除保护模式protected-mode no# 绑定端口port 6379 启动（守护进程）123src/redis-server或指定配置文件位置nohup src/redis-server redis.conf &amp; 这里可以把服务作为系统服务启动，后面再讲。 关闭每个服务启动都是作为一个系统进程并且有进程号(pid)的。1ps -ef | grep -v 'grep' | grep redis 其中2991就是进程号。1kill 2991 命令行客户端连接12345src/redis-cliredis&gt; set foo barOKredis&gt; get foo"bar" java连接集成jedis// TODO等有时间写个jedis客户端工具 集成spring-boot-starter-data-redis引包1compile group: 'org.springframework.boot', name: 'spring-boot-starter-data-redis', version: '2.1.3.RELEASE' 加配置12345678910redis: # redis host: vhost1 port: 6379 password: jedis: pool: max-active: 10 max-wait: -1 max-idle: 10 min-idle: 1 注入RedisTemplate或StringRedisTemplate直接使用，后续会仔细剖析二者区别12@Autowiredprivate StringRedisTemplate redisTemplate; 封装工具可参考whvcse/RedisUtil 总结 确定你刚装的虚拟机上有gcc，没有就装yum install -y gcc]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>看破Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Activiti 1.快速安装及使用]]></title>
    <url>%2Fp%2F21135a2b%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>activiti</category>
      </categories>
      <tags>
        <tag>看破Activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Apollo 1.快速安装及使用]]></title>
    <url>%2Fp%2F21135a2b%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>apollo</category>
      </categories>
      <tags>
        <tag>看破Apollo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破MySQL 2.基本概念、存储引擎]]></title>
    <url>%2Fp%2Fda0fe888%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>看破MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破MySQL 10.]]></title>
    <url>%2Fp%2Fd0b4f2a0%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>看破MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破MySQL 3.基本语法]]></title>
    <url>%2Fp%2F24df3a21%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>看破MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破MySQL 9.监控]]></title>
    <url>%2Fp%2Fe8112972%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>看破MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破MySQL 5.事务]]></title>
    <url>%2Fp%2F756621b4%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>看破MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破MySQL 8.调优]]></title>
    <url>%2Fp%2Fc17eb71a%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>看破MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破MySQL 7.高可用、容灾]]></title>
    <url>%2Fp%2Fef7fa5f2%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>看破MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破MySQL 6.binlog、分库分表、读写分离、数据安全]]></title>
    <url>%2Fp%2F7f1d7c1e%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>看破MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破MySQL 4.进阶]]></title>
    <url>%2Fp%2Fa4ca35ce%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>看破MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Netty 1.基本概念]]></title>
    <url>%2Fp%2Feb662d2f%2F</url>
    <content type="text"><![CDATA[#]]></content>
      <categories>
        <category>netty</category>
      </categories>
      <tags>
        <tag>看破Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破SpringCloud 1.快速安装及使用]]></title>
    <url>%2Fp%2F95e812ed%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>看破SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Zookeeper 1.快速安装及使用]]></title>
    <url>%2Fp%2F698730d5%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>看破Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Spring 1.快速安装及使用]]></title>
    <url>%2Fp%2F5384e89f%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>看破Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破IDEA 安装、使用、配置]]></title>
    <url>%2Fp%2F24280e36%2F</url>
    <content type="text"><![CDATA[为什么我改用IDEA？就eclipse每次打开都需要rebuild all projects，在网络环境及其恶劣的情况下，总是无故卡死，我就不想用它了。就这么倔！ 安装IDEA下载地址 这里有很多开发工具供你选择，我开发前后端分别用到了WebStorm和IDEA。 点击download来到下载选择页面，左边付费功能多，右边免费开源功能少。 windows程序目录如下，Mac的Contents结构也类似： 使用开始一个项目创建项目TODO 导入项目TODO 配置程序配置文件参数12345678910111213-Xms128m // 初始内存-Xmx750m // 最大内存-XX:ReservedCodeCacheSize=240m // 代码恢复缓存-XX:+UseConcMarkSweepGC // 设置老年代为并发收集-XX:SoftRefLRUPolicyMSPerMB=50-ea-Dsun.io.useCanonCaches=false-Djava.net.preferIPv4Stack=true-Djdk.http.auth.tunneling.disabledSchemes=""-XX:+HeapDumpOnOutOfMemoryError-XX:-OmitStackTraceInFastThrow-Dfile.encoding=UTF-8 // 文件编码集，解决控制台输出乱码问题-Deditable.java.test.console=true // 解决Junit @Test不能使用控制台输入问题 快捷键 常用快捷键 TODO 自定义快捷键 Settings -&gt; Keymap 代码模版 自定义代码模版 Settings -&gt; Editor -&gt; Live Templates]]></content>
      <categories>
        <category>devtool</category>
      </categories>
      <tags>
        <tag>看破IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破MySQL 1.快速安装及使用]]></title>
    <url>%2Fp%2F87c87cf%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>看破MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Jmeter 1.快速安装及使用]]></title>
    <url>%2Fp%2F1631c841%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>testtool</category>
      </categories>
      <tags>
        <tag>看破Jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破MacOS 1.快捷键]]></title>
    <url>%2Fp%2F91dc983c%2F</url>
    <content type="text"><![CDATA[快捷键打开Finderoption + command + space跳到指定目录shift + command + g 图示]]></content>
      <categories>
        <category>devtool</category>
      </categories>
      <tags>
        <tag>看破MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Git 2.基本功能]]></title>
    <url>%2Fp%2Fec441838%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>看破Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Gradle 1.快速安装及使用]]></title>
    <url>%2Fp%2F18a22795%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>看破Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Git 1.Git、GitLab快速安装及使用]]></title>
    <url>%2Fp%2Fa94eab5a%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>看破Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破并发 1.基本概念]]></title>
    <url>%2Fp%2F71b6f09d%2F</url>
    <content type="text"><![CDATA[#]]></content>
      <categories>
        <category>concurrent</category>
      </categories>
      <tags>
        <tag>看破并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破数据结构 1.线性表]]></title>
    <url>%2Fp%2Fe8093df2%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>datastucture</category>
      </categories>
      <tags>
        <tag>看破数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Java 4.集合]]></title>
    <url>%2Fp%2Fff55f559%2F</url>
    <content type="text"><![CDATA[下面对jdk8的集合做一次深入，所有传统集合都在rt.jar的java.util包中，1.5后开发的并发集合都在java.util.concurrent包中。 java.util.CollectionCollection接口继承Iterable接口，用于继承迭代遍历集合元素的方法。 List、Set、Queue这三个接口都继承自Collection接口、用于规范所有集合的共性方法。AbstractCollection抽象集合类又实现了Collection的部分方法，AbstractList、AbstractSet、AbstractQueue这三个抽象类也都继承了AbstractCollection。 List 列表列表接口，提供一些方法标准，诸如add()、addAll()、get()、remove()、clear()等，供其子类具体实现。 这里还要提到AbstractList和AbstractSequentialList这两个抽象类，AbstractSequentialList继承自AbstractList，这两个类的作用，其实就是在实现List接口的基础上，又增加了一层抽象，添加和实现了一些个性化方法。 AbstractList支持随机访问，而AbstractSequentialList只支持迭代访问。这也是ArrayList和LinkedList，线性表和链表的区别之一。 ArrayList 线性表基于数组实现，继承AbstractList类，默认长度是10。12345678910public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable /** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; transient Object[] elementData; // non-private to simplify nested class access private int size; 每次固定扩容size+1 + (size+1) &gt;&gt; 1这个数量长度。1234567891011121314151617181920212223242526272829 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; 方法内没有同步锁修饰，所以非线程安全。 它的增删操作是按照线性表的规则，如果增删都在末尾，则直接操作；否则需要元素移位，所以增删效率很低。123456789101112131415161718192021222324public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125;public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; 但获取、设置元素是根据索引直接定位的，所以效率高。123456789public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125; E elementData(int index) &#123; return (E) elementData[index]; &#125; LinkedList 双链表继承AbstractSequentialList类，实现了List和Deque，说明也可以充当栈和队列。123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 节点属性1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 方法内没有同步锁修饰，所以非线程安全。 它的增删操作是按照链表的规则，修改前后节点的索引即可，所以效率高。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 public boolean add(E e) &#123; linkLast(e); return true; &#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125;public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); &#125; void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; &#125;public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125;public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index)); &#125; E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; 但获取、设置元素是需要遍历定位的，所以效率低。12345678910111213141516171819public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; Vector 向量基于数组实现，继承AbstractList类，默认长度是10。1234567891011public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializableprotected Object[] elementData;protected int elementCount; protected int capacityIncrement;public Vector() &#123; this(10);&#125; 所有方法都带同步锁修饰，所以是线程安全的，但效率极低……123456public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; &#125; 默认每次扩容1倍，如果在初始化时指定capacityIncrement，则每次扩容capacityIncrement，最大长度为Integer.MAX_VALUE，超长报OutOfMemoryError错误。12345678910111213141516171819202122232425262728293031323334353637383940 public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; &#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125;public synchronized void removeElementAt(int index) &#123; modCount++; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; elementData[elementCount] = null; /* to let gc do its work */ &#125; Stack 栈是一个栈（后进先出）数据结构的实现，入栈出栈，继承Vector向量。1public class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; 也是基于Vector向量的数组实现，也是线程安全、效率低。1234567891011121314151617181920212223242526272829 public E push(E item) &#123; addElement(item); return item; &#125;public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; &#125;public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; &#125;public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); &#125; 这个栈的实现已经没人用了，可以通过ArrayDeque双端队列实现栈的需求。 Set 集合主要特性为集合中不能存在重复元素（复合类型实例需要重写equals()和hashCode()实现去重），其实现类分为无序集合、排序集合、枚举集合三种。 HashSet 哈希集合基于HashMap实现，继承AbstractSet抽象集合。1234567891011public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializableprivate transient HashMap&lt;E,Object&gt; map;public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; 实际上就是将HashMap中的key作为容器，实现无序集合。所以这里的无序是由HashMap的key自然排序导致的。123456789// Dummy value to associate with an Object in the backing Mapprivate static final Object PRESENT = new Object(); public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; LinkedHashSet 链式哈希集合基于LinkedHashMap实现，继承HashSet类。1234567891011121314public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; public LinkedHashSet() &#123; super(16, .75f, true); &#125; public LinkedHashSet(int initialCapacity) &#123; super(initialCapacity, .75f, true); &#125;HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; 增删操作与HashSet相同，对LinkedHashMap的key操作，但它是有序的。 TreeSet 树集合基于TreeMap实现，继承AbstractSet类。123456789public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;()); &#125;public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;&gt;(comparator)); &#125; 增删操作与HashSet相同，对TreeMap的key操作，可以指定比较器进行排序控制，默认是自然排序。123456Set&lt;String&gt; treeSet = new TreeSet&lt;&gt;((a, b) -&gt; -a.compareTo(b)); treeSet.add("b"); treeSet.add("a"); treeSet.add("d"); treeSet.add("c"); treeSet.forEach(System.out::println); 结果：1234dcba EnumSet 枚举集合EnumSet是一个枚举抽象类继承AbstractSet类。12public abstract class EnumSet&lt;E extends Enum&lt;E&gt;&gt; extends AbstractSet&lt;E&gt; implements Cloneable, java.io.Serializable 分别记录枚举类型和枚举成员。123456789/** * The class of all the elements of this set. */final Class&lt;E&gt; elementType;/** * All of the values comprising T. (Cached for performance.) */final Enum&lt;?&gt;[] universe; 可通过内部提供的静态方法实例化。1Set&lt;MyEnum&gt; enumSet = EnumSet.allOf(MyEnum.class); 当枚举集合长度不大于64时，实例化RegularEnumSet类，否则实例化JumboEnumSet类。123456789101112131415public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; allOf(Class&lt;E&gt; elementType) &#123; EnumSet&lt;E&gt; result = noneOf(elementType); result.addAll(); return result;&#125;public static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) &#123; Enum&lt;?&gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + " not an enum"); if (universe.length &lt;= 64) return new RegularEnumSet&lt;&gt;(elementType, universe); else return new JumboEnumSet&lt;&gt;(elementType, universe);&#125; Enum类中ordinal成员变量用于记录枚举常量声明位置，枚举集合的增删操作也是基于这个成员变量进行位运算的。12345678910/** * The ordinal of this enumeration constant (its position * in the enum declaration, where the initial constant is assigned * an ordinal of zero). * * Most programmers will have no use for this field. It is designed * for use by sophisticated enum-based data structures, such as * &#123;@link java.util.EnumSet&#125; and &#123;@link java.util.EnumMap&#125;. */ private final int ordinal; RegularEnumSet 固定尺寸枚举集合实例化直接调用EnumSet的构造器，将类型和成员赋给枚举集合实例。123RegularEnumSet(Class&lt;E&gt;elementType, Enum&lt;?&gt;[] universe) &#123; super(elementType, universe);&#125; RegularEnumSet的增删操作是使用long型elements与枚举的ordinal进行位运算。 add就是将1L左移ordinal位后，与elements进行位或运算，这位变1，从而实现将某类型枚举成员不重复地加到其枚举集合中。 remove就是将1L左移ordinal位后取反，与elements进行位与运算，这位变0，从而实现将其从枚举集合中删除。 这也是为什么RegularEnumSet长度必须不大于64，因为long型就64位能给你玩…… 非线程安全。123456789101112131415161718192021222324 /** * Bit vector representation of this set. The 2^k bit indicates the * presence of universe[k] in this set. */ private long elements = 0L;public boolean add(E e) &#123; typeCheck(e); long oldElements = elements; elements |= (1L &lt;&lt; ((Enum&lt;?&gt;)e).ordinal()); return elements != oldElements; &#125; public boolean remove(Object e) &#123; if (e == null) return false; Class&lt;?&gt; eClass = e.getClass(); if (eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType) return false; long oldElements = elements; elements &amp;= ~(1L &lt;&lt; ((Enum&lt;?&gt;)e).ordinal()); return elements != oldElements; &#125; JumboEnumSet 大尺寸枚举集合实例化直接调用EnumSet的构造器，将类型和成员赋给枚举集合实例，并初始化elements枚举数组，枚举成员个数+63再右移6位相当于除以2^6=64，也就是创建一个包含N个long型的64位的数组给你玩……1234JumboEnumSet(Class&lt;E&gt;elementType, Enum&lt;?&gt;[] universe) &#123; super(elementType, universe); elements = new long[(universe.length + 63) &gt;&gt;&gt; 6];&#125; 增删操作和RegularEnumSet类似，只不过多个除以64的操作。非线程安全。123456789101112131415161718192021222324252627282930313233343536373839 /** * Bit vector representation of this set. The ith bit of the jth * element of this array represents the presence of universe[64*j +i] * in this set. */ private long elements[]; // Redundant - maintained for performance private int size = 0; public boolean add(E e) &#123; typeCheck(e); int eOrdinal = e.ordinal(); int eWordNum = eOrdinal &gt;&gt;&gt; 6; long oldElements = elements[eWordNum]; elements[eWordNum] |= (1L &lt;&lt; eOrdinal); boolean result = (elements[eWordNum] != oldElements); if (result) size++; return result; &#125;public boolean remove(Object e) &#123; if (e == null) return false; Class&lt;?&gt; eClass = e.getClass(); if (eClass != elementType &amp;&amp; eClass.getSuperclass() != elementType) return false; int eOrdinal = ((Enum&lt;?&gt;)e).ordinal(); int eWordNum = eOrdinal &gt;&gt;&gt; 6; long oldElements = elements[eWordNum]; elements[eWordNum] &amp;= ~(1L &lt;&lt; eOrdinal); boolean result = (elements[eWordNum] != oldElements); if (result) size--; return result; &#125; Queue 队列队列的特点就是先进先出，尾进头出。 PriorityQueue 优先级队列这是一个特殊队列。有时间详细分析一下算法// TODO 基于数组实现，继承AbstractCollection类， 默认长度是11。1234567public abstract class AbstractQueue&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Queue&lt;E&gt; &#123;private static final int DEFAULT_INITIAL_CAPACITY = 11;transient Object[] queue; // non-private to simplify nested class access 每次扩容，如果队列长度小于64就扩1倍+2，否则扩50%。12345678910111213141516171819private void grow(int minCapacity) &#123; int oldCapacity = queue.length; // Double size if small; else grow by 50% int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ? (oldCapacity + 2) : (oldCapacity &gt;&gt; 1)); // overflow-conscious code if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); queue = Arrays.copyOf(queue, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 进出操作，非线程安全。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495 public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else siftUp(i, e); return true; &#125;private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); &#125; private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = key; &#125; private void siftUpUsingComparator(int k, E x) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (comparator.compare(x, (E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = x; &#125; public E poll() &#123; if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0]; E x = (E) queue[s]; queue[s] = null; if (s != 0) siftDown(0, x); return result; &#125;private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); &#125;private void siftDownComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x; int half = size &gt;&gt;&gt; 1; // loop while a non-leaf while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0) c = queue[child = right]; if (key.compareTo((E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = key; &#125; private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x; &#125; Deque 双端队列双端队列的特点就是两边都能进，两边都能出，所以就有对应的offerFirst、offerLast、pollFirst、pollLast等操作。 ArrayDeque 数组双端队列基于数组实现，继承AbstractCollection类，实现了Deque接口。默认长度为16。最小长度为8。1234567891011121314public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Deque&lt;E&gt;, Cloneable, Serializable transient Object[] elements; // non-private to simplify nested class access transient int head; transient int tail; private static final int MIN_INITIAL_CAPACITY = 8;public ArrayDeque() &#123; elements = new Object[16]; &#125; 头尾进出操作，非线程安全，元素不能为null，每次扩容加1倍。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void addFirst(E e) &#123; if (e == null) throw new NullPointerException(); elements[head = (head - 1) &amp; (elements.length - 1)] = e; if (head == tail) doubleCapacity(); &#125;public void addLast(E e) &#123; if (e == null) throw new NullPointerException(); elements[tail] = e; if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); &#125;public E pollFirst() &#123; int h = head; @SuppressWarnings("unchecked") E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; elements[h] = null; // Must null out slot head = (h + 1) &amp; (elements.length - 1); return result; &#125; public E pollLast() &#123; int t = (tail - 1) &amp; (elements.length - 1); @SuppressWarnings("unchecked") E result = (E) elements[t]; if (result == null) return null; elements[t] = null; tail = t; return result; &#125;private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; int r = n - p; // number of elements to the right of p int newCapacity = n &lt;&lt; 1; if (newCapacity &lt; 0) throw new IllegalStateException("Sorry, deque too big"); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r); System.arraycopy(elements, 0, a, r, p); elements = a; head = 0; tail = n; &#125; java.util.MapHashMap 哈希表是基于数组加链表的数据结构，默认长度选16,加载因子选0.75，是为了减少哈希碰撞的几率。123456789101112131415161718public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 static final float DEFAULT_LOAD_FACTOR = 0.75f; transient Node&lt;K,V&gt;[] table; transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; transient int size; static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; 因为索引是通过hash计算的，所以是无序的，而且非线程安全。当发生哈希碰撞时，将元素添加到元素后形成链表，当链表长度大于8并且数组总长度大于64，则将链表改为红黑树。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125;public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125;final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125;final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125; &#125; LinkedHashMap 链式哈希表继承HashMap类，是在HashMap基础上实现的双链表数据结构，所以有序，而且非线程安全，但效率与HashMap相比偏低。1234567891011121314public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; &#125; transient LinkedHashMap.Entry&lt;K,V&gt; head; transient LinkedHashMap.Entry&lt;K,V&gt; tail; TreeMap 红黑树表TreeMap能够把它保存的记录根据key排序，默认是自然排序。也可以指定排序的比较器。当用Iteraor遍历TreeMap时，得到的记录是排过序的。TreeMap的键和值都不能为空。 EnumMap 枚举表以Enum为key的Map。不常用不深抠…… WeakHashMap 弱引用哈希表与HashMap的区别是HashMap的key保留了对实际对象的强引用，只要HashMap实例不被销毁，其中的所有value都不会被垃圾回收。而WeakHashMap的key只保留了对实际对象的弱引用，在满足垃圾回收条件下，会被回收删除。 IdentityHashMap 身份证哈希表与HashMap的区别：HashMap中的key只要通过equals和hashCode两个方法就可以判断是否相同，决定保存其中一个还是两个都保存。而IdentityHashMap中的key必须是引用相同。 Hashtable 哈希表看这命名就知道这东西都淘汰多少年了，不想说它了。不过Properties继承了Hashtable。 fail-fast机制集合在增删操作中经常出现 modCount++;或++modCount; 那我很好奇它是什么东西。 它是什么？12345678/** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the HashMap fail-fast. (See ConcurrentModificationException). */transient int modCount; 翻译： 是HashMap结构改变的次数。结构改变是指更改哈希表的长度或其他改变内部结构的行为。比如再哈希。这个变量是用于使HashMap的迭代器快速失败。参考ConcurrentModificationException异常。 原来fail-fast是Java集合在并发修改场景中的一种错误检测机制。 什么时候会出现ConcurrentModificationException异常？当多个线程同时操作非线程安全的集合时，线程A可能正在使用Iterator或ForEach遍历集合，线程B可能更改了集合结构，那么原来的mc和++后的modCount就不一致了，这时就会进入123456789101112131415@Override public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key, e.value); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; 抛出ConcurrentModificationException异常。 java.util.concurrent.*// TODO]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>看破Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Java 3.JDK8 Core]]></title>
    <url>%2Fp%2Fc46700a5%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>看破Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破设计模式 4. 行为型模式 - 职责链模式(Chain of Responsibility)]]></title>
    <url>%2Fp%2Fbaaf222c%2F</url>
    <content type="text"><![CDATA[定义示例疑问]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>看破设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Java 5.IO、Socket]]></title>
    <url>%2Fp%2F6a43eebc%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>看破Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破调优 1.从java开发开始]]></title>
    <url>%2Fp%2F5191fb9a%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>optimization</category>
      </categories>
      <tags>
        <tag>看破调优</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Java 6.NIO]]></title>
    <url>%2Fp%2Fe269c416%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>看破Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Java 7.AIO]]></title>
    <url>%2Fp%2Fd455aa9b%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>看破Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破JVM 1.]]></title>
    <url>%2Fp%2Ffc61a33c%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>看破JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破SpringBoot 1.快速安装及使用]]></title>
    <url>%2Fp%2Fc40289d2%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>看破SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Tcpcopy 1.快速安装及使用]]></title>
    <url>%2Fp%2Ff9d0a7b1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>testtool</category>
      </categories>
      <tags>
        <tag>看破Tcpcopy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破设计模式 3. 结构型模式 - 适配器模式(Adapter)]]></title>
    <url>%2Fp%2Fa718df1a%2F</url>
    <content type="text"><![CDATA[定义示例疑问]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>看破设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Elastic-Job 1.快速安装及使用]]></title>
    <url>%2Fp%2F75509985%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>elasticjob</category>
      </categories>
      <tags>
        <tag>看破Elastic-Job</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破设计模式 2. 创建型模式 - 单例模式(Singleton)]]></title>
    <url>%2Fp%2Fc9a4fbc9%2F</url>
    <content type="text"><![CDATA[定义 Ensure a class has only one instance, and provide a global point of access to it. 确保某一个类只有一个实例， 而且自行实例化并向整个系统提供这个实例。 示例饿汉式123456789101112131415public class HungrySingleton &#123; private static final HungrySingleton instance = new HungrySingleton(); private HungrySingleton() &#123; &#125; public static HungrySingleton instance() &#123; return instance; &#125; public void say() &#123; System.out.println("hello"); &#125;&#125; 懒汉式（加锁禁止重排序保证线程安全）12345678910111213141516171819202122public class LazySingleton &#123; private static volatile LazySingleton instance = null; private LazySingleton() &#123; &#125; public static LazySingleton instance() &#123; if (instance == null) &#123; synchronized (LazySingleton.class) &#123; if (instance == null) &#123; instance = new LazySingleton(); &#125; &#125; &#125; return instance; &#125; public void say() &#123; System.out.println("hello"); &#125;&#125; 当然Effective java推荐枚举式12345678910111213141516171819202122232425262728public class EnumSingleton &#123; private EnumSingleton() &#123; &#125; private enum Singleton &#123; INSTANCE; private final EnumSingleton instance; Singleton() &#123; instance = new EnumSingleton(); &#125; public EnumSingleton getInstance() &#123; return instance; &#125; &#125; public static EnumSingleton instance() &#123; return Singleton.INSTANCE.getInstance(); &#125; public void say() &#123; System.out.println("hello"); &#125;&#125; 我选择静态内部类式123456789101112131415161718public class NiceSingleton &#123; private NiceSingleton() &#123; &#125; private static class InstanceHolder &#123; private final static NiceSingleton instance = new NiceSingleton(); &#125; public static NiceSingleton instance() &#123; return InstanceHolder.instance; &#125; public void say() &#123; System.out.println("hello"); &#125;&#125; 疑问 为什么懒汉式单例要双重校验？ 当两个线程同时调用instance()方法时，由于singleton==null，两个线程都可以通过第一个校验，然后线程A持有锁，线程B等待。当线程A执行完实例化、释放锁，线程B进入代码块。 如果不加第二个校验，线程B又会实例化一个对象。就会违反单例模式设计原则。 如果不加第一个校验，也能实现单例，但多个线程反复竞争锁会增加系统开销，严重影响性能。]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>看破设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Jenkins 1.快速安装及使用]]></title>
    <url>%2Fp%2F17293ae1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>看破Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Java 1.核心语法]]></title>
    <url>%2Fp%2F195fb869%2F</url>
    <content type="text"><![CDATA[重新梳理一下JAVA开发中常用到的核心语法，随遇到随补充…… 封装将变量和方法封装成一个类，通过实例化的方式赋予其为对象。 可以看下八大基本数据类型的包装类加深理解： 怎么包装成类的？ 怎么继承Number实现obj.xxxValue()的？ 怎么实现自动拆箱装箱的？ 继承子类继承超类允许的属性和方法。 内部类在类的内部声明类，就是内部类。特性： 可以通过声明多个内部类，实现多继承。 内部类可直接访问外部类成员变量和方法，但外部类访问内部类的成员需要实例化内部类。 提供更好的封装。 构造代码块{}在类中跟构造方法类似，都是在实例化对象时执行。 实例化内部类没什么好说的，直接上代码……拥有内部类的类：1234567891011121314151617public class MySelf &#123; private String id; public MySelf() &#123;&#125; public class Info &#123; public Info() &#123;&#125; public Info(int age) &#123; this.age = age; &#125; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125;&#125; 实例化：123MySelf mySelf = new MySelf();MySelf.Info myInfo = mySelf.new Info(12);LogUtils.info(myInfo.getAge()); 为MySelf.Info加上static修饰，实例化：12MySelf.Info myInfo = new MySelf.Info(12);LogUtils.info(myInfo.getAge()); 继承内部类需要通过外部类实例引用外部类构造器，才能继承内部类，没这么玩的。太反人类……父类：1234567891011121314151617181920212223public class MySelf &#123; private String id; public MySelf() &#123;&#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public class Info &#123; public Info() &#123;&#125; public Info(int age) &#123; this.age = age; &#125; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125;&#125; 子类：12345public class MySon extends MySelf.Info &#123; public MySon(MySelf mySelf) &#123; mySelf.super(); &#125;&#125; 匿名内部类在实例化前内部继承抽象类并实现抽象方法，或内部实现接口并实现接口所有方法。类似这样：123456MySelf son = new MySon() &#123;public void set(String id) &#123;this.setId(id);&#125;&#125;;LogUtils.info(((MySon) son).get()); this 和 superthis指当前对象本身super指当前对象最近超（父）类 在构造方法中使用super()和this()应该注意： super()调用父类的构造方法，this()调用当前类的其它构造方法。 每个子类构造方法的第一条语句，都隐式调用super()，如果父类没有这种形式的构造函数，会编译报错。 super()和this()均需放在构造方法内第一行，一个构造方法内只能调用其中一个。 this()和super()都指向对象，所以不能在static方法，static语句块中使用。 多态静态绑定在编译阶段就能确定调用哪个方法的方式，叫静态绑定机制。 动态绑定根据实际创建的对象类型来确定方法所在位置，通过动态创建的对象方法表来定位方法的方式，叫动态绑定机制。 修饰符访问控制修饰符Java修饰符中用来控制访问权限的，分为以下四种： 类内可访问（private） 包内可访问 (缺省。有人说是default，但在jdk8中default用于修饰接口默认方法，写在代码里尝试过确实不是) 子类可访问 (protected) 均可访问 (public) 以下用表格说明各修饰符区别： 修饰符 当前类 包内 子孙类（包内） 子孙类（不同包） 其他包 public Y Y Y Y Y protected Y Y Y Y/N N 缺省 Y Y Y N N private Y N N N N 这里要特别说明protected作用，也就是上面那个Y/N： 允许同一包内的类任意调用。 不在同一包内的类，只允许子孙类调用，不在家谱上的类不能调用 默认缺省值： 类中的变量和方法都是public，构造函数为缺省。 接口中的变量为public static final，方法为public。 访问控制的继承： 父类声明为public的变量和方法，子类也必须声明为public。 父类声明为protected的变量和方法，子类可以声明为protected或public。 父类声明为private的方法，不能被继承。 非访问控制修饰符静态修饰符static用于修饰静态方法和静态变量。 一个类无论实例化了多少个对象，类的静态变量和静态方法都指向一块固定的内存区，修改任意实例中的静态变量都为最终修改值。 静态方法中只能使用静态变量。 二者可以通过Class.member，Class.method()的方式直接调用。 可以修饰静态内部类 static{} 代码块在JVM的生命周期中只被加载一次，是伴随类加载执行的。不管怎么实例化这个类，都只执行一次。 最终修饰符final修饰常量、修饰不可继承类，修饰可继承但不能重写的方法。 抽象类修饰符abstract抽象类不能被final修饰，可以包含抽象方法和非抽象方法。抽象方法不能被final和static修饰，不能有方法体，继承抽象类的子类必须实现父类的所有抽象方法，除非子类也是抽象类。 注意：抽象类是不能被实例化的！！！除非你使用匿名内部类的方式实现它的抽象方法，然后实例化这个匿名内部类，比如：123456MySelf son = new MySon() &#123;public void set(String id) &#123;this.setId(id);&#125;&#125;;LogUtils.info(((MySon) son).get()); 但是！这么写属于反人类设计模式，不推荐这样写。 接口默认实现方法default (jdk8)在interface中实现默认方法需要加default修饰，必须为public公有这和抽象类中可以有protected抽象方法和private成员变量有区别 transient实现了Serilizable接口的POJO，在不需要对类中某个成员变量进行序列化时，可以使用transient修饰该成员变量。反序列化时该成员变量无法获得访问，值为null。 在实际开发过程中，有些属性需要序列化，有些不需要，比如一些敏感信息（如身份证，密码，银行卡号等）不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。 只能修饰成员变量，类、方法、本地变量均不能修饰。 静态变量不能被序列化。 synchronized和volatilesynchronized修饰多线程中的同步锁volatile修饰多线程中的共享变量 异常 Error Error一般表示编译时或者系统错误，例如：虚拟机相关的错误，系统崩溃（例如：OutOfMemoryError）等。这种错误无法恢复或不可捕获,将导致应用程序中断,通常应用程序无法处理这些错误,因此也不应该试图用catch来进行捕获。 Exception Exception分为受检查异常和运行时异常（不受检查异常）。 编译器在编译时，对于受检查异常必须进行try…catch或throws处理,否则无法通过编译。常见的受检查异常包括：IO操作、ClassNotFoundException、线程操作等。 RuntimeException及其子类都统称为非受检查异常，例如：NullPointExecrption、NumberFormatException（字符串转换为数字）、ArrayIndexOutOfBoundsException（数组越界）、ClassCastException（类型转换错误）、ArithmeticException（算术错误）等。 try-with-resources(jdk7)在try()括号中打开的资源会在语句执行结束时关闭。123456try( BufferedReader br = new BufferedReader(new FileReader(path)); BufferedWriter bw = new BufferedWriter(new FileWriter(path));)&#123;&#125;catch()&#123;&#125; try catch finally首先看这段代码123456789101112public int test() &#123; int x = 1; try &#123; return ++x; &#125; catch (Exception e) &#123; &#125; finally &#123; ++x; &#125; return x;&#125; 结果是2而不是3，finally到底执行了吗？经打断点运行确认，finally执行后x为3，又执行到return，返回结果为2。 查阅官方finally语句说明，对这个特殊情况有说明： The finally block always executes when the try block exits. This ensures that the finally block is executed even if an unexpected exception occurs. But finally is useful for more than just exception handling — it allows the programmer to avoid having cleanup code accidentally bypassed by a return, continue, or break. Putting cleanup code in a finally block is always a good practice, even when no exceptions are anticipated. Note: If the JVM exits while the try or catch code is being executed, then the finally block may not execute. Likewise, if the thread executing the try or catch code is interrupted or killed, the finally block may not execute even though the application as a whole continues. 翻译： 当try语句退出时肯定会执行finally语句。这确保了即使发了一个意想不到的异常也会执行finally语句块。但是finally的用处不仅是用来处理异常——它可以让程序员不会因为return、continue、或者break语句而忽略了清理代码。把清理代码放在finally语句块里是一个很好的做法，即便可能不会有异常发生也要这样做。 注意，当try或者catch的代码在运行的时候，JVM退出了。那么finally语句块就不会执行。同样，如果线程在运行try或者catch的代码时被中断了或者被杀死了(killed)，那么finally语句可能也不会执行了，即使整个运用还会继续执行。 这说明只要进程(jvm)不死,线程(thread)不被中断，finally就必须执行。 那么为什么返回结果为2呢？ 查阅官方jvm文档， If the try clause executes a return, the compiled code does the following: 1.Saves the return value (if any) in a local variable.2.Executes a jsr to the code for the finally clause.3.Upon return from the finally clause, returns the value saved in the local variable. 翻译： 如果try语句里有return，那么代码的行为如下： 1.如果有返回值，就把返回值保存到局部变量中2.执行jsr指令跳到finally语句里执行3.执行完finally语句后，返回之前保存在局部变量表里的值 根据上面的说明就可以明白为什么是2了。当执行到return ++x;时，jvm在执行完++x后会在局部变量表里另外分配一个空间来保存当前x的值。注意，现在还没把值返回，而是继续执行finally语句里的语句。等执行完后再把之前保存的值（是2不是x）返回。所以就有了返回结果是2不是3的情况。 泛型类型参数化，可以看下集合的实现。 未知泛型参数方法需要在返回值类型前声明泛型。 注解修饰构造器、成员变量类型、成员方法、方法参数等，用于反射拿值逻辑处理。 自定义注解 @Target （作用域） 12345678910111213141516171819202122232425262728293031323334353637/** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE @Retention （保留策略） 12345678910111213141516171819/** * Annotations are to be discarded by the compiler. */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement */ RUNTIME 比如Lombok的所有注解都是保留在源码阶段的， 123@Target(ElementType.TYPE)@Retention(RetentionPolicy.SOURCE)public @interface Data &#123; @Repeatable （重复注解） 123456/** * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the * repeatable annotation type. * @return the containing annotation type */Class&lt;? extends Annotation&gt; value(); 重复注解(jdk8)注解容器： 12345@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotations &#123; MyAnnotation[] value();&#125; 注解： 123456@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Repeatable(MyAnnotations.class)public @interface MyAnnotation &#123; String value() default "aaa";&#125; 使用： 1234@MyAnnotation("bbb") @MyAnnotation("ccc") public void callback() &#123; &#125; 提取注解属性123456Class&lt;AnnotationTest&gt; clazz = AnnotationTest.class; Method m1 = clazz.getMethod("callback"); MyAnnotation[] ans = m1.getAnnotationsByType(MyAnnotation.class); Arrays.asList(ans).forEach((a) -&gt; &#123; System.out.println(a.value()); &#125;); 输出结果： 12bbbccc 引用类型强引用（StrongReference）如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。 1String[] arr = new String[]&#123;"a", "b", "c"&#125;; 软引用（SoftReference）如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。 12ReferenceQueue&lt;String[]&gt; referenceQueue = new ReferenceQueue&lt;String[]&gt;();SoftReference&lt;String[]&gt; softBean = new SoftReference&lt;String[]&gt;(new String[]&#123;"a", "b", "c"&#125;, referenceQueue); 弱引用（WeakReference）在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 12ReferenceQueue&lt;String[]&gt; referenceQueue = new ReferenceQueue&lt;String[]&gt;();WeakReference&lt;String[]&gt; softBean = new WeakReference&lt;String[]&gt;(new String[]&#123;"a", "b", "c"&#125;, referenceQueue); 虚引用（PhantomReference）与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。 虚引用必须和引用队列 （ReferenceQueue）联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 12ReferenceQueue&lt;String[]&gt; referenceQueue = new ReferenceQueue&lt;String[]&gt;();PhantomReference&lt;String[]&gt; referent = new PhantomReference&lt;String&gt;(new String[]&#123;"a", "b", "c"&#125;, referenceQueue); 参考资料 《Java核心技术卷I基础知识》 《Java核心技术卷II高级特性》 《Effective Java中文版》 《Java编程思想》]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>看破Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Python 1.从语法开始]]></title>
    <url>%2Fp%2F6bacb559%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>看破Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Java 2.知其所以然]]></title>
    <url>%2Fp%2Fbafefb6b%2F</url>
    <content type="text"><![CDATA[== 和 equals()的区别== 基本数据类型比较的是：值是否相等。 复合数据类型比较的是：引用实例是否相同，即实例在堆内存中存放地址是否相同。 equals() Object基类中比较的是：存放地址是否相同（是否为同一对象实例）。 Object.equals()方法中是这么写的： return (this == obj); 其他类重写了equals()方法，就看具体怎么写了。 由以下方法实现，可以看出基本数据类型的包装类都是通过内置基本数据类型的成员变量value做==比较的， 而字符串的比较可以看成是字符数组的比较。 Byte的equals()1234if (obj instanceof Byte) &#123; return value == ((Byte)obj).byteValue();&#125;return false; Short的equals()1234if (obj instanceof Short) &#123; return value == ((Short)obj).shortValue();&#125;return false; Integer的equals()1234if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false; Long的equals()1234if (obj instanceof Long) &#123; return value == ((Long)obj).longValue(); &#125; return false; Float的equals()12return (obj instanceof Float) &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value)); Double的equals()123return (obj instanceof Double) &amp;&amp; (doubleToLongBits(((Double)obj).value) == doubleToLongBits(value)); 注意Float和Double的计算值是通过native方法调用系统本地接口实现的，这里先不用管它，以后学了JNI再说。 Boolean的equals()1234if (obj instanceof Boolean) &#123; return value == ((Boolean)obj).booleanValue();&#125;return false; Character的equals()1234if (obj instanceof Character) &#123; return value == ((Character)obj).charValue();&#125;return false; String的equals()12345678910111213141516171819if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; 先比较引用变量指向的内存地址，然后判断类型，再比较字符串长度，再转成字符数组挨个字符比较。 hashCode()的计算Object提供的hashCode()方法的计算依赖于本地接口，暂且理解为实例对象的内存地址。1public native int hashCode(); 所有类都可以重写Object的hashCode()方法，但重写hashCode()方法的基本规则： 两个对象通过equals()方法比较返回true时，那么两个对象的hashCode必须相等。 hashCode相等的两个对象，不必保证它们必须相同。（因为再优的哈希算法也避免不了哈希冲突） 看下基础数据类型包装类是怎么计算hashCode的： Boolean 1return value ? 1231 : 1237; Character 1return super.hashCode(); Byte 1return (int)value; Short 1return (int)value; Integer 1return value; Long 1return (int)(value ^ (value &gt;&gt;&gt; 32)); Float 1return floatToIntBits(value); Double 12long bits = doubleToLongBits(value);return (int)(bits ^ (bits &gt;&gt;&gt; 32));L 再看看String，池里有就直接拿，池里没有才计算累加 123456789101112131415/** Cache the hash code for the string */private int hash; // Default to 0public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 由equals和==引出的问题 - A pool of strings（字符串池）123456789101112131415161718System.out.println("引用同一实例：");String a = "abcd";String b = "abcd";System.out.println(a == b);System.out.println(a.equals(b));System.out.println("创建新实例：");String a1 = new String("abcd");String b1 = new String("abcd");System.out.println(a1 == b1);System.out.println(a1.equals(b1));System.out.println("从字符串池中拿对象：");String a2 = "abcd";String b2 = new String("abcd");b2 = b2.intern();System.out.println(a2 == b2);System.out.println(a2.equals(b2)); 运行结果 123456789引用同一实例：truetrue创建新实例：falsetrue从字符串池中拿对象：truetrue 这说明非创建新实例的操作，会从字符串池中拿对象。 看一下intern()方法的注释， Returns a canonical representation for the string object. * &lt;p&gt; * A pool of strings, initially empty, is maintained privately by the * class {@code String}. * &lt;p&gt; * When the intern method is invoked, if the pool already contains a * string equal to this {@code String} object as determined by * the {@link #equals(Object)} method, then the string from the pool is * returned. Otherwise, this {@code String} object is added to the * pool and a reference to this {@code String} object is returned. * &lt;p&gt; * It follows that for any two strings {@code s} and {@code t}, * {@code s.intern() == t.intern()} is {@code true} * if and only if {@code s.equals(t)} is {@code true}. * &lt;p&gt; * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. 翻译大致如下： String类自己维护了一个字符串池，在初始化时是空的。 当intern方法被调用时，如果池中包含一个与传入字符串相等的字符串，那么直接返回该字符串。 对于任意两个相等(equals)的字符串，他们的intern()都相等(==)。 所有的字面声明（双引号声明）字符串和常量字符串都会维护在字符串池中。 字面声明字符串在Java语言规范的第3.10.5节中声明。 保证从唯一的字符串池中返回一个与该字符串内容相同的字符串。 String，StringBuffer和StringBuilder的区别 String是不可变的，char[] value是被final修饰，所以是线程安全的。 他们都实现了CharSequence接口，而StringBuffer和StringBuilder继承了AbstractStringBuilder类并实现了Appendable接口。 StringBuffer和StringBuilder的append()方法都是调父类AbstractStringBuilder中的append()方法，StringBuffer的append()方法加了synchronized同步锁，所以线程安全，效率低。 StringBuffer:123456@Override public synchronized StringBuffer append(String str) &#123; toStringCache = null; super.append(str); return this; &#125; StringBuilder:12345@Overridepublic StringBuilder append(String str) &#123; super.append(str); return this;&#125; 那么为什么String的 + 这种运算效率非常低呢？ 1.常量相加 - 虚拟机是会优化成常量返回的。 2.变量相加 - 虚拟机是会优化成创建StringBuilder对象的append()方法操作的，一般所说的 String 采用连接运算符（+）效率低下主要产生在以下的情况中： 1234String s = "";for(int i = 0; i &lt; 100; i++) &#123; s += "a";&#125; 每做一次 + 就产生个 StringBuilder 对象，然后 append 后就扔掉。下次循环再到达时重新产生个 StringBuilder 对象，然后 append 字符串，如此循环直至结束。如果我们直接采用 StringBuilder 对象进行 append 的话，我们可以节省 N - 1 次创建和销毁对象的时间。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>看破Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破SpringSecurity 1.快速安装及使用]]></title>
    <url>%2Fp%2F25f2dbaa%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>springsecurity</category>
      </categories>
      <tags>
        <tag>看破SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破ApacheBench 1.快速安装及使用]]></title>
    <url>%2Fp%2Fda68c872%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>testtool</category>
      </categories>
      <tags>
        <tag>看破ApacheBench</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破设计模式 1.设计原则]]></title>
    <url>%2Fp%2F3e610103%2F</url>
    <content type="text"><![CDATA[单一职责原则（Single Responsibility Principle）SRP定义 There should never be more than one reason for a class to change. 一个类只干一个事儿。 优点 类的复杂性降低，职责清晰，增强可读性。 解耦，提高可维护性。 总结这个原则同样适用于类和方法。 里氏替换原则（Liskov Substitution Principle）LSP定义 If for each object o1 of type S there is an object o2 oftype T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T. 如果对每一个类型为S的对象o1， 都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化， 那么类型S是类型T的子类型。 换句人话讲，所有引用基类的地方必须能透明地使用其子类的对象。 包含以下4层含义： 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法。 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 优点 明确类的定义和方法的行为，有利于复用，而且保证父子类行为一致。 总结里氏替换原则的提出主要是为了解决因继承不当导致的父子类行为不一致、运行结果与预期不符的问题。 说白了，就是父类的方法尽量别动。 依赖倒置原则（Dependence Inversion Principle）DIP定义 High level modules should not depend upon low level modules.Both should depend uponabstractions.Abstractions should not depend upon details.Details should depend upon abstractions. 包含以下3层含义： 高层模块不应该依赖低层模块， 两者都应该依赖其抽象； 抽象不应该依赖细节； 细节应该依赖抽象。 底层模块：每一个逻辑的实现都是由不可分割的原子逻辑组成的，不可分割的原子逻辑就是底层模块。高层模块：由原子逻辑再组装就是高层模块。抽象：即抽象类或接口，两者是不能够实例化的。细节：即具体的实现类，实现接口或者继承抽象类所产生的类，两者可以通过关键字new直接被实例化。 最灵活的方式就是Setter方法传递依赖对象，当然如果不想提供灵活变更，可以在构造体中注入，参考代码如下：123456789101112131415161718192021222324252627282930313233343536public interface IDriver &#123; public void drive();&#125;public class Driver implements IDriver&#123; private ICar car; public void setCar(ICar car)&#123; this.car = car; &#125; public void drive()&#123; this.car.run(); &#125;&#125;public interface ICar &#123; public void run();&#125;public class Benz implements ICar&#123; public void run()&#123; System.out.println("奔驰汽车开始运行..."); &#125;&#125;public class BMW implements ICar&#123; public void run()&#123; System.out.println("宝马汽车开始运行..."); &#125;&#125;public static void main(String[] args) &#123; IDriver driver = new Driver(); ICar benz = new Benz(); driver.drive(benz); ICar benz = new BMW(); driver.drive(benz);&#125; 优点 解耦，避免动一处而伤全身。 总结目的就是为了解耦，封装工具类和建立管道模型就遵循这种原则。 接口隔离原则（Interface Segregation Principles）ISP定义 Clients should not be forced to depend upon interfaces that they don’t use. The dependency of one class to another one should depend on the smallest possible interface. 包含以下2层含义： 客户端不应该强行依赖它不需要的接口。 类间的依赖关系应该建立在最小的接口上。 含义比较明确，尽量把接口拆得足够细，参考代码如下：123456789101112131415161718192021222324252627282930313233public interface I1 &#123; public void method1();&#125;public interface I2 &#123; public void method2();&#125;public interface I3 &#123; public void method3();&#125; public class A implements I1,I2&#123; @Override public void method1() &#123; System.out.println("Class A - method1()"); &#125; @Override public void method2() &#123; System.out.println("Class A - method2()"); &#125;&#125; public class B implements I2,I3&#123; @Override public void method2() &#123; System.out.println("Class B - method2()"); &#125; @Override public void method3() &#123; System.out.println("Class B - method3()"); &#125;&#125; 优点 减少代码量，避免实现无必要的方法。 总结与单一职责原则很像，但还是有些区别的。 单一职责原则针对的是类和方法；而接口隔离原则针对的是接口。 迪米特法则（Least Knowledge Principle）LKP定义 Only talk to your immediate friends. 一个类只和朋友交流。 意思就是尽量减少与其他类的依赖，像这样：12345678910public class A &#123; private B b; public void say()&#123; b.sayHello(); &#125; public void fly()&#123; b.flyInTheSky(); &#125; 优点 解耦，不用管其他方法的实现，我只要用你提供的方法就行了。 总结太简单不说了。 开闭原则（Open-Closed Principle）OCP定义 Software entities like classes,modules and functions should be open for extension but closed formodifications. 一个软件实体如类、 模块和函数应该对扩展开放，对修改关闭。 也就是说，当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public interface IBook &#123; //书籍有名称 public String getName(); //书籍有售价 public int getPrice(); //书籍有作者 public String getAuthor();&#125;public class NovelBook implements IBook &#123; //书籍名称 private String name; //书籍的价格 private int price; //书籍的作者 private String author; //通过构造函数传递书籍数据 public NovelBook(String _name,int _price,String _author)&#123; this.name = _name; this.price = _price; this.author = _author; &#125; //获得作者是谁 public String getAuthor() &#123; return this.author; &#125; //书籍叫什么名字 public String getName() &#123; return this.name; &#125; //获得书籍的价格 public int getPrice() &#123; return this.price; &#125;&#125;public class BookStore &#123; private final static ArrayList&lt;IBook&gt; bookList = new ArrayList&lt;IBook&gt;(); //static静态模块初始化数据， 实际项目中一般是由持久层完成 static&#123; bookList.add(new NovelBook("天龙八部",3200,"金庸")); bookList.add(new NovelBook("巴黎圣母院",5600,"雨果")); bookList.add(new NovelBook("悲惨世界",3500,"雨果")); &#125; //模拟书店买书 public static void main(String[] args) &#123; NumberFormat formatter = NumberFormat.getCurrencyInstance(); formatter.setMaximumFractionDigits(2); System.out.println("-----------书店卖出去的书籍记录如下： -----------"); for(IBook book:bookList)&#123; System.out.println("书籍名称： " + book.getName()+"\t书籍作者： " book.getAuthor()+"\t书籍价格： "+ formatter.format (book.getPrice()/ 100.0)+"元"); &#125; &#125;&#125;public class OffNovelBook extends NovelBook &#123; public OffNovelBook(String _name,int _price,String _author)&#123; super(_name,_price,_author); &#125; //覆写销售价格 @Override public int getPrice()&#123; //原价 int selfPrice = super.getPrice(); int offPrice=0; if(selfPrice&gt;4000)&#123; //原价大于40元， 则打9折 offPrice = selfPrice * 90 /100; &#125;else&#123; offPrice = selfPrice * 80 /100; &#125; return offPrice; &#125;&#125;public class BookStore &#123; private final static ArrayList&lt;IBook&gt; bookList = new ArrayList&lt;IBook&gt;(); //static静态模块初始化数据， 实际项目中一般是由持久层完成 static&#123; bookList.add(new OffNovelBook("天龙八部",3200,"金庸")); bookList.add(new OffNovelBook("巴黎圣母院",5600,"雨果")); bookList.add(new OffNovelBook("悲惨世界",3500,"雨果")); &#125; //模拟书店买书 public static void main(String[] args) &#123; NumberFormat formatter = NumberFormat.getCurrencyInstance(); formatter.setMaximumFractionDigits(2); System.out.println("-----------书店卖出去的书籍记录如下： -----------"); for(IBook book:bookList)&#123; System.out.println("书籍名称： " + book.getName()+"\t书籍作者： " &#125; &#125;&#125; 优点 减少出现不必要问题的几率，避免节外生枝。 总结设计模式不必局限于这六大原则，要活学活用。 在读过一些优秀的开源框架源码之后，潜移默化地形成这种设计思维，运用到开发中即可。 合成复用原则（Composite Reuse Principle）CRP定义要尽量使用合成和聚合，尽量不要使用继承。 优点 不使用继承，不破坏类的封装性。 可扩展性强，修改单一模块对全局影响不大。 总结如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。 参考资料 《设计模式之禅（第2版）》设计模式之禅这本书，我读到第9章抽象工厂的时候，就发现作者有点开始扯犊子了。他的思路并不清晰，人的思路一旦不清晰就容易含糊其辞，试图通过列举怪力乱神、妖魔鬼怪等反科学、伪实践的例子来说服读者……果断扔了 《设计模式 GOF》 《研磨设计模式》 《图解设计模式》 设计模式读书笔记文集]]></content>
      <categories>
        <category>design</category>
      </categories>
      <tags>
        <tag>看破设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Guava 1.简介、集成和使用]]></title>
    <url>%2Fp%2Ffa66359c%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>guava</category>
      </categories>
      <tags>
        <tag>看破Guava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Zabbix 1.快速安装及使用]]></title>
    <url>%2Fp%2Fba9b5879%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>zabbix</category>
      </categories>
      <tags>
        <tag>看破Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Linux 10.监控工具]]></title>
    <url>%2Fp%2F4b526f85%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>看破Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Linux 9.把系统调优玩明白了行吗]]></title>
    <url>%2Fp%2Faf1430a1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>看破Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Linux 8.lvs+nginx+keepalive]]></title>
    <url>%2Fp%2F79cca877%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>看破Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Linux 7.磁盘分区、格式化、挂载、磁盘阵列]]></title>
    <url>%2Fp%2Fe252e857%2F</url>
    <content type="text"><![CDATA[背景现在随便一台服务器都可以挂十几个盘，每个盘十几个T，然后做磁盘阵列，由于fdisk使用MBR分区标准，导致它不支持大于2T的磁盘分区，而且只能分4个物理分区，所以我仅总结下parted分区方式。 磁盘分区parted [OPTION]… [DEVICE [COMMAND [PARAMETERS]…]…]1234567891011121314151617181920212223242526272829303132333435363738选项：-l 列出所有块设备上的分区布局-s 不提示用户-a, --align=[none|cyl|min|opt] 分区对齐方式分区对齐方式：none - 使用磁盘类型允许的最小对齐。cyl - 将分区与柱面对齐。min - 使用磁盘拓扑信息指定的最小对齐方式。此值和opt值将使用磁盘提供的布局信息将逻辑分区表地址与磁盘上的实际物理块对齐。 min值是将分区正确地与物理块对齐所需的最小对齐，这可以避免性能下降。opt - 使用磁盘拓扑信息给出的最佳对齐方式。这以保证最佳性能的方式与物理块大小的倍数对齐。命令：quit 退出help [COMMAND] 显示帮助select DEVICE 选择设备print [devices|free|list,all|NUMBER] 显示可用设备、剩余空间、分区表、指定分区align-check TYPE N 检查分区是否按TYPE对齐mklabel LABEL-TYPE 设置磁盘分区格式mkpart PART-TYPE [FS-TYPE] START END 创建分区rm NUMBER 删除分区resizepart NUMBER END 调整分区大小name NUMBER NAME 给分区起名rescue START END 修复START和END之间的分区disk_set FLAG [on|off] 设置磁盘FLAGdisk_toggle [FLAG] 切换磁盘FLAGset NUMBER FLAG [on|off] 设置分区FLAGtoggle [NUMBER [FLAG]] 切换分区FLAGunit UNIT 修改显示单位UNIT： s：扇区 B:Byte kB:kByte MB:兆B GB：gb %:显示为百分比 cyl：以柱面数量显示 chs：柱面, 磁道, 扇区数目显示 compact:比较友好的显示。 我这儿新加块100G的盘，系统识别硬盘设备，并给它命名为/dev/sdb1234567891011121314151617# parted -lModel: ATA vhost1-0 SSD (scsi)Disk /dev/sda: 42.9GBSector size (logical/physical): 512B/4096BPartition Table: msdosDisk Flags:Number Start End Size Type File system 标志 1 1049kB 42.9GB 42.9GB primary xfs 启动错误: /dev/sdb: unrecognised disk labelModel: ATA vhosttest-0 SSD (scsi)Disk /dev/sdb: 107GBSector size (logical/physical): 512B/4096BPartition Table: unknownDisk Flags: 但系统无法识别他是什么格式，现在给他设置成gpt格式123456789101112131415161718192021# parted /dev/sdb mklabel gpt信息: You may need to update /etc/fstab.# parted -lModel: ATA vhost1-0 SSD (scsi)Disk /dev/sda: 42.9GBSector size (logical/physical): 512B/4096BPartition Table: msdosDisk Flags:Number Start End Size Type File system 标志 1 1049kB 42.9GB 42.9GB primary xfs 启动Model: ATA vhosttest-0 SSD (scsi)Disk /dev/sdb: 107GBSector size (logical/physical): 512B/4096BPartition Table: gptDisk Flags:Number Start End Size File system Name 标志 接下来对其进行分区，12345678910111213141516171819202122232425# parted -a opt /dev/sdb mkpart p1 0% 50%信息: You may need to update /etc/fstab.# parted -a opt /dev/sdb mkpart p2 50% 100%信息: You may need to update /etc/fstab.# parted -lModel: ATA vhost1-0 SSD (scsi)Disk /dev/sda: 42.9GBSector size (logical/physical): 512B/4096BPartition Table: msdosDisk Flags:Number Start End Size Type File system 标志 1 1049kB 42.9GB 42.9GB primary xfs 启动Model: ATA vhosttest-0 SSD (scsi)Disk /dev/sdb: 107GBSector size (logical/physical): 512B/4096BPartition Table: gptDisk Flags:Number Start End Size File system Name 标志 1 1049kB 53.7GB 53.7GB p1 2 53.7GB 107GB 53.7GB p2 如果分错了还可以用rm删除分区，重新分。 还有如果对正在使用的磁盘进行分区操作，还需要使用partprobe使分区表立即生效1# partprobe 创建文件系统分区分好之后还需要为其创建文件系统，文件系统有很多种ext3，ext4，xfs等。 mkfs.xfs [选项] 设备1选项太多，优化这块有时间再深究 我直接用默认参数创建文件系统，结果显示的就是文件系统的所有配置信息。123456789101112131415161718192021# mkfs.xfs /dev/sdb1meta-data=/dev/sdb1 isize=512 agcount=4, agsize=3276736 blks = sectsz=4096 attr=2, projid32bit=1 = crc=1 finobt=0, sparse=0data = bsize=4096 blocks=13106944, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=1log =internal log bsize=4096 blocks=6399, version=2 = sectsz=4096 sunit=1 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0# mkfs.xfs /dev/sdb2meta-data=/dev/sdb2 isize=512 agcount=4, agsize=3276736 blks = sectsz=4096 attr=2, projid32bit=1 = crc=1 finobt=0, sparse=0data = bsize=4096 blocks=13106944, imaxpct=25 = sunit=0 swidth=0 blksnaming =version 2 bsize=4096 ascii-ci=0 ftype=1log =internal log bsize=4096 blocks=6399, version=2 = sectsz=4096 sunit=1 blks, lazy-count=1realtime =none extsz=4096 blocks=0, rtextents=0 挂载现在可以挂载分区到目录了12345678910111213# mkdir /disk1 /disk2# mount /dev/sdb1 /disk1# mount /dev/sdb2 /disk2# df -h文件系统 容量 已用 可用 已用% 挂载点/dev/sda1 40G 2.4G 38G 6% /devtmpfs 907M 0 907M 0% /devtmpfs 917M 0 917M 0% /dev/shmtmpfs 917M 8.9M 908M 1% /runtmpfs 917M 0 917M 0% /sys/fs/cgrouptmpfs 184M 0 184M 0% /run/user/0/dev/sdb1 50G 33M 50G 1% /disk1/dev/sdb2 50G 33M 50G 1% /disk2 还得修改系统挂载表，再重启就会自动挂载指定分区了。1234# vim /etc/fstabUUID=94b135cb-df54-4f82-91b8-026f27444c2f / xfs defaults 0 0/dev/sdb1 /disk1 xfs defaults 0 0/dev/sdb2 /disk2 xfs defaults 0 0 每块设备、每个分区都有自己的UUID，如果以后磁盘坏了或者其他情况需要换盘，这时设备名就有可能更改，所以可以使用UUID固定分区挂载设置。使用blkid查看磁盘分区UUID12345678# blkid /dev/sdb1/dev/sdb1: UUID="12b5cbef-bd21-4977-8eca-c2b72f8e3b47" TYPE="xfs" PARTLABEL="p1" PARTUUID="e82d1feb-214e-4b33-ae9d-67ed67c654fe"# blkid /dev/sdb2/dev/sdb2: UUID="9ff79f5f-c53e-4b8e-af90-9fdb1bc6d6bf" TYPE="xfs" PARTLABEL="p2" PARTUUID="e8a21d8c-7771-486b-a238-cfabf019aadf"然后系统挂载表可以改成UUID=12b5cbef-bd21-4977-8eca-c2b72f8e3b47 /disk1 xfs defaults 0 0UUID=9ff79f5f-c53e-4b8e-af90-9fdb1bc6d6bf /disk2 xfs defaults 0 0 Raid磁盘阵列我公司用的raid10，镜像加条带化，足以保证IO效率和数据安全。 先转一篇文章，以后用到再深究。 （最全面的）各类RAID详解]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>看破Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Linux 6.systemd服务管理]]></title>
    <url>%2Fp%2F76029495%2F</url>
    <content type="text"><![CDATA[背景首先为什么要托管服务，而不是手动ps查pid，然后kill它？为了让服务易于管理，服务状态可感知，进程挂了尝试重启……阿里云ECS也有宕机重启的时候，别凌晨两三点钟被薅起来就为了启个进程。那么现在有很多监控工具，如zabbix、Prometheus可以监控服务故障重启，但监控工具进程也有挂的时候。 为什么要用systemd管理服务？CentOS7中使用systemd管理服务，取代CentOS6中的init和chkconfig，为确保向后兼容，写的service脚本和chkconfig运行启动设置将自动移交给systemd管理。 还有使用过去init管理方式操作过于繁杂，以前在CentOS6写过init.d的service，但启停都是自己写的shell脚本，还要用chkconfig开机启动，还要在/run下创建pidfile记录pid，还要在开机启动时创建对应的临时目录，修改指定用户的使用权限…… 使用systemctl管理工具systemd是一个内核启动第一个就运行的守护进程，所以它的PID为1，管理着所有按照systemd unit规范写出的服务脚本。配合systemctl这个管理工具，可以有效控制服务的配置、启停、重载配置、开机启用禁用、监控状态日志，定时器等 管理服务12345678910111213141516171819202122232425262728293031查看服务状态# systemctl status httpd启动# systemctl start httpd停止# systemctl stop httpd杀死# systemctl kill httpd重启# systemctl restart httpd服务正在运行，则重启，否则不操作# systemctl try-restart httpd# systemctl condrestart httpd重载指定服务配置文件# systemctl reload httpd重载所有服务脚本# systemctl daemon-reload开机启用# systemctl enable httpd开机禁用# systemctl disable httpd查看启用状态# systemctl is-enabled httpd列出所有服务单元的启用状态# systemctl list-unit-files --type=service列出服务所有底层参数# systemctl show httpd查看服务指定底层参数# systemctl show -p CPUShare httpd设置服务指定底层参数# systemctl set-property httpd CPUShares=500 管理系统1234567891011121314重启系统# systemctl reboot关闭系统，切断电源# systemctl poweroff只关闭系统，大部分硬件停止工作，不切断电源# systemctl halt暂停系统，将系统状态写入内存，大部分硬件停止工作，但没有关机# systemctl suspend休眠系统，将系统状态写到硬盘，然后关机# systemctl hibernate系统进入救援模式# systemctl rescue系统进入紧急救援模式# systemctl emergency 使用journalctl日志工具使用journalctl可以查看日志，日志的配置文件是/etc/systemd/journald.conf。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# 查看所有日志（默认情况下 ，只保存本次启动的日志）$ sudo journalctl# 查看内核日志（不显示应用日志）$ sudo journalctl -k# 查看系统本次启动的日志$ sudo journalctl -b$ sudo journalctl -b -0# 查看上一次启动的日志（需更改设置）$ sudo journalctl -b -1# 查看指定时间的日志$ sudo journalctl --since="2012-10-30 18:17:16"$ sudo journalctl --since "20 min ago"$ sudo journalctl --since yesterday$ sudo journalctl --since "2015-01-10" --until "2015-01-11 03:00"$ sudo journalctl --since 09:00 --until "1 hour ago"# 显示尾部的最新10行日志$ sudo journalctl -n# 显示尾部指定行数的日志$ sudo journalctl -n 20# 实时滚动显示最新日志$ sudo journalctl -f# 查看指定服务的日志$ sudo journalctl /usr/lib/systemd/systemd# 查看指定进程的日志$ sudo journalctl _PID=1# 查看某个路径的脚本的日志$ sudo journalctl /usr/bin/bash# 查看指定用户的日志$ sudo journalctl _UID=33 --since today# 查看某个 Unit 的日志$ sudo journalctl -u nginx.service$ sudo journalctl -u nginx.service --since today# 实时滚动显示某个 Unit 的最新日志$ sudo journalctl -u nginx.service -f# 合并显示多个 Unit 的日志$ journalctl -u nginx.service -u php-fpm.service --since today# 查看指定优先级（及其以上级别）的日志，共有8级# 0: emerg# 1: alert# 2: crit# 3: err# 4: warning# 5: notice# 6: info# 7: debug$ sudo journalctl -p err -b# 日志默认分页输出，--no-pager 改为正常的标准输出$ sudo journalctl --no-pager# 以 JSON 格式（单行）输出$ sudo journalctl -b -u nginx.service -o json# 以 JSON 格式（多行）输出，可读性更好$ sudo journalctl -b -u nginx.serviceqq -o json-pretty# 显示日志占据的硬盘空间$ sudo journalctl --disk-usage# 指定日志文件占据的最大空间$ sudo journalctl --vacuum-size=1G# 指定日志文件保存多久$ sudo journalctl --vacuum-time=1years 概念系统运行级别runlevel/init（已过时） 运行级别有7种： level 0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动level 1：单用户状态，root权限，用于系统维护，禁止远程登陆level 2：多用户没网状态level 3：完全的多用户状态，登陆后进入控制台命令行模式level 4：系统未使用，保留level 5：X11控制台，登陆后进入图形GUI模式level 6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动 CentOS6中的运行级别各自开机启动服务进程的原理： 1.在/etc/rc.d/init.d下有服务脚本，称为服务(service)2.在/etc/rc.d下有7个名为rcN.d的目录，对应系统的7个运行级别3.rcN.d目录下都是一些符号链接文件，这些链接文件都指向init.d目录下的service脚本文件，命名规则为K+nn+服务名或S+nn+服务名，其中nn为两位数字。4.系统会根据指定的运行级别进入对应的rcN.d目录，并按照文件名顺序检索目录下的链接文件 对于以K开头的文件，系统将终止对应的服务 对于以S开头的文件，系统将启动对应的服务 在CentOS7中，设置系统默认启动级别的/etc/inittab文件说明如下： 12345678910111213141516# inittab is no longer used when using systemd.## ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.## Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target## systemd uses 'targets' instead of runlevels. By default, there are two main targets:## multi-user.target: analogous to runlevel 3# graphical.target: analogous to runlevel 5## To view current default target, run:# systemctl get-default## To set a default target, run:# systemctl set-default TARGET.target systemd.target设置系统默认运行级别： 在systemd中取而代之的是TARGET.target，并通过systemctl set-default设置。 123456获得当前的运行级别# systemctl get-default设置默认的运行级别# systemctl set-default TARGET.target在不重启的情况下，切换到指定运行级别# systemctl isolate TARGET.target TARGET.target对应级别：level 0：shutdown.targetlevel 1：emergency.targetlevel 2：rescure.targetlevel 3：multi-user.targetlevel 4：-level 5：graphical.targetlevel 6：- 服务脚本存放目录 /usr/lib/systemd/system/ 服务脚本存放目录 /run/systemd/system/ 服务运行产生的服务脚本目录 /etc/systemd/system/ 系统运行级别对应启动的服务脚本目录 从下面启用禁用nginx开机启动的例子，可以看出，nginx的服务启动脚本是放在/usr/lib/systemd/system/下并且服务命名为nginx.service，我当前登录的系统运行级别是multi-user.target多用户环境，所以当告诉systemd开机启用nginx时，它会在/etc/systemd/system/multi-user.target.wants/目录下创建一个符号链接指向nginx的服务脚本。当我想禁用nginx时，它又删除了这个符号链接。12345678# systemctl get-defaultmulti-user.target# systemctl enable nginxCreated symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.# systemctl disable nginxRemoved symlink /etc/systemd/system/multi-user.target.wants/nginx.service. /etc/sysconfig/ 存放服务的配置文件 /var/lib/ 存放服务产生的数据 /run/ 存放服务启动后的lock file和pid file 认识Systemd UnitUnit种类：Service unit：系统服务Target unit：多个 Unit 构成的一个组Device Unit：硬件设备Mount Unit：文件系统的挂载点Automount Unit：自动挂载点Path Unit：文件或路径Scope Unit：不是由 Systemd 启动的外部进程Slice Unit：进程组Snapshot Unit：Systemd 快照，可以切回某个快照Socket Unit：进程间通信的 socketSwap Unit：swap 文件Timer Unit：定时器 Unit相关命令：123456789101112131415161718列出正在运行的 Unit# systemctl list-units列出所有Unit，包括没有找到配置文件的或者启动失败的# systemctl list-units --all列出所有没有运行的 Unit# systemctl list-units --all --state=inactive列出所有加载失败的 Unit# systemctl list-units --failed列出所有正在运行的、类型为 service 的 Unit# systemctl list-units --type=service列出unit依赖# systemctl list-dependencies nginx.service列出unit详细依赖# systemctl list-dependencies --all nginx.service列出谁依赖这个unit# systemctl list-dependencies nginx.service --reverse列出unit状态# systemctl list-unit-files 编写服务脚本先看看nginx.service是怎么写的1234567891011121314151617# vim /usr/lib/systemd/system/nginx.service[Unit]Description=nginx - high performance web serverDocumentation=http://nginx.org/en/docs/After=network-online.target remote-fs.target nss-lookup.targetWants=network-online.target[Service]Type=forkingPIDFile=/var/run/nginx.pidExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.confExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s TERM $MAINPID[Install]WantedBy=multi-user.target Unit服务脚本配置[Unit]用来定义元数据以及服务依赖关系。主要字段如下12345678910Description：简短描述Documentation：文档地址Requires：依赖哪些Unit，如果它们没有运行，当前Unit会启动失败Wants：需要哪些Unit，如果它们没有运行，当前Unit不会启动失败BindsTo：与Requires类似，如果指定Unit终止，当前Unit也终止Before：指定在哪些Unit之前启动After：指定在哪些Unit之后启动Conflicts：指定不能同时运行的UnitCondition...：当前 Unit 运行必须满足的条件，否则不会运行Assert...：当前 Unit 运行必须满足的条件，否则会报启动失败 [Service]用来定义服务配置，只有Service类型的Unit才有。主要字段如下1234567891011121314151617Type：定义启动时的进程行为。它有以下几种值。Type=simple：默认值，执行ExecStart指定的命令，启动主进程Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行Type=dbus：当前服务通过D-Bus启动Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行Type=idle：若有其他任务执行完毕，当前服务才会运行ExecStart：启动当前服务的命令ExecStartPre：启动当前服务之前执行的命令ExecStartPost：启动当前服务之后执行的命令ExecReload：重启当前服务时执行的命令ExecStop：停止当前服务时执行的命令ExecStopPost：停止当其服务之后执行的命令RestartSec：自动重启当前服务间隔的秒数Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdogTimeoutSec：定义 Systemd 停止当前服务之前等待的秒数Environment：指定环境变量 [Install]用来定义如何启动。主要字段如下1234WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中Alias：当前 Unit 可用于启动的别名Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit 详细请参考官方文档systemd.service 中文手册-金步国Systemd 入门教程：命令篇-阮一峰 @和%I的玩法在服务命名的时候@后可以带一个参数，传给%I。可以参考《自己写一个服务脚本》一章。 自己写一个服务脚本现在尝试写一个管理java服务管理的脚本，并且可以指定任何端口启动。user-srv@6666.service这个服务就代表java程序HTTP通信端口将绑定在6666。12345678910111213141516# vim /usr/lib/systemd/system/user-srv@.service[Unit]Description=User ServiceAfter=multi-user.target[Service]Type=simpleExecStart=/disk1/lib/jdk1.8.0_201/bin/java -jar -Dserver.port=%I /disk1/pack/user-srv/user-srv.jarExecStop=/bin/kill -s TERM $MAINPIDSuccessExitStatus=143Restart=on-failureRestartSec=10s[Install]WantedBy=multi-user.target java程序的退出状态码是143，所以要指定成功退出状态码为143，告诉systemd这个java程序成功退出了。要不然会反复尝试重启。 记得每次修改服务脚本后都要重载脚本1# systemctl daemon-reload 写好之后试试启动，停止、重启123456789101112131415161718192021222324252627282930313233343536373839404142# systemctl start user-srv@6666.service# systemctl status user-srv@6666.service -l● user-srv@6666.service - User Service Loaded: loaded (/usr/lib/systemd/system/user-srv@.service; disabled; vendor preset: disabled) Active: active (running) since 五 2019-02-22 12:28:35 CST; 17s ago Main PID: 10702 (java) CGroup: /system.slice/system-user\x2dsrv.slice/user-srv@6666.service └─10702 /disk1/lib/jdk1.8.0_201/bin/java -jar -Dserver.port=6666 /disk1/pack/user-srv/user-srv.jar2月 22 12:28:38 test.ntg java[10702]: 2019-02-22 12:28:38.491[INFO][main]org.apache.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-6666"]2月 22 12:28:38 test.ntg java[10702]: 2019-02-22 12:28:38.510[INFO][main]org.apache.catalina.core.StandardService - Starting service [Tomcat]2月 22 12:28:38 test.ntg java[10702]: 2019-02-22 12:28:38.511[INFO][main]org.apache.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/9.0.16]2月 22 12:28:38 test.ntg java[10702]: 2019-02-22 12:28:38.612[INFO][main]org.apache.catalina.core.AprLifecycleListener - The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: [/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib]2月 22 12:28:38 test.ntg java[10702]: 2019-02-22 12:28:38.697[INFO][main]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext2月 22 12:28:38 test.ntg java[10702]: 2019-02-22 12:28:38.698[INFO][main]org.springframework.web.context.ContextLoader - Root WebApplicationContext: initialization completed in 1702 ms2月 22 12:28:39 test.ntg java[10702]: 2019-02-22 12:28:39.976[INFO][main]org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-6666"]2月 22 12:28:40 test.ntg java[10702]: 2019-02-22 12:28:39.996[INFO][main]o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port(s): 6666 (http) with context path ''2月 22 12:28:40 test.ntg java[10702]: 2019-02-22 12:28:39.998[INFO][main]com.nitaoge.reiki.user.srv.launcher.AppLauncher - Started AppLauncher in 3.77 seconds (JVM running for 4.168)2月 22 12:28:40 test.ntg java[10702]: 2019-02-22 12:28:40.000[INFO][main]com.nitaoge.reiki.user.srv.launcher.AppLauncher - 服务 - 启动成功# jps10702 user-srv.jar11134 Jps# systemctl stop user-srv@6666.service# systemctl status user-srv@6666.service -l● user-srv@6666.service - User Service Loaded: loaded (/usr/lib/systemd/system/user-srv@.service; disabled; vendor preset: disabled) Active: inactive (dead)2月 22 12:28:38 test.ntg java[10702]: 2019-02-22 12:28:38.612[INFO][main]org.apache.catalina.core.AprLifecycleListener - The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: [/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib]2月 22 12:28:38 test.ntg java[10702]: 2019-02-22 12:28:38.697[INFO][main]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext2月 22 12:28:38 test.ntg java[10702]: 2019-02-22 12:28:38.698[INFO][main]org.springframework.web.context.ContextLoader - Root WebApplicationContext: initialization completed in 1702 ms2月 22 12:28:39 test.ntg java[10702]: 2019-02-22 12:28:39.976[INFO][main]org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-6666"]2月 22 12:28:40 test.ntg java[10702]: 2019-02-22 12:28:39.996[INFO][main]o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port(s): 6666 (http) with context path ''2月 22 12:28:40 test.ntg java[10702]: 2019-02-22 12:28:39.998[INFO][main]com.nitaoge.reiki.user.srv.launcher.AppLauncher - Started AppLauncher in 3.77 seconds (JVM running for 4.168)2月 22 12:28:40 test.ntg java[10702]: 2019-02-22 12:28:40.000[INFO][main]com.nitaoge.reiki.user.srv.launcher.AppLauncher - 服务 - 启动成功2月 22 12:29:21 test.ntg systemd[1]: Stopping User Service...2月 22 12:29:21 test.ntg java[10702]: 2019-02-22 12:29:21.508[INFO][Thread-3]com.nitaoge.reiki.user.srv.launcher.AppLauncher - 服务 - 关闭成功2月 22 12:29:21 test.ntg systemd[1]: Stopped User Service. 尝试强制关闭这个进程，看看是否重启123456789101112131415161718192021222324252627282930313233343536373839404142434445# jps11301 user-srv.jar11365 Jps# kill -9 11301# systemctl status user-srv@6666.service -l● user-srv@6666.service - User Service Loaded: loaded (/usr/lib/systemd/system/user-srv@.service; disabled; vendor preset: disabled) Active: activating (auto-restart) (Result: exit-code) since 五 2019-02-22 12:36:37 CST; 5s ago Process: 11387 ExecStop=/bin/kill -s TERM $MAINPID (code=exited, status=1/FAILURE) Process: 11301 ExecStart=/disk1/lib/jdk1.8.0_201/bin/java -jar -Dserver.port=%I /disk1/pack/user-srv/user-srv.jar (code=killed, signal=KILL) Main PID: 11301 (code=killed, signal=KILL)2月 22 12:36:37 test.ntg kill[11387]: -q, --queue &lt;信号&gt; 使用 sigqueue(2) 代替 kill(2)2月 22 12:36:37 test.ntg kill[11387]: -p, --pid 打印 pid 而不向它们发送信号2月 22 12:36:37 test.ntg kill[11387]: -l, --list [=&lt;信号&gt;] 列出信号名，或将一个信号转换为名称2月 22 12:36:37 test.ntg kill[11387]: -L, --table 列出信号名和数值2月 22 12:36:37 test.ntg systemd[1]: user-srv@6666.service: control process exited, code=exited status=12月 22 12:36:37 test.ntg kill[11387]: -h, --help 显示此帮助并退出2月 22 12:36:37 test.ntg kill[11387]: -V, --version 输出版本信息并退出2月 22 12:36:37 test.ntg kill[11387]: 更多信息请参阅 kill(1)。2月 22 12:36:37 test.ntg systemd[1]: Unit user-srv@6666.service entered failed state.2月 22 12:36:37 test.ntg systemd[1]: user-srv@6666.service failed.10秒后再看# systemctl status user-srv@6666.service -l● user-srv@6666.service - User Service Loaded: loaded (/usr/lib/systemd/system/user-srv@.service; disabled; vendor preset: disabled) Active: active (running) since 五 2019-02-22 12:36:47 CST; 8s ago Process: 11387 ExecStop=/bin/kill -s TERM $MAINPID (code=exited, status=1/FAILURE) Main PID: 11398 (java) CGroup: /system.slice/system-user\x2dsrv.slice/user-srv@6666.service └─11398 /disk1/lib/jdk1.8.0_201/bin/java -jar -Dserver.port=6666 /disk1/pack/user-srv/user-srv.jar2月 22 12:36:50 test.ntg java[11398]: 2019-02-22 12:36:50.620[INFO][main]org.apache.catalina.core.AprLifecycleListener - The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path: [/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib]2月 22 12:36:50 test.ntg java[11398]: 2019-02-22 12:36:50.829[INFO][main]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext2月 22 12:36:50 test.ntg java[11398]: 2019-02-22 12:36:50.829[INFO][main]org.springframework.web.context.ContextLoader - Root WebApplicationContext: initialization completed in 1862 ms2月 22 12:36:52 test.ntg java[11398]: 2019-02-22 12:36:52.228[INFO][main]org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-6666"]2月 22 12:36:52 test.ntg java[11398]: 2019-02-22 12:36:52.264[INFO][main]o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port(s): 6666 (http) with context path ''2月 22 12:36:52 test.ntg java[11398]: 2019-02-22 12:36:52.268[INFO][main]com.nitaoge.reiki.user.srv.launcher.AppLauncher - Started AppLauncher in 4.021 seconds (JVM running for 4.47)2月 22 12:36:52 test.ntg java[11398]: 2019-02-22 12:36:52.271[INFO][main]com.nitaoge.reiki.user.srv.launcher.AppLauncher - 服务 - 启动成功2月 22 12:36:52 test.ntg java[11398]: 2019-02-22 12:36:52.541[INFO][http-nio-6666-exec-1]o.a.catalina.core.ContainerBase.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet 'dispatcherServlet'2月 22 12:36:52 test.ntg java[11398]: 2019-02-22 12:36:52.541[INFO][http-nio-6666-exec-1]org.springframework.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'2月 22 12:36:52 test.ntg java[11398]: 2019-02-22 12:36:52.549[INFO][http-nio-6666-exec-1]org.springframework.web.servlet.DispatcherServlet - Completed initialization in 8 ms 这里我同样试了优雅关闭，同样会重启，这样就实现了服务挂掉尝试重启的功能。 接下来尝试重启系统，看看会不会开机启动12345678# systemctl enable user-srv@6666.serviceCreated symlink from /etc/systemd/system/multi-user.target.wants/user-srv@6666.service to /usr/lib/systemd/system/user-srv@.service.# reboot# jps4279 user-srv.jar4361 Jps 再开一个7777端口的java程序12345# systemctl restart user-srv@7777.service# jps4432 user-srv.jar4279 user-srv.jar4446 Jps 齐活。 不光是java程序，所有服务都可以交给systemd管理。例如mysql、kafka、zk、es等等。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>看破Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Linux 5.编辑神器-vim]]></title>
    <url>%2Fp%2F76709178%2F</url>
    <content type="text"><![CDATA[背景目前Linux中比较主流的编辑器有nano、vi/vim和emacs。简单看了下nano的风格，好像回到了上世纪70年代，相信历史进程的我，不信它功能比vim强，所以用它可以，但真的没必要。而vi作为rh、centos系统自带编辑器，学之利弊多说无益。centos7.6已默认安装vim，老版本没有可以yum安装。而emacs更像一个IDE，我承认其功能强大，但如果我想在每台服务器上使用emacs……安装依赖包如下？！？！@？？￥@#……？？1234567891011121314151617181920212223242526272829303132333435363738394041安装 1 软件包 (+96 依赖软件包)总下载量：67 M安装大小：220 M已安装: emacs.x86_64 1:24.3-22.el7作为依赖被安装: GConf2.x86_64 0:3.2.6-8.el7 ImageMagick.x86_64 0:6.7.8.9-16.el7_6 OpenEXR-libs.x86_64 0:1.7.1-7.el7 adwaita-cursor-theme.noarch 0:3.28.0-1.el7 adwaita-icon-theme.noarch 0:3.28.0-1.el7 at-spi2-atk.x86_64 0:2.26.2-1.el7 at-spi2-core.x86_64 0:2.28.0-1.el7 atk.x86_64 0:2.28.1-1.el7 avahi-libs.x86_64 0:0.6.31-19.el7 cairo.x86_64 0:1.15.12-3.el7 cairo-gobject.x86_64 0:1.15.12-3.el7 colord-libs.x86_64 0:1.3.4-1.el7 cups-libs.x86_64 1:1.6.3-35.el7 dconf.x86_64 0:0.28.0-4.el7 dejavu-fonts-common.noarch 0:2.33-6.el7 dejavu-sans-fonts.noarch 0:2.33-6.el7 dejavu-sans-mono-fonts.noarch 0:2.33-6.el7 emacs-common.x86_64 1:24.3-22.el7 fontconfig.x86_64 0:2.13.0-4.3.el7 fontpackages-filesystem.noarch 0:1.44-8.el7 fribidi.x86_64 0:1.0.2-1.el7 gdk-pixbuf2.x86_64 0:2.36.12-3.el7 ghostscript.x86_64 0:9.07-31.el7_6.10 ghostscript-fonts.noarch 0:5.50-32.el7 giflib.x86_64 0:4.1.6-9.el7 glib-networking.x86_64 0:2.56.1-1.el7 gnutls.x86_64 0:3.3.29-9.el7_6 graphite2.x86_64 0:1.3.10-1.el7_3 gsettings-desktop-schemas.x86_64 0:3.28.0-2.el7 gtk-update-icon-cache.x86_64 0:3.22.30-3.el7 gtk3.x86_64 0:3.22.30-3.el7 harfbuzz.x86_64 0:1.7.5-2.el7 hicolor-icon-theme.noarch 0:0.12-7.el7 ilmbase.x86_64 0:1.0.3-7.el7 jasper-libs.x86_64 0:1.900.1-33.el7 jbigkit-libs.x86_64 0:2.0-11.el7 json-glib.x86_64 0:1.4.2-2.el7 lcms2.x86_64 0:2.6-3.el7 libICE.x86_64 0:1.0.9-9.el7 libSM.x86_64 0:1.2.2-2.el7 libX11.x86_64 0:1.6.5-2.el7 libX11-common.noarch 0:1.6.5-2.el7 libXau.x86_64 0:1.0.8-2.1.el7 libXaw.x86_64 0:1.0.13-4.el7 libXcomposite.x86_64 0:0.4.4-4.1.el7 libXcursor.x86_64 0:1.1.15-1.el7 libXdamage.x86_64 0:1.1.4-4.1.el7 libXext.x86_64 0:1.3.3-3.el7 libXfixes.x86_64 0:5.0.3-1.el7 libXft.x86_64 0:2.3.2-2.el7 libXi.x86_64 0:1.7.9-1.el7 libXinerama.x86_64 0:1.1.3-2.1.el7 libXmu.x86_64 0:1.1.2-2.el7 libXpm.x86_64 0:3.5.12-1.el7 libXrandr.x86_64 0:1.5.1-2.el7 libXrender.x86_64 0:0.9.10-1.el7 libXt.x86_64 0:1.1.5-3.el7 libXtst.x86_64 0:1.2.3-1.el7 libXxf86vm.x86_64 0:1.1.4-1.el7 libepoxy.x86_64 0:1.5.2-1.el7 libfontenc.x86_64 0:1.1.3-3.el7 libglvnd.x86_64 1:1.0.1-0.8.git5baa1e5.el7 libglvnd-egl.x86_64 1:1.0.1-0.8.git5baa1e5.el7 libglvnd-glx.x86_64 1:1.0.1-0.8.git5baa1e5.el7 libgusb.x86_64 0:0.2.9-1.el7 libjpeg-turbo.x86_64 0:1.2.90-6.el7 liblockfile.x86_64 0:1.08-17.el7 libotf.x86_64 0:0.9.13-4.el7 librsvg2.x86_64 0:2.40.20-1.el7 libsoup.x86_64 0:2.62.2-2.el7 libthai.x86_64 0:0.1.14-9.el7 libtiff.x86_64 0:4.0.3-27.el7_3 libtool-ltdl.x86_64 0:2.4.2-22.el7_3 libwayland-client.x86_64 0:1.15.0-1.el7 libwayland-cursor.x86_64 0:1.15.0-1.el7 libwayland-egl.x86_64 0:1.15.0-1.el7 libwayland-server.x86_64 0:1.15.0-1.el7 libwmf-lite.x86_64 0:0.2.8.4-41.el7_1 libxcb.x86_64 0:1.13-1.el7 libxkbcommon.x86_64 0:0.7.1-1.el7 libxshmfence.x86_64 0:1.2-1.el7 m17n-db.noarch 0:1.6.4-4.el7 m17n-lib.x86_64 0:1.6.4-14.el7 mesa-libEGL.x86_64 0:18.0.5-4.el7_6 mesa-libGL.x86_64 0:18.0.5-4.el7_6 mesa-libgbm.x86_64 0:18.0.5-4.el7_6 mesa-libglapi.x86_64 0:18.0.5-4.el7_6 nettle.x86_64 0:2.7.1-8.el7 pango.x86_64 0:1.42.4-1.el7 poppler-data.noarch 0:0.4.6-3.el7 psmisc.x86_64 0:22.20-15.el7 rest.x86_64 0:0.8.1-2.el7 trousers.x86_64 0:0.3.14-2.el7 urw-fonts.noarch 0:2.4-16.el7 xkeyboard-config.noarch 0:2.24-1.el7 xorg-x11-font-utils.x86_64 1:7.5-21.el7 概念vi(visual editor)可视化编辑器，读作”vee-eye”；vim（vi Improved）vi的改良版，读作”vim”。 普通玩法打开文件vim [options] [filename] vim所有对文件的操作都会存放在缓冲区中，除非保存，否则任何操作都会丢失。1234# vim testfile# ll -a | grep swp-rw------- 1 root root 12288 2月 21 11:02 .testfile.swp vim +10 file，打开文件，光标在第10行。 vim + file，打开文件，光标在内容尾行。 vim +/pattern file，打开文件，光标在第一个匹配结果处。 vim -R file，只读模式打开文件。 vim -r file，从缓冲区恢复上次死机或退出终端没正常退出的操作。 vim -b file，以二进制模式编辑。 vim -d file，以diff模式编辑多个文件。 vim -o file1 file2，以水平分割窗口方式打开多个文件。 vim -O file1 file2，以垂直分割窗口方式打开多个文件。 设置编辑器 :set all，查看编辑器所有设置项 :set option?，查看设置项属性 :set nu / :set nu!，打开/关闭行号显示 :set ic / :set ic!，打开/关闭搜索忽略大小写 持久化设置：在主目录下新建.exrc文件，在里边加入set nu等设置项。 命令模式和插入模式 命令模式等待输入命令，按ESC恢复成命令模式。 插入模式即可编辑文本，命令模式下按i和a进入插入模式。 i（插入）是在光标前插入，a（追加）是在光标后插入。 I在当前行首插入，A在当前行尾插入。 o在当前行下一行插入，O在当前行上一行插入。 数字+i/I/a/A/o/O+字符+ESC，可以重复插入N个字符。 保存退出 :q!，强制退出 :w，保存不退出 :x，保存退出 :x!，强制保存退出 :qa!，退出所有窗口不保存 移动光标 上、下、左、右k、j、h、l↑、↓、←、→ 按光标键前先按数字，即可使光标移到指定第N个字符位置，并且不超过边界。比如： 123|a|bcdefghijk按3→，则光标跳到abc|d|efghijk 按数字0将光标移到行首，按符号$将光标移到行尾。 按照文本块（可以是单词、标点符号）移动光标，b是前一个，w是后一个。 按照文本块（仅限单词）移动光标，大写B是前一个，大写W是后一个。 先按数字，然后按w/W、b/B是向前或向后移动N个文本框。 Ctrl+g，显示当前光标位置百分比。 按大写G将光标移到文本末尾行，按数字1+G移到文本首行，按数字+G移动到第N行开头位置。 按``，恢复光标到使用G移动光标前的位置。 (，光标移动到当前句子开头或上个句子开头。 )，光标移动到下一个句子开头。 {，光标移动到当前段落开头或上一段落开头。 }，光标移动到下一个段落开头。 [[，光标移动到当前节开头或上一节开头。 ]]，光标移动到下一节开头。 标记光标 m+字符，给当前光标位置标记为字符。 `+字符，移动光标到字符标记处。 ‘+字符，移动光标到字符标记的行首。 ``，恢复光标到移动前位置。 ‘’，恢复光标到移动前位置行首。 复制操作 yy，复制光标处指定行，然后按p粘贴到光标行下方。 y+0，复制光标至行首的所有字符，然后按p粘贴到光标处。 y+$，复制光标至行尾的所有字符，然后按p粘贴到光标处。 y+数字，按回车，复制包括当前行下N+1行，然后按p粘贴N+1行到光标行下方。 数字+yy，复制包括当前行下N行，然后按p粘贴N行到光标行下方。 y+w/W，复制从光标到该单词结尾，然后按p粘贴到光标处。 y+数字+w/W，复制从光标到后面N个单词结尾，然后按p粘贴到光标处。 y+b/B，复制从光标到该单词开头，然后按p粘贴到光标处。 y+数字+b/B，复制从光标到前面N个单词开头，然后按p粘贴到光标处。 删除操作 x，删除光标处字符。 数字+x，删除包括光标处N个字符。 dd，删除选中行。 d+0，删除光标至行首的所有字符。 d+$或大写D，删除光标至行尾的所有字符。 d+数字，按回车，删除包括当前行下N+1行。 数字+dd，删除包括当前行下N行。 d+数字+w/W或d+数字+b/B同理。 缓冲区会记录最后一步删除操作，按p会粘贴出来。 这里要说下c（更改文本），实际上就是删除指定文本，然后进入插入模式。 cc或大写S，删除选中行，~。 c+0，删除光标到行开头所有字符，~。 c+$或大写C，删除光标到行末尾所有字符，~。 c+数字，按回车，删除包括当前行下N+1行，~。 数字+cc，删除包括当前行下N行，~。 c+数字+w/W或c+数字+b/B同理。 替换操作 r+指定字符，将光标处字符替换为指定字符。 数字+r+指定字符，将包括光标处后N个字符替换为指定字符。 大写R进入覆盖模式，会使用用户输入字符覆盖光标处字符，按回车换行可以继续覆盖。 ~，会将光标处字符切换大小写。 合并行 大写J，合并光标所在行和下一行。 数字+J，合并包括光标所在行下N行。 撤销操作 u，撤销上一步操作。 数字+u，撤销回上N步操作。 大写U，切换上一步操作所在行为初始状态和改变后状态。 重做操作 Ctrl+r，重做刚刚按u的撤销操作。 搜索 /+字符，向后搜索。 ?+字符，向前搜索。 n，向同一方向移动光标至匹配结果。 N，向相反方向移动光标至匹配结果。 f+字符，将光标移动至当前行下一个匹配字符处。 F+字符，将光标移动至当前行上一个匹配字符处。 配合y/d+搜索功能，可以复制或删除当前光标到第一个匹配结果之间的所有内容。 屏幕滚动 Ctrl+F，向后翻一页。 Ctrl+B，向前翻一页。 Ctrl+D，向后翻半页。 Ctrl+U，向前翻半页。 Ctrl+E，向后翻一行。 Ctrl+Y，向前翻一行。 z+回车，滚动屏幕使光标置于顶部。 z+.，滚动屏幕使光标置于中部。 z+-，滚动屏幕使光标置于底部。 重画屏幕终端滚动条向上翻之后，如果找不到文本在屏幕位置，按Ctrl+L，可以重画文本可视屏幕。 光标在屏幕中移动 H，光标移动到屏幕顶端的行。 数字+H，光标移动到屏幕顶端行下N行。 M，光标移动到屏幕中间的行。 L，光标移动到屏幕底部的行。 数字+L，光标移动到屏幕底部行上N行。 组合操作（一次根本记不住-0-，需要经常敲） 全局替换 :s/old/new，替换当前行第一个匹配结果。 :s/old/new/g，替换当前行所有匹配结果。 :50,100s/old/new/g，指定范围替换匹配结果。 :1,$s/old/new/g 或 :%s/old/new/g，替换整个文本匹配结果。 :%s/old/new/gc，替换前确认。 :g/正则/%s/old/new/g，在所有符合正则匹配的行里执行替换。 匹配正则 字符. -&gt; 匹配单字符 字符* -&gt; 通配符 \^字符 -&gt; 匹配开头字符 字符$ -&gt; 匹配结尾字符 . -&gt; 匹配转义符 [] -&gt; 匹配中括号内任意字符 \&lt; -&gt; 只匹配单词开头 > -&gt; 只匹配单词末尾 高端玩法执行Unix命令 !date，新开命令行执行date命令 :r !date，在当前行输出date命令结果 :r !type java，在当前行输出java所在路径 使用ab缩写命令 :ab addr address，将address命令缩写为addr :unab abbr，取消缩写 :ab，查看所有缩写 使用map映射命令序列 :map mm yy p，将mm命令序列映射成复制当前行然后粘贴。 :unmap mm，取消映射 :map，查看所有映射 多窗口编辑 :split file，水平分割当前窗口，并打开指定文件（不指定则默认当前文件）。 :vsplit file，垂直分割当前窗口，并打开指定文件（不指定则默认当前文件）。 :[n]split [++opt] [+cmd] file，以N行水平分割当前窗口，打开指定文件。 :[n]new [++opt] [+cmd] file，以N行水平分割当前窗口，打开指定文件。 :sview [++opt] [+cmd] file，水平分割当前窗口，以只读模式打开指定文件。 :sfind [++opt] [+cmd] file，水平分割当前窗口，没找到文件则不操作。 :set mouse=a，为编辑器激活鼠标操作。 ctrl+w+方向键，光标移至选择窗口。 移动窗口 ctrl+w+r，向右或向下移动窗口。 ctrl+w+R，向左或向上移动窗口。 ctrl+w+x/X，交换同列或同行的窗口。 数字+ctrl+w+x/x，交换第N个同列或同行的窗口。 ctrl+w+K，移动当前窗口至顶部。 ctrl+w+J，移动当前窗口至底部。 ctrl+w+H，移动当前窗口至最左部。 ctrl+w+L，移动当前窗口至最右部。 ctrl+w+=，调整所有窗口至相同行数尺寸。 ctrl+w++，增加当前窗口行数。 ctrl+w+-，减少当前窗口行数。 :resize 10/+10/-10，使用命令调整窗口行数。 ctrl+w+|，调整当前窗口为最大宽度。 ctrl+w+&lt;/&gt;，调整当前窗口宽度。 vertical resize 50，使用命令调整窗口宽度。 关闭窗口 ctrl+w+q，关闭当前窗口。 ctrl+w+o/O，关闭除当前窗口的其他窗口。 :qa!/:wq!，关闭所有窗口，不保存/保存。 折叠文本 数字+z+F，折叠包括当前行下N行。 z+A，切换光标处折叠。 z+E，去除所有折叠。 缩进文本 数字+&gt;&gt;，包括当前行下N行向右缩进一个Tab。 数字+&lt;&lt;，包括当前行下N行向左缩进一个Tab。 数字+==，自动缩进N行。 使用以下设置，每次点击Tab键，增加的缩进将被转化为4个空格。 1234:set tabstop=4:set softtabstop=4:set shiftwidth=4:set expandtab 其中，expandtab选项，用来控制是否将Tab转换为空格。但是这个选项并不会改变已经存在的文本，如果需要应用此设置将所有Tab转换为空格，需要执行以下命令： 1:retab! 主要有cindent、smartindent和autoindent三种自动缩进模式。 :set autoindent autoindent 在这种缩进形式中，新增加的行和前一行使用相同的缩进形式。可以使用以下命令，启用autoindent缩进形式。也可以点击==键进行缩进。 :set smartindent smartindent 在这种缩进模式中，每一行都和前一行有相同的缩进量，同时这种缩进形式能正确的识别出花括号，当遇到右花括号（}），则取消缩进形式。此外还增加了识别C语言关键字的功能。如果一行是以#开头的，那么这种格式将会被特殊对待而不采用缩进格式。可以使用以下命令，启用smartindent缩进结构。 :set cindent cindent Vim可以很好的识别出C和Java等结构化程序设计语言，并且能用C语言的缩进格式来处理程序的缩进结构。可以使用以下命令，启用cindent缩进结构。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>看破Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Linux 4.ShellScript]]></title>
    <url>%2Fp%2F5234275c%2F</url>
    <content type="text"><![CDATA[概念什么是Shellshell是用户和Linux内核之间的接口程序。在提示符下输入的每个命令都由shell先解释然后传给Linux内核。 shell 是一个命令语言解释器（command-language interpreter）。拥有自己内建的 shell 命令集。此外，shell也能被系统中其他有效的Linux 实用程序和应用程序（utilities and application programs）所调用。 12345# less /bin/bash"/bin/bash" may be a binary file. See it anyway?# less /usr/bin/python"/usr/bin/python" may be a binary file. See it anyway? 可以看出shell是一个二进制可执行文件。 Shell解释器的种类linux内置的shell1234567# cat /etc/shells/bin/sh/bin/bash/usr/bin/sh/usr/bin/bash/bin/tcsh/bin/csh 其他shell比如python12# ll /usr/bin/pythonlrwxrwxrwx. 1 root root 7 2月 18 09:15 /usr/bin/python -&gt; python2 还有其他的自行开发。 查看bash版本1234567# bash -versionGNU bash， 版本 4.2.46(2)-release (x86_64-redhat-linux-gnu)Copyright (C) 2011 Free Software Foundation, Inc.许可证 GPLv3+: GNU GPL 许可证版本3或者更高 &lt;http://gnu.org/licenses/gpl.html&gt;这是自由软件，您可以自由地更改和重新发布。在法律允许的范围内没有担保. /bin/sh和/bin/bash的区别由于历史进程，bash提供更丰富的功能，随后将/bin/sh软链接指向/bin/bash，所以两者使用上是一样的。123# ll /bin/sh /bin/bash-rwxr-xr-x. 1 root root 964608 8月 3 2017 /bin/bashlrwxrwxrwx. 1 root root 4 2月 16 10:27 /bin/sh -&gt; bash /bin/csh和/bin/tcshsh 之后另一个广为流传的 shell 是由柏克莱大学的 Bill Joy 设计的，这个 shell 的语法有点类似C语言，所以才得名为 C shell ，简称为 csh。 Bill Joy 是一个风云人物，他创立了 BSD 操作系统，开发了 vi 编辑器，还是 Sun 公司的创始人之一。BSD 是 UNIX 的一个重要分支，后人在此基础上发展出了很多现代的操作系统，最著名的有 FreeBSD、OpenBSD 和 NetBSD，就连 Mac OS X 在很大程度上也基于BSD。 tcsh 是 csh 的增强版，加入了命令补全功能，提供了更加强大的语法支持。123# ll /bin/csh /bin/tcshlrwxrwxrwx. 1 root root 4 2月 16 10:27 /bin/csh -&gt; tcsh-rwxr-xr-x. 1 root root 404648 8月 3 2017 /bin/tcsh 然而linux默认使用的终端脚本是/bin/bash，我这里深入学习下/bin/bash。12# echo $SHELL/bin/bash 基础重定向 LinuxShell支持0-8共9个文件描述符，其中0-2为系统预设： 标准输入(stdin)：文件描述符为0，使用 &lt; 或 &lt;&lt;（等价于0&lt;或0&lt;&lt;）， 0代表/dev/stdin 标准输出(stdout)：文件描述符为1，使用 &gt; 或 &gt;&gt;（等价于1&gt;或1&gt;&gt;），1代表/dev/stdout 标准错误输出(stderr)：文件描述符为2，使用 2&gt; 或 2&gt;&gt;，2代表/dev/stderr 3-8为用户自定义文件描述符： 创建自定义文件描述符： 6&gt; testfile 1&gt;&amp;6关闭自定义文件描述符： 6&gt;&amp;- 输入重定向输入重定向可以将输入文本发送给shell处理。 &lt;是将文件中的文本发送给shell；&lt;&lt;可以使用相同的文本标记表示开头和结尾，将中间的文本发送给shell，文本标记可以是任意字符，但通常使用EOF。1234567# cat &lt; testfilehello# cat &lt;&lt; EOF&gt; hello&gt; EOFhello 输出重定向输出重定向可以将输出文本发送到指定文件。 >是将输出文本覆盖到指定文件；>&gt;是将输出文本追加到指定文件。12345678# echo "hello" &gt; testfile# cat testfilehello# echo "world" &gt;&gt; testfile# cat testfilehelloworld 可以看下以下几个输出重定向使用的区别：&amp;&gt; testout 将标准输出和标准错误输出重定向输出到指定文件testout> testout 2&gt;&amp;1 将标准输出重定向输出到testout，并将标准错误输出重定向输出到标准输出2&gt; testout 1&gt;&amp;2 将标准错误输出重定向输出到testout，并将标准输出重定向到标准错误输出结果都是一样的，都是将输出重定向到testout。 这里可以看到，系统中没有undefinedcmd这个命令，那么可以通过&amp;&gt;把标准输出和标准错误输出重定向到指定文件。12345678# undefinedcmd -bash: undefinedcmd: 未找到命令# undefinedcmd &amp;&gt;result# cat result-bash: undefinedcmd: 未找到命令# undefinedcmd &amp;&gt;/dev/null 通常我们使用nohup和&amp;用于应用后台执行的时候，nohup.out控制台输出文本常常会创建在用户当前所在目录，如果我们想指定输出文本位置，可以这么玩。1# nohup java -jar test.jar &amp;&gt; /disk1/log/test/app.log &amp; 我用logback都配置好打印到哪些日志文件了，干脆不要nohup输出控制台日志，可以这么玩1# nohup java -jar test.jar &amp;&gt; /dev/null &amp; 管道管道符 | 可以用来接力命令执行结果，也就是将第一个命令的标准输出 输入到第二个命令执行，再将第二个命令的标准输出 输入到第三个命令执行，以此类推。123456# cat /etc/profile | wc -l81# ps -ef | grep nginx | grep -v "grep"root 5986 1 0 09:57 ? 00:00:00 nginx: master process nginxnginx 5987 5986 0 09:57 ? 00:00:00 nginx: worker process 变量/常量普通变量定义变量可以使用key=value，使用变量要在变量前加一个$。1234#!/bin/bashcmd_path=/usr/localcmd_type=watcherecho $cmd_path/$cmd_type 数组变量数组赋值：123array[index]=valuearray=(value1 value2 value3)array=([2]=value3 [0]=value1 [1]=value2) 引用数组：1234567891011121314151617181920#!/bin/basha=(1 2 3 4 5)echo $&#123;a[*]&#125;echo $&#123;a[@]&#125;echo $&#123;a[2]&#125;echo ------for i in $&#123;a[@]&#125;;do echo $idone# ./nonTest1 2 3 4 51 2 3 4 53------12345 *和@的区别：在不加””时二者没有区别，但加双引号之后例如”\${a[*]}”和”\${a[@]}”，*返回的是一个整串，@返回的是一个数组，这是因为加双引号，告诉内核这是一个原始变量，别给我分割。而用@就是要告诉内核，给我返回数组形式。比如上边改成遍历”\${a[*]}”的话，会输出以下结果：123456# ./nonTest1 2 3 4 51 2 3 4 53------1 2 3 4 5 清除变量unset [选项] 变量或函数名12-f 仅删除函数-v 仅删除变量 常量readonly 常量名 环境变量export name=value 父shell设置的环境变量，打开新的子shell可以使用，但子shell修改环境变量，不影响父shell。 Shell变量\$HOME 当前用户的主目录\$SHELL 当前使用的Shell\$USER 当前用户\$UID 当前用户ID\$BASH_VERSION 当前Bash版本\$PWD 当前工作目录\$OLDPWD 上一次工作目录\$SECONDS 当前SHELL运行时长，单位秒\$SHLVL 当前SHELL是登录SHELL的第几层子进程\$RANDOM 取0-32767之间的随机整数\$IFS 当前内部域分隔符 IFS是什么？ Shell 的环境变量分为 set, env 两种，其中 set 变量可以通过 export 工具导入到 env 变量中。其中，set 是显示设置shell变量，仅在本 shell 中有效；env 是显示设置用户环境变量 ，仅在当前会话中有效。换句话说，set 变量里包含了 env 变量，但 set 变量不一定都是 env 变量。这两种变量不同之处在于变量的作用域不同。显然，env 变量的作用域要大些，它可以在 subshell 中使用。而 IFS 是一种 set 变量，当 shell 处理”命令替换”和”参数替换”时，shell 根据 IFS 的值，默认是 space, tab, newline 来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量。 123456# echo $IFS# echo -n "$IFS" | od -b0000000 040 011 0120000003 直接输出IFS是看不到的，因为Shell默认分隔符是空格、制表符、换行符，把它转成二进制就能看到了。“040”是空格，”011”是Tab，”012”是换行符”\n”。 特殊变量这些特殊变量的作用域都是指向当前shell，或当前函数。 \$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。\$0 当前脚本的文件名\$n 传递给脚本或函数的第N个参数。\$# 传递给脚本或函数的参数个数。\$* 传递给脚本或函数的所有参数。\$@ 传递给脚本或函数的所有参数。（数组形式）\$? 上个命令的退出状态码，或函数的返回值。\$! 获取上一次运行的后台进程的PID。\$_ 获取上一次执行的命令的最后一个参数 怎么写脚本脚本的规范命名后缀通常为.sh，并且脚本文件要有可执行权限。执行脚本可以通过./脚本名，直接执行。也可通过bash 脚本名，来执行。也可以将当前工作目录放到环境变量PATH中，# 脚本名，执行。 脚本的第一行需要声明shell解释器，不声明的话使用系统默认的解释器。123#!/bin/bashecho hello... 命令替换在Shell脚本中想要使用命令输出结果，可以通过反引号`或$()实现。 #!/bin/bashecho `date`echo $(date) 退出脚本 &amp; 退出状态码Shell脚本中可以使用exit退出当前脚本，并返回退出状态码。123#!/bin/bashecho "hello"exit 0 可以在脚本执行完使用$?查看执行状态，以便通知我们程序处理成功还是失败。 系统预设的退出状态码：123456780 成功结束1 未知错误2 不合适的shell命令126 命令不可执行127 没找到命令 128 无效的退出参数128+x 与linux信号x相关的严重错误130 通过Ctrl+c终止的命令255 正常范围之外的退出状态码 退出状态码最大为255，超出则对255取余。 单行注释和多行注释123456# 这是个单行注释&lt;&lt; comment这是个多行注释...comment 数学运算Shell脚本中数学运算可以使用expr命令，但写起来麻烦，需要各种转义，各种冗余。Bash Shell中提供了$[]这种格式，1234567#!/bin/basha=2b=136echo "The result is " $[$a * $b]# ./testshellThe result is 272 浮点运算可以使用bc或awk123456789#!/bin/basha=2.2b=136.1echo "The result is" $(echo "scale=4; $a*$b" | bc)echo $(awk -v x=$a -v y=$b 'BEGIN &#123;printf "The result is %.4f\n",x*y&#125;')# ./testshellThe result is 299.42The result is 299.4200 处理用户输入获取脚本名$0可以获取当前脚本的文件名，你怎么执行，它就怎么显示。123456789#!/bin/bashecho $0# ./nonTest./nonTest# bash nonTestnonTest# bash /disk1/practise/shell/nonTest/disk1/practise/shell/nonTest 可以通过basename去掉目录，再看1234567#!/bin/shecho $(basename $0)# ./nonTestnonTest# bash /disk1/practise/shell/nonTestnonTest 获取输入参数在脚本中获取传入参数，可以用$数字的方式获取或赋给指定变量，当数字&gt;9时，必须用{}包上，比如${10}，${11}… $# 用于获取输入参数个数$* 获取所有参数，将输入参数拼成一个字符串$@ 获取所有参数，将输入参数拼成数组，可以用于遍历 丢弃输入参数因为$0是获取脚本名，shift 0没有任何作用。shift 不指定n的话默认是1，丢弃当前第一个参数，后面参数前移。shift n 丢弃所有前n个参数，后面参数前移。 getopt/getopts 获取输入参数getopt optstring parameters123456-a, --alternative 允许长选项以 - 开始-l, --longoptions &lt;长选项&gt; 识别长选项-q, --quiet 不提示错误信息-Q, --quiet-output 无正常输出-s, --shell &lt;shell&gt; 指定shell：sh bash csh tcsh-u, --unquoted 输出值不加引号 在optstring中列出你要在脚本中用到的选项字母，每个需要参数值的选项字母后加一个冒号，getopt命令会基于你定义的optstring解析提供的参数。 比如，我想写一个服务管理脚本，h代表帮助，v代表显示执行过程，f代表指定配置文件，m代表运行模式(master或slave)，daemon代表后台运行。就可以通过这种方式获取用户输入的参数。12345# getopt hvf:m -h -h -- # getopt hvf:m: -v -f test.conf -m master daemon -v -f test.conf -m master -- daemon 这样就可以获取”–”前面的选项、选项-参数和后面的参数，然后通过这些结果控制脚本执行。而用过的选项，就可以shift掉了，而带参数的选项，需要shift两次。大概是这么玩的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/bin/bashproc_daemon=0exec_show=0config_path=/etc/xxx.confexec_mode=normal# optionsset -- $(getopt -q hvdf:m: "$@")while [[ -n $1 ]];do case "$1" in -h) echo -e " -f 指定配置文件\n -m 指定运行模式\n -h 帮助\n -v 显示执行过程\n -d 后台运行" exit 0 ;; -f) config_path=$2 shift ;; -m) exec_mode=$2 shift ;; -d) proc_daemon=1 ;; -v) exec_show=1 ;; esac shiftdone# startupif [[ $exec_show -eq 1 ]]; thenecho "服务启动中..."echo "配置文件: $config_path"echo "运行模式: $exec_mode"fisleep 3echo "服务启动成功"# handleexec_fun()&#123; while [[ -n "true" ]];do sleep 5 echo "`date`: 处理一个请求" done&#125;if [[ $proc_daemon -eq 1 ]];then exec_fun &amp; echo "进程ID: $!"else exec_funfi# ./binTest -h -f 指定配置文件 -m 指定运行模式 -h 帮助 -v 显示执行过程 -d 后台运行# # ./binTest服务启动成功2019年 02月 18日 星期一 19:10:19 CST: 处理一个请求2019年 02月 18日 星期一 19:10:24 CST: 处理一个请求# ./binTest -v服务启动中...配置文件: /etc/xxx.conf运行模式: normal服务启动成功2019年 02月 18日 星期一 19:13:00 CST: 处理一个请求# ./binTest -vf test.conf -m master服务启动中...配置文件: 'test.conf'运行模式: 'master'服务启动成功2019年 02月 18日 星期一 19:14:22 CST: 处理一个请求# ./binTest -dvf test.conf -m master服务启动中...配置文件: 'test.conf'运行模式: 'master'服务启动成功进程ID: 15230 还可以使用-l指定长选项12# getopt -l nitaoge: -l practise dvf: -dvf test.conf --nitaoge test --practise -d -v -f 'test.conf' --nitaoge 'test' --practise -- getopts optstring namegetopts的optstring与getopt的optstring类似，不同的是，如果忽略错误提示，就在前面加个冒号，而不是-q。 getopts每次执行时，将下一个选项放在变量name中，如果name不存在就初始化它；当遇到没有在optstring中声明的选项时，name会被设置为?。 getopts命令会用到两个环境变量。变量OPTARG存放每次访问选项的参数，变量OPTIND存放每次访问的下一个选项索引，所以不需要shift掉选项。 每次shell脚本被执行的时候OPTIND被初始化为1。在同一shell中不会自动重置OPTIND，如果要使用新的参数集合而需要多次调用getopts时，必须使用OPTIND=1手动重置它。 上面的例子可以改成这样：1234567891011121314151617181920212223242526#!/bin/bashproc_daemon=0exec_show=0config_path=/etc/xxx.confexec_mode=normal# optionswhile getopts :hvdf:m: opt;do case "$opt" in h) echo -e " -f 指定配置文件\n -m 指定运行模式\n -h 帮助\n -v 显示执行过程\n -d 后台运行" exit 0 ;; f) config_path=$OPTARG ;; m) exec_mode=$OPTARG ;; d) proc_daemon=1 ;; v) exec_show=1 ;; esacdone 获取用户输入使用read，可以指定变量123456#!/bin/bashread -p "enter:" str1 str1# ./nonTestenter: abc defabc def 也可以不指定，默认都放在变量REPLY中1234567#!/bin/bashread -p "enter:"echo "$REPLY"# ./nonTestenter: a b c a b c 可以通过-t设置超时秒数1read -t 5 -p "enter:" 可以通过-s隐藏输入1read -s 5 -p "enter:" 可以以行模式读文件123456#!/bin/bashcount=1cat testfile | while read line; do echo "Line $count: $line" count=$[ $count + 1]done 也可以读用户输入并输出到文件1234567#!/bin/bashexec 1&gt; testfile #配合exec使用，表示全局重定向count=1while read -p "enter: " line; do echo "Line #$count: $line" count=$[ $count + 1 ]done tee 将标准输入同时输出到控制台和文件tee [选项]… [文件]…12-a, --append 内容追加到给定的文件而非覆盖-i, --ignore-interrupts 忽略中断信号 配合管道使用12345# date | tee -a testfile2# date | tee -a testfile2# cat testfile22019年 02月 19日 星期二 10:14:09 CST2019年 02月 19日 星期二 10:14:11 CST 流程控制每行代码后可省略分号; 但如果想在一行执行多条语句，需要使用分号;分割。 表达式(( expression )) 可以用来实现任意数学表达式，包括：++、–、自增自减** 幂运算! 逻辑取反&amp;&amp; 逻辑与|| 逻辑或~ 按位取反&lt;&lt; 左位移>> 右位移&amp; 位与| 位或 比如12345678910111213141516171819#!/bin/basha=1echo "a:"$a((a++))echo "a++:"$a# ./nonTesta:1a++:2#!/bin/bashtag=0echo $tagecho $((!tag))# ./nonTest01 if 条件判断判断首先要知道test命令，最开始posix shell的标准是这么写的，123if test expression;then ... fi 后来加入[]，其实[]就是test的同义词。1234567891011121314151617181920212223242526# help [[: [ 参数... ] 估值条件表达式。 是内嵌命令 "test" 的同义词，但是最后一个参数必须是 字符 `]'，以匹配起始的 `['。[[ ... ]]: [[ 表达式 ]] 执行条件命令。 根据条件表达式 EXPRESSION 的估值返回状态0或1。表达式按照 `test' 内嵌的相同条件组成，或者可以有下列操作符连接而成： ( EXPRESSION ) 返回 EXPRESSION 表达式的值 ! EXPRESSION 如果 EXPRESSION表达式为假则为真，否则为假 EXPR1 &amp;&amp; EXPR2 如果 EXPR1 和 EXPR2 表达式均为真则为真，否则为假 EXPR1 || EXPR2 如果 EXPR1 和 EXPR2 表达式中有一个为真则为真，否则为假 当使用 `==' 和 `!=' 操作符时，操作符右边的字符串被用作模式并且执行一个 匹配。当使用 `=~' 操作符时，操作符右边的字符串被当作正则表达式来进行 匹配。 操作符 &amp;&amp; 和 || 将不对 EXPR2 表达式进行估值，如果 EXPR1 表达式足够确定 整个表达式的值。 退出状态： 根据 EXPRESSION 的值为0或1。 在使用[]过程中，有些语义与运算结果比较模糊，比如每个字符串变量都要加””、不支持正则等，不推荐使用。bash提供双方括号[[]]支持更强大的高级特性，所以我这里使用双括号实现。 判断语句格式如下，注意两边都有空格：1234567if [[ expression ]]; then ...elif [[ expression ]]; then ...else ...fi 当然也可以嵌套：123456789if [[ expression ]]; then if [[ expression ]]; then ... fielif [[ expression ]]; then ...else ...fi 也可以使用复合条件：1234567if [[ expression1 &amp;&amp; expression2 ]]; then ...elif [[ expression1 || expression2 ]]; then ...else ...fi 整数比较运算符：a -eq b ab是否相等a -ne b ab是否不相等a -ge b a是否大于等于ba -gt b a是否大于ba -le b a是否小于等于ba -lt b a是否小于b 1234567891011121314151617181920#!/bin/basha=$1b=$2if [[ $a -gt $b ]];then echo "大于"elif [[ $a -eq $b ]];then echo "等于"elif [[ $a -lt $b ]];then echo "小于"else echo "不知道了"fi# ./intCompare 1 1等于# ./intCompare 1 2小于# ./intCompare 2 1大于 字符串比较运算符：a = b ab是否相同a != b ab是否不同a &lt; b a是否小于ba &gt; b a是否大于b，不支持&lt;=和&gt;=，字符串比较大小也不常用-n str 判断字符串长度是否非0-z str 判断字符串长度是否为01234567891011121314151617181920212223242526272829303132333435363738394041424344#!/bin/basha=$1b=$2if [[ $a = $b ]]; then echo "相同"elif [[ $a != $b ]]; then echo "不同"fi# ./strCompare a a相同# ./strCompare a b不同#!/bin/basha=$1b=$2if [[ $a \&lt; $b ]]; then echo "a小于b"elif [[ $a \&gt; $b ]]; then echo "a大于b"fi# ./strCompare xxx yyya小于b# ./strCompare yyy xxxa大于b#!/bin/basha=$1if [[ -n $a ]]; then echo "a不是空串"elif [[ -z $a ]]; then echo "a是空串"fi# ./strComparea是空串# ./strCompare ""a是空串# ./strCompare xxxxa不是空串 文件比较运算符：-d 目录是否存在-f 文件是否存在-e 是否存在，不区分是目录还是文件-r 文件是否存在并可读-w 文件是否存在并可写-x 文件是否存在并可执行-s 文件是否存在并非空-O 文件是否存在并属于当前用户-G 文件是否存在并属于当前用户所在组file1 -nt file2 file1是否比file2新file1 -ot file2 file1是否比file2旧1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/bin/basha=$1if [[ -r $a ]];then echo "$a 文件可读"else echo "$a 文件不可读"fiif [[ -w $a ]];then echo "$a 文件可写"else echo "$a 文件不可写"fiif [[ -x $a ]];then echo "$a 文件可执行"else echo "$a 文件不可执行"fiif [[ -s $a ]];then echo "$a 文件非空"else echo "$a 空文件"fi---------- 1 root root 0 2月 18 11:47 testfileroot用户有无上权限，所以可读写# ./fileOpt testfiletestfile 文件可读testfile 文件可写testfile 文件不可执行testfile 空文件换普通用户$ ./fileOpt testfiletestfile 文件不可读testfile 文件不可写testfile 文件不可执行testfile 空文件-rw-r--r-- 1 root root 2 2月 18 11:48 testfile2$ ./fileOpt testfile2testfile2 文件可读testfile2 文件不可写testfile2 文件不可执行testfile2 文件非空#!/bin/basha=$1if [[ -O $a ]];then echo "$a 文件属于当前用户"else echo "$a 文件不属于当前用户"fiif [[ -G $a ]];then echo "$a 文件属于当前用户所在组"else echo "$a 文件不属于当前用户所在组"fi# ./fileOpt testfiletestfile 文件属于当前用户testfile 文件属于当前用户所在组$ ./fileOpt testfiletestfile 文件不属于当前用户testfile 文件不属于当前用户所在组 case 分支判断跟java中的switch类似，比如服务管理脚本可以这么写：1234567891011121314151617#!/bin/basha=$1case $a instart) echo "srv start";;stop) echo "srv stop";;*) echo "unsupport cmd";;esac# ./srvTestunsupport cmd[root@vhosttest shell]# ./srvTest startsrv start[root@vhosttest shell]# ./srvTest stopsrv stop for 循环默认shell脚本中的写法，123456for i in 1 2 3 4 5;do或for i in &#123;1..5&#125;;doecho "now, i is: $i"doneecho "finally, i is: $i" 也支持c语言中的写法，但要用(())表达式形式括起来，1234for ((i=1; i&lt;=5; i++));doecho "now, i is: $i"doneecho "finally, i is: $i" 执行到最后变量i是最后处理过的值，结果：123456789101112131415# ./nonTestnow, i is: 0now, i is: 1now, i is: 2now, i is: 3now, i is: 4now, i is: 5finally, i is: 5now, i is: 1now, i is: 2now, i is: 3now, i is: 4now, i is: 5finally, i is: 6 while 循环格式如下：1234567891011121314i=1while [[ $i -le 5 ]]; doecho "now, i is: $i"((i++))doneecho "finally, i is: $i"# ./whileTestnow, i is: 1now, i is: 2now, i is: 3now, i is: 4now, i is: 5finally, i is: 6 until 循环until命令和while命令工作的方式完全相反。until命令要求你指定一个通常返回非零退出状态码的测试命令。只有测试命令的退出状态码不为0，bash shell才会执行循环中列出的命令。 一旦测试命令返回了退出状态码0，循环就结束了。 12345678910111213i=1until [[ $i -eq 5 ]]; doecho "now, i is: $i"((i++))doneecho "finally, i is: $i"# ./untilTestnow, i is: 1now, i is: 2now, i is: 3now, i is: 4finally, i is: 5 select 选择循环可以用于让用户选择的处理逻辑，比如：123456789101112131415161718192021#!/bin/bashecho "enter your select:"select s in "install Linux" "test Linux" reboot shutdown quit;do if [[ $s == "quit" ]];then exit 0; fi echo $sdone# ./nonTestenter your select:1) install Linux 3) reboot 5) quit2) test Linux 4) shutdown#? 1install Linux#? 2test Linux#? 3reboot#? 4shutdown#? 5 break/continue 退出/继续循环break 默认跳出当前循环代码块break n 可以跳出n层循环，当前循环代码块层级是1 continue 默认继续执行当前循环代码块continue n 可以继续执行n层循环，当前循环代码块层级是1 控制脚本Linux 信号之前在琢磨kill的时候就说过信号，对进程的信号控制常用的就这些：123456781 SIGHUP 挂起进程2 SIGINT 终止进程（同 Ctrl + C）3 SIGQUIT 退出进程（同 Ctrl + \）9 SIGKILL 无条件终止进程15 SIGTERM 尽可能终止进程17 SIGSTOP 无条件停止进程18 SIGTSTP 停止或暂停进程（同 Ctrl + Z）19 SIGCONT 继续运行停止的进程（与SIGTSTP相反， fg/bg命令） 终止进程按Ctrl+C会向进程发送SIGINT信号，可终止前台进程。使用kill发送终止信号，也可以终止指定进程。 暂停进程/恢复进程按Ctrl+Z会向进程发送SIGTSTP信号，使进程暂停。 使用jobs查看当前终端正在运行的进程123456789-l 列出进程的PID以及作业号-n 只列出上次shell发出的通知后改变了状态的作业-r 只列出运行中的作业-s 只列出已停止的作业# jobs -l[1] 19007 停止 ./signTest[2]- 19017 停止 ./signTest[3]+ 19020 停止 ./signTest 我这里运行了三个signTest进程并使其暂停，[]中的数字是job number，19007是pid，+是当前正在运行或准备运行的进程，-是下一个准备运行的进程，./signTest是进程执行命令。 可以通过bg命令使进程在后台恢复执行，也可以通过fg命令使进程在前台恢复执行。12345678910# bg 2[2]+ ./signTest &amp;345# fg 3./signTest34 捕获信号捕获：trap commands signals移除捕获：trap – signals123456789101112131415161718192021222324252627282930313233343536373839404142#!/bin/bashtrap "echo 'forbidden operation.'" SIGINTtrap "echo 'interrupt failed.'" SIGTERMtrap "echo 'killed by otherone.'" SIGKILLtrap "echo 'process exit.'" EXITcount=1while [[ $count -le 100 ]];doecho "$count"((count++))sleep 1if [[ $count -ge 10 ]];then trap -- SIGINTfidone# ./signTest1^Cforbidden operation.2^Cforbidden operation.3interrupt failed.45678910^Cprocess exit.在这个过程中如果使用kill -9强制关闭，则进程直接终止。并且trap无法捕捉SIGKILL信号。term2# ps -ef | grep signroot 18902 18329 0 11:30 pts/4 00:00:00 /bin/bash ./signTestroot 18908 4435 0 11:30 pts/0 00:00:00 grep --color=auto signterm2#term1# ./signTest1234已杀死 后台模式运行命令结尾加&amp;可以使命令、脚本或进程在后台运行，但输出到控制台的内容仍然显示在当前终端。可以配合nohup command &amp;使输出重定向到默认的nohup.out或自己指定的文件当中。12# nohup ./signTest &amp;&gt;/dev/null &amp;[1] 18431 []中的数字是job number，19007是pid，可以通过ps查看进程状态，通过kill控制进程状态 函数创建函数 &amp; 调用函数可以使用function name{}或name(){}创建函数，调用函数和获得实参与使用shell的方式相同。函数创建必须写在调用前，否则报错。 使用$?获取上次执行命令的退出状态码，也可以用于获取函数的退出状态码。函数执行过程中如果发生错误，则退出状态码为1，正常默认退出状态码为0。 将函数赋给变量时，赋的值是函数标准输出的内容。 1234567891011121314#!/bin/bashfun1()&#123; echo $1 echo $2 return 123&#125;p=`fun1 $1 $2`echo "return: $?"echo "result: $p"# ./funTest hello worldreturn: 123result: helloworld 全局变量 &amp; 局部变量默认情况下定义的变量，都是全局变量，无论在脚本中还是函数中对其赋值更改，都会影响变量。12345678910111213141516#!/bin/bashfun1()&#123; i=33 echo "in i: $i"&#125;i=1echo "i: $i"fun1echo "return: $?"echo "i2: $i"# ./funTesti: 1in i: 33return: 0i2: 33 可以使用local在函数中修饰局部变量，避免逻辑混乱。12345678910111213141516#!/bin/bashfun1()&#123; local i=33 echo "in i: $i"&#125;i=1echo "i: $i"fun1echo "return: $?"echo "i2: $i"# ./funTesti: 1in i: 33return: 0i2: 1 数组传参 &amp; 返回数组将数组传入函数，其实就是将数组铺开，将数组每个元素依次传入函数。使用\$myArr访问数组只会获得数组第一个元素，获取数组所有元素可以使用\${myArr[*]}来访问，*或@都可以。在函数中获取参数并赋给临时数组，即可实现数组传参。 再将临时数组输出到标准输出，即可返回数组。 下面代码实现对数组每个元素+112345678910111213141516171819#!/bin/bashtransArrPlusOne()&#123; local tmpArr=($@) local arrSize=$# local i=0 while [ $i -lt $arrSize ]; do ((tmpArr[$i]++)) ((i++)) done echo $&#123;tmpArr[*]&#125;&#125;myArr=(1 2 3 4 5)myArrResult=`transArrPlusOne $&#123;myArr[*]&#125;`echo "result is :$&#123;myArrResult[*]&#125;"# ./arrTestresult is :2 3 4 5 6 函数递归举个计算阶乘的例子n! = n*(n-1)*(n-2)*…*2*1提取通项公式n! = n*(n-1)!代码表示如下：1234567891011121314151617#!/bin/bashcalc()&#123; if [ $1 -eq 1 ];then echo 1 else local temp=$[ $1 - 1 ] local result=$(calc $temp) echo $[ $result * $1 ] fi&#125;result=$(calc $1)echo "The result is: $result"# ./funTest 5The result is: 120# ./funTest 3The result is: 6 引入函数库在当前脚本引入其他脚本，可以使用source命令，也可使用.来替代source命令。1234567891011121314151617181920212223242526272829#!/bin/bashfun1()&#123; echo "fun1-your enter: $1 $2"&#125;fun2()&#123; echo "fun2-your enter: $1 $2"&#125;fun3()&#123; echo "fun3-your enter: $1 $2"&#125;echo "funLib."#!/bin/bash. ./funLibfun1 hi afun2 hi bfun3 hi cecho "over."# ./funTestfunLib.fun1-your enter: hi afun2-your enter: hi bfun3-your enter: hi cover. 脚本调试在写shell脚本时，难免遗漏误写，没有IDE还不容易找到问题所在，为此bash提供了调试选项，可以输出错误提示。 bash [选项] 脚本 参数…123-n 只检查语法，不执行脚本-v 打印shell脚本所有语句，包括引入的脚本库-x 追踪模式，显示所有执行步骤 还可以通过set -x和set +x调试部分代码。123456789101112131415161718192021222324252627282930#!/bin/bash. ./libFuncalc()&#123; if [ $1 -eq 1 ];then echo 1 else local temp=$[ $1 - 1 ] local result=$(calc $temp) echo $[ $result * $1 ] fi&#125;set -xresult=$(calc $1)set +xecho "The result is: $result"# ./funTest 2funLib.++ calc 2++ '[' 2 -eq 1 ']'++ local temp=1+++ calc 1+++ '[' 1 -eq 1 ']'+++ echo 1++ local result=1++ echo 2+ result=2+ set +xThe result is: 2 总结Shell中括号的区别 \$()和 是用来做命令替换的，可以在命令行或脚本中使用命令。 \${}是用来做变量替换的，\$var和${var}都可以使用变量。 \$[] \$(()) 用来做数学运算，返回运算结果。支持+ - * / %。bash只支持整数运算，浮点数运算需要借助bc或awk实现。 []相当于test命令，用来做判断。括号中两边要有空格，使用字符串比较要用””引用，大于号和小于号需要用\转义。 (())和[[]]是对[]的数学表达式和字符串表达式的扩展。(())可以支持自增自减，逻辑运算，位运算。[[]]可以不用””引用，支持正则匹配。 env和set到底是什么env 用来显示环境变量export 用来显示和设置环境变量set 用来显示和设置本地变量 env（查看环境变量）env [选项] [命令]1234567891011121314-i 不带环境变量执行命令-u 从环境变量中删除一个变量执行命令# env | grep aaaaaa=1# env -i bash# envLS_COLORS=PWD=/disk1/practise/shellLANG=zh_CN.UTF-8SHLVL=1LESSOPEN=||/usr/bin/lesspipe.sh %s_=/usr/bin/env set（设置shell属性）set [选项]… [参数]… 不带选项时，shell变量或函数将以当前语言环境进行排序后显示。指定选项时，设置或重置shell属性。-选项表示设置，+选项表示重置。处理完选项之后剩余的任何参数都被作为位置参数的值被赋值，可以通过\$n获取。 123456789101112131415161718-o 显示所有选项的开启或关闭状态-a 遇到变量赋值操作，设置成当前环境的环境变量赋值操作-v 在读取输入时立即打印出来-f 禁用文件名通配符-u 如果有未定义变量，则立即退出并报错-e 如果有命令执行失败，则立即退出-t 只读取并执行一个命令之后立即退出-p shell不再读取.profile文件和env文件，shell函数也不继承任何环境-m 启用作业控制，它在交互shell中是默认启用的-b 后台作业结束时立即报告状态，而不是在下次显示主提示符前报告。只有在启用作业控制时才有效-n 检查语法是否错误，不执行命令-h hash命令所在位置，默认启用-x 启用追踪模式，显示详细执行过程-H 启用可以使用!执行history历史命令的操作，默认命令行模式是启用的-P 如果使用的路径是链接路径，直接使用实际路径-B 启用shell执行花括号扩展，默认启用-C 如果设置的话，bash使用重定向操作符&gt;, &gt;&amp;, &lt;&gt;时，不会覆盖已存在的文件。可以使用重定向操作符&gt;|代替&gt;来创建输出文件，从而绕过这个限制-- 不设置任何选项，直接设置传参]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>看破Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Linux 3.sed和gawk]]></title>
    <url>%2Fp%2F4e1d4d44%2F</url>
    <content type="text"><![CDATA[概念sed（stream editor） 流编辑器。它每次读一行数据，根据预先指定的规则，对文本进行数据流编辑，将结果输出到标准输出。也就是说它的所作所为都可以看成对文本行的操作，继而批量对所有文本行操作。 gawk它是awk的GNU版，添加了更多的功能扩展。CentOS7中默认安装了gawk。awk是一个格式化程序脚本，可以定义变量、使用数学运算、结构化编程，输出格式化文本。 正则表达式Linux中的正则分为BRE标准和ERE标准：POSIX基础正则表达式(basic regular expression，BRE)引擎POSIX扩展正则表达式(extended regular expression，ERE)引擎 为了兼容POSIX标准，默认sed和awk不支持扩展正则，可通过选项指定支持扩展正则。 表示正则表达式的特殊符号包括.*[]^${}+?|()如果想要用这些特殊符号或其他系统标识符进行字符匹配，必须使用\进行转义。 BRE^ 匹配行首12# echo -e "Apple store\nBook store" | sed -n '/^A/p'Apple store $ 匹配行尾12# echo -e "Apple store\nBook store\nApple Factory" | sed -n '/y$/p'Apple Factory 同时匹配行首行尾12# echo -e "Apple store\nBook store\nApple Factory\nPaper Factory" | sed -n '/^P/,/y$/p'Paper Factory . 匹配任意单字符123# echo -e "Apple store\nBook store\nApple Factory\nPaper Factory" | sed -n '/Factor./p'Apple FactoryPaper Factory [] 范围匹配[]中指定的任意单字符都将被匹配，还可以用-指定区间。为了方便查看，我直接将原始文本放入文件。123456789101112131415161718192021# cat strlistApple store1Apple store2Book store1Book store2Apple Factory1Apple Factory2Paper Factory1Paper Factory2# sed -n '/[PB]/p' strlistBook store1Book store2Paper Factory1Paper Factory2# sed -n '/[a-z][0-1]/p' strlistApple store1Book store1Apple Factory1Paper Factory1 BRE提供的特殊字符范围123456789[[:alpha:]] 匹配任意字母字符，不管是大写还是小写[[:alnum:]] 匹配任意字母数字字符0~9、A~Z或a~z[[:blank:]] 匹配空格或制表符[[:digit:]] 匹配0~9之间的数字[[:lower:]] 匹配小写字母字符a~z[[:print:]] 匹配任意可打印字符[[:punct:]] 匹配标点符号[[:space:]] 匹配任意空白字符:空格、制表符、NL、FF、VT和CR[[:upper:]] 匹配任意大写字母字符A~Z 排除范围内匹配，在[]中开头加^下面例子表示中间出现任何l或m字符都匹配不到12345678# echo "heo" | sed -nr '/he[^lm]*o/p'heo# echo "helo" | sed -nr '/he[^lm]*o/p'# echo "helmo" | sed -nr '/he[^lm]*o/p'# echo "hemo" | sed -nr '/he[^lm]*o/p'# echo "hemlo" | sed -nr '/he[^lm]*o/p'# echo "hedo" | sed -nr '/he[^lm]*o/p'hedo * 出现次数匹配（0次或多次）123456# echo "heo" | sed -n '/hel*o/p'heo# echo "helo" | sed -n '/hel*o/p'helo# echo "hellllllo" | sed -n '/hel*o/p'hellllllo 配合.实现匹配所有字符12# echo "hebsdfgsdbdbo" | sed -n '/he.*o/p'hebsdfgsdbdbo 配合[]实现范围内任意字符出现任意次数的匹配12345678910111213141516# echo "bt" | sed -n '/b[ae]*t/p'bt# echo "bat" | sed -n '/b[ae]*t/p'bat# echo "bet" | sed -n '/b[ae]*t/p'bet# echo "btt" | sed -n '/b[ae]*t/p'btt# echo "baat" | sed -n '/b[ae]*t/p'baat# echo "baaeeet" | sed -n '/b[ae]*t/p'baaeeet# echo "baeeaeeat" | sed -n '/b[ae]*t/p'baeeaeeat# echo "baakeeet" | sed -n '/b[ae]*t/p'# EREsed -r 支持扩展正则 ? 出现次数匹配（0次或1次）123456# echo "heo" | sed -nr '/hel?o/p'heo# echo "helo" | sed -nr '/hel?o/p'helo# echo "hello" | sed -nr '/hel?o/p'# 同理，可以配合.使用可以配合[]使用 + 出现次数匹配（1次或多次）1234567# echo "heo" | sed -nr '/hel+o/p'# echo "helo" | sed -nr '/hel+o/p'helo# echo "hello" | sed -nr '/hel+o/p'hello# echo "helllo" | sed -nr '/hel+o/p'helllo 同理，可以配合.使用可以配合[]使用 {} 指定出现次数{n} 表示准确出现n次{m,n} 表示至少出现m次，最多出现n次 12345echo "helo" | sed -nr '/hel&#123;2&#125;o/p'# echo "hello" | sed -nr '/hel&#123;2&#125;o/p'hello# echo "helllo" | sed -nr '/hel&#123;2&#125;o/p'# 123456789# echo "hello" | sed -nr '/hel&#123;3,5&#125;o/p'# echo "helllo" | sed -nr '/hel&#123;3,5&#125;o/p'helllo# echo "hellllo" | sed -nr '/hel&#123;3,5&#125;o/p'hellllo# echo "helllllo" | sed -nr '/hel&#123;3,5&#125;o/p'helllllo# echo "hellllllo" | sed -nr '/hel&#123;3,5&#125;o/p'# | 或匹配1234# echo "hello" | sed -nr '/hl&#123;3&#125;o/p'# echo "hello" | sed -nr '/he&#123;3&#125;o/p'# echo "hello" | sed -nr '/h(e|l)&#123;3&#125;o/p'hello () 表达式分组在|一节可以看出，(e|l)视为一个最小单位匹配。()可以将任何一个长正则表达式，分成多个小单元进行匹配。 实例手机号匹配手机号目前运营商放出的号段一般都是1开头，紧接3-9，然后是9位的任意数字，所以正则模板可以写成1[3-9]{1}[0-9]{9}。如下例子替换手机号为*12345678# echo "My phone number: 23812345678d" | sed -r 's/1[3-9]&#123;1&#125;[0-9]&#123;9&#125;/***/g'My phone number: 23812345678d# echo "My phone number: 1381234567" | sed -r 's/1[3-9]&#123;1&#125;[0-9]&#123;9&#125;/***/g'My phone number: 1381234567# echo "My phone number: 138123456788" | sed -r 's/1[3-9]&#123;1&#125;[0-9]&#123;9&#125;/***/g'My phone number: ***8# echo "My phone number: 13812345678asdfasdf" | sed -r 's/1[3-9]&#123;1&#125;[0-9]&#123;9&#125;/***/g'My phone number: ***asdfasdf 再试试grep12# echo "My Phone Number:1381234567813dg15dasgsd" | grep -E '1[3-9]&#123;1&#125;[0-9]&#123;9&#125;'My Phone Number:1381234567813dg15dasgsd 身份证号匹配二代身份证号是18位，最后一位还有可能是X，所以正则模板可以写成[0-9]{17}([0-9]|X){1}。123456789# echo "My idt number: 230123456781234567" | grep -E "[0-9]&#123;17&#125;([0-9]|X)&#123;1&#125;"My idt number: 230123456781234567# echo "My idt number: 23012345678123456X" | grep -E "[0-9]&#123;17&#125;([0-9]|X)&#123;1&#125;"My idt number: 23012345678123456X# echo "My idt number: 23012345678123456Xddd" | grep -E "[0-9]&#123;17&#125;([0-9]|X)&#123;1&#125;"My idt number: 23012345678123456Xddd# echo "My idt number: 23012345678123456" | grep -E "[0-9]&#123;17&#125;([0-9]|X)&#123;1&#125;"# echo "My idt number: d23012345678123456X" | grep -E "[0-9]&#123;17&#125;([0-9]|X)&#123;1&#125;"My idt number: d23012345678123456X 邮箱匹配一般国内邮箱的命名规则: name@domainname最长24，域名长度一般2-6个name可以使用字母大小写、数字、下划线、破折号、英文句号，并且只能以字母开头 所以正则模板可以写成^[a-zA-Z]{1}([0-9a-zA-Z\_\.]|\-){0,23}@([0-9a-z]+\.){1,5}[0-9a-z]+。1234567891011121314151617181920212223# cat emailsnitaogetech@gmail.comnitaoge.com@gmail.comnitaoge_tech@nitaoge.comnitaoge-tech@nitaoge.com.cn.abc.vipnitaoge@abcd.abcdnitaoge666@abcd.abcdnitaoge@tech@gmail.comnitaoge#tech@gmail.com_nitaoge@gmail.com3nitaoge@gmail.comnitaoge@gmailnitaoge@gmail.nitaoge@gmail.c# cat emails | grep -E "^[a-zA-Z]&#123;1&#125;([0-9a-zA-Z\_\.]|\-)&#123;0,23&#125;@([0-9a-z]+\.)&#123;1,5&#125;[0-9a-z]+"nitaogetech@gmail.comnitaoge.com@gmail.comnitaoge_tech@nitaoge.comnitaoge-tech@nitaoge.com.cn.abc.vipnitaoge@abcd.abcdnitaoge666@abcd.abcdnitaoge@gmail.c sedsed [选项]… 命令脚本 文件12345678910-n 仅显示匹配文本-e 在命令行中指定规则-f 指定规则脚本-r 允许使用扩展正则-i[SUFFIX] 修改文件（如果提供SUFFIX，则进行备份）-c 使用-i修改文件时使用copy而不是rename-l N 配合`l'命令指定每行长度-z 用NULL字符换行-u 从输入文件加载最少量的数据并更频繁地刷新输出缓冲区-s 将文件视为单独的而不是单个连续的长流。 行地址[line]command[line]{command1;command2;…;} 在命令操作符前加数字可以指定文本的行地址进行匹配，$表示最后一行1234567891011指定替换文本的第10行sed '10s/pattern/replacement/flags' input-file指定替换文本的第10行到第100行sed '10,100s/pattern/replacement/flags' input-file指定替换文本的第10行到最后一行sed '10,$s/pattern/replacement/flags' input-file指定替换文本的第1行到第9行，和第101行到最后一行，也就是行范围取补集sed '10,100!s/pattern/replacement/flags' input-file 还支持在命令组合前指定行数1sed '10,$&#123;s/pattern1/replacement1/flags; s/pattern2/replacement2/flags;&#125;' input-file 行匹配[pattern]command[pattern]{command1;command2;…;} 先查找匹配pattern1的文本行，然后再进行pattern2匹配文本替换1sed '/pattern1/s/pattern2/replacement/flags' input-file 命令脚本中的命令操作符s 替换行sed ‘[line]|[pattern]s/pattern/replacement/flags’ input-file 其中/如果遇到路径/usr/local这种格式，可以替换为其他字符，只要前后保持一致即可。123sed 's:pattern:replacement:flags' input-filesed 's!pattern!replacement!flags' input-filesed 's@pattern@replacement@flags' input-file flags 替换标记： 数字 替换行内第N处匹配文本g 替换行内所有匹配文本p 显示替换后的文本w output-file，将替换后的文本保存到output-file &amp; 替换变量可以使用&amp;引用匹配结果12# echo "The cat sleeps in his hat." | sed 's/.at/"&amp;"/g'The "cat" sleeps in his "hat". d 删除行sed ‘[line]|[pattern]d’ input-file i 行前插入 &amp; a 行后追加sed ‘[line]|[pattern]i\New Line Text’ input-filesed ‘[line]|[pattern]a\New Line Text’ input-file 12345678# echo "Test Line 2" | sed 'i\Test Line 1' Test Line 1Test Line 2# echo "Test Line 2" | sed 'a\Test Line 1' Test Line 2Test Line 1 c 修改行sed ‘[line]|[pattern]c\New Line Text’ input-file y 字符转换sed ‘[line]|[pattern]y/abc/ABC’ input-file p 打印输出需要配合sed -n选项输出指定行。sed ‘[line]|[pattern]p’ input-file = 打印行号sed ‘[line]|[pattern]=’ input-file l 打印特殊文本（转为ASCII码）sed ‘[line]|[pattern]l’ input-file w 写入文件sed ‘[line]|[pattern]w output-file’ input-file r 读取文件会读input-file2的文本，追加到input-file1匹配行后，输出sed ‘[line]|[pattern]r input-file2’ input-file1 n 将下一文本行移动到sed编辑器的缓冲区比如删除匹配行的下一行12345678# cat profileexport PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROLexport JAVA_HOME=/disk1/lib/jdk1.8.0_201export PATH=$PATH:$JAVA_HOME/bin# sed '/USER/&#123;n; d&#125;' profileexport PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROLexport PATH=$PATH:$JAVA_HOME/bin N 将下一文本行添加到缓冲区中已有的文本后在sed编辑器中将两行当做一行处理，并替换换行符为空格。12345678# cat profileexport PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROLexport JAVA_HOME=/disk1/lib/jdk1.8.0_201export PATH=$PATH:$JAVA_HOME/bin# sed '/USER/&#123;N; s/\n/ /g &#125;' profileexport PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL export JAVA_HOME=/disk1/lib/jdk1.8.0_201export PATH=$PATH:$JAVA_HOME/bin 将分为两行的词组合并后替换。1234567891011# cat datafileOn Tuesday, the Linux SystemAdministrator's group meeting will be held.All System Administrators should attend.Thank you for your attendance.# sed 'N; s/System\nAdministrator/Desktop\nUser/' datafileOn Tuesday, the Linux DesktopUser's group meeting will be held.All Desktop Users should attend.Thank you for your attendance. 可以看出N的作用，就是依次将下一文本行添加到缓冲区中已有的文本后123456# sed -n 'N; s/\n/ /p' bOn Tuesday, the Linux System Administrator's group meeting will be held.All System Administrators should attend. Thank you for your attendance.# sed -n 'N; s/\n/ /p' b | sed -n 'N; s/\n/ /p'On Tuesday, the Linux System Administrator's group meeting will be held. All System Administrators should attend. Thank you for your attendance. 但如果最后一行下面没有文本行了，就没法添加到缓冲区，对最后一行的操作会失效。 D 删除缓冲区中的第一行只删除缓冲区中的第一行。该命令会删除到换行符(含换行符)为止的所有字符。12# sed 'N; /System\nAdministrator/D' datafileAdministrator's group meeting will be held. All System Administrators should attend. P 只打印缓冲区中的第一行只打印多行缓冲区中的第一行。包括缓冲区中直到换行符为止的所有字符。12# sed -n 'N ; /System\nAdministrator/P' data3.txtOn Tuesday, the Linux System ### gawkgawk [选项]… 脚本命令 文件123456789-e 在命令行指定脚本命令-f scripfile 从脚本文件中读取脚本命令-F fs fs指定输入分隔符，fs可以是字符串或正则表达式。-v var=value 在程序开始执行之前，将值val分配给变量var。这些变量值可用于AWK程序的BEGIN块。-r 允许使用扩展正则-b 将所有输入数据视为单字节字符-c 兼容模式下运行，兼容unix awk-P 打开POSIX兼容模式-d[file] 将全局变量，类型和最终值的排序后列表打印到文件。 如果没有提供文件，gawk会在当前使用名为awkvars.out的文件到当前工作目录]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>看破Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Linux 2.系统目录结构]]></title>
    <url>%2Fp%2F3474802a%2F</url>
    <content type="text"><![CDATA[/etc 存放系统服务的配置文件password 用户的库文件，保存用户的用户名、UID、GID、用户说明、工作目录、访问方式shadow 用户密码的库文件，保存用户加密后的密码group 用户组的库文件，保存用户组的组名、GID和组内成员fstab 系统启动挂载分区列表hosts 本地域名映射表resolv.conf DNS配置表systemd/system/ 系统启动服务脚本目录crontab 系统级定时任务rsyslog.conf 系统日志配置文件profile 全局环境变量配置文件 /usr 存放应用的可执行程序、源码和一些函数库lib/ 函数库目录src/ 源代码目录local/ 本地安装应用目录bin/ 可执行程序目录sbin/ 系统管理员可执行程序目录include/ C语言头文件目录share/ 应用共享数据目录，一般放用户手册 /var 存放系统内经常变动的文件log/ 系统及应用日志目录lib/ 系统及应用运行时可变的依赖库目录spool/ 定时任务、系统邮件等输入输出队列目录tmp/ 存放相比/tmp存活时间更长、体积更大的临时文件目录lock/ 设备或应用占用锁目录cache/ 应用缓存目录local/ 存放/usr/local中应用的可变数据目录account/run/ 存放进程ID文件目录，重启系统清空crash/ 系统崩溃时转储的文件目录，可以通过这些文件分析宕机原因 /dev 存放设备文件fd 软盘audio 声卡hd IDE设备，如光驱cdrom 光驱，链接到某个hdsd SCSI设备，如SATA盘、SAS盘、U盘md raid设备ram 系统内存tty 伪终端ttyS 串口lp* 并口console 控制台random 随机数设备null 黑洞zero 零数据资源 /proc 内存映射虚拟目录version 内核版本信息cpuinfo cpu详细信息meminfo 内存详细信息filesystems 系统支持的文件系统类型devices 当前运行内核所配置的所有设备net 网络使用协议及状态信息dma 当前使用的dma通道ioports 当前使用的IO端口modules 当前系统加载的内核模块信息uptime 系统总的启动时间和空闲时间，单位秒loadavg 系统平均负载kmsg 内核输出信息initerrupts 当前使用和曾经有多少个中断 其他目录/boot 系统引导文件目录/home 用户家目录/root root用户主目录/tmp 临时文件目录/bin、/sbin、/lib、/lib64分别软链接到/usr下的/bin、/sbin、/lib、/lib64]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>看破Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破CentOS 3.搭建DNS服务器]]></title>
    <url>%2Fp%2F10622d9b%2F</url>
    <content type="text"><![CDATA[背景在家搞了两台PC，虚了10+台机器来玩，如果用本地域名解析(/etc/hosts)那就太麻烦了，干脆搞个DNS服务器，所有机器添加DNS地址，增删解析记录只改一次就行了。 准备关闭防火墙关闭Selinux 安装安装bind相关软件1# yum -y install bind* 启动服务123# systemctl start named.service --启动DNS服务# systemctl enable named.service --设置为开机启动# netstat -anlp | grep named --查看监听端口为53 named默认监听TCP、UDP协议的53端口，以及TCP的953端口：其中UDP 53端口一般对所有客户机开放，以提供解析服务；TCP 53端口一般只对特定从域名服务器开放，提高解析记录传输通道；TCP 953端口默认只对本机（127.0.0.1）开放，用于为rndc远程管理工具提供控制通道 配置配置文件：/etc/named.conf、/etc/named.rfc1912.zones等数据文件目录：/var/named/ 服务配置修改服务配置文件，绑定dns服务器端口，允许所有人访问。1234# vim /etc/named.conf listen-on port 53 &#123; 66.66.66.30; &#125;; allow-query &#123; any; &#125;; 正向解析（将域名解析成IP）添加正向解析域123456# vim /etc/named.rfc1912.zoneszone "ntg" IN &#123; type master; file "data/ntg.zone";&#125;; 添加解析记录，文件中注释以“;”开头。123456789101112131415# vim /var/named/data/ntg.zone$TTL 1D@ IN SOA vhdns.ntg. nitaogetech.gmail.com. ( 20190213 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum@ IN NS vhdnsvhtest IN A 66.66.66.240vhdns IN A 66.66.66.30rhmac IN A 66.66.66.20rh1 IN A 66.66.66.21 反向解析（将IP解析成域名）添加反向解析域123456# vim /etc/named.rfc1912.zoneszone "66.66.66.in-addr.arpa" IN &#123; type master; file "data/66.66.66.zone";&#125;; 添加解析记录，文件中注释以“;”开头。1234567891011121314# vim /var/named/data/66.66.66.zone$TTL 1D@ IN SOA vhdns.ntg. nitaogetech.gmail.com. ( 20190213 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum@ IN NS vhdns.ntg.240 IN PTR vhtest.ntg.30 IN PTR vhdns.ntg.20 IN PTR rhmac.ntg.21 IN PTR rh1.ntg. 检查服务配置是否正确1# named-checkconf 检查解析域配置是否正确检查正向解析域123# named-checkzone ntg /var/named/data/ntg.zonezone ntg/IN: loaded serial 20190213OK 检查反向解析域123# named-checkzone 66.66.66.in-addr.arpa /var/named/data/66.66.66.zonezone 66.66.66.in-addr.arpa/IN: loaded serial 20190213OK 重启服务配置好了之后重启DNS服务1# systemctl restart named 配置转发当我在本机配置dns为我的DNS服务器时，只能解析我加的那些记录，其他类似baidu.com,qq.com解析不了了……我发现我上不了外网了…… 其实可以为DNS服务器配置转发功能12345678910# vim /etc/named.confoptions &#123;... forwarders &#123; 66.66.66.1; 8.8.8.8; 114.114.114.114; &#125;;... 这次就不用配多个DNS地址了，只配一个自己搭的DNS服务器地址就行了。 解析测试在另一台机器上的网卡配置中或在/etc/resolv.conf中（看你是否用NetworkManager）添加DNS地址。我这里DNS地址是66.66.66.30，注意刚配好的DNS要放在前面，否则可能会先去从外网DNS解析。1234# vi /etc/sysconfig/network-scripts/ifcfg-eth0DNS1="66.66.66.30"DNS2="66.66.66.1" 查看域名解析信息123# dig www.test.com --查询DNS包括NS记录，A记录，MX记录等相关信息# nslookup www.test.com# host www.test.com --测试域名系统工作是否正常 测试下我的DNS是否配好：12345678910111213# nslookup vhdns.ntgServer: 66.66.66.30Address: 66.66.66.30#53Name: vhdns.ntgAddress: 66.66.66.30# nslookup 66.66.66.30Server: 66.66.66.30Address: 66.66.66.30#5330.66.66.66.in-addr.arpa name = vhdns.ntg. ok，齐活。 集群高可用// 暂时用不到高可用 参考资料CentOS 7.3 搭建DNS服务器 keepalived(主从)+LVS(DR模型)+DNS实现高可用集群服务]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>看破CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Linux 1.从命令入手]]></title>
    <url>%2Fp%2F7919749f%2F</url>
    <content type="text"><![CDATA[Linux中一切皆文件，所有命令也都是可执行文件，而且有Shell内建命令和其他命令之分。在执行命令时，linux会在当前shell内部寻找命令，如果没有，再到配置的环境变量PATH中逐一目录找，并将命令和路径映射到当前用户的命令哈希表，以减少循迹操作。1234567# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/disk1/lib/jdk1.8.0_201/bin:/root/bin# hash命中 命令 1 /usr/bin/cat 3 /usr/bin/who 基础命令重启/关机1234567891011121314151617181920重启# shutdown -r# reboot# init 6关机（默认一分钟后）# shutdown立即关机# shutdown now# init 0关闭系统，不关闭电源# shutdown -H# halt切断电源# shutdown -P# poweroff定时操作# shutdown 23:00 # shutdown -r 23:00 执行关机前，取消关机操作# shutdown -c man（查看帮助手册）man [命令] enable（启用或禁用内部命令）enable: 用法:enable [-a] [-dnps] [-f 文件名] [名称 …] -n：关闭指定的内部命令；-a：显示所有激活的内部命令；-f：从指定文件中读取内部命令。 bash内部命令数量12# enable -p | wc -l61 type/whereis/which（命令文件所在路径）12345678# type killkill 是 shell 内嵌# whereis treetree: /usr/bin/tree /usr/share/man/man1/tree.1.gz# which tree/usr/bin/tree alias/unalias（设置/取消命令别名）alias [名称[=值] … ]12345678910111213141516171819202122232425262728293031# aliasalias cp='cp -i'alias egrep='egrep --color=auto'alias fgrep='fgrep --color=auto'alias grep='grep --color=auto'alias l.='ls -d .* --color=auto'alias ll='ls -l --color=auto'alias ls='ls --color=auto'alias mv='mv -i'alias rm='rm -i'alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'# alias showdir="ls -lah -tu"# showdir总用量 56K-rw-------. 1 root root 9.4K 4月 30 17:42 .bash_historydrwxr-xr-x 2 root root 46 4月 30 17:18 tempdr-xr-x---. 6 root root 229 4月 30 16:55 .drwxr-xr-x. 2 root root 29 4月 30 16:40 .sshdrwxr-xr-x. 3 root root 18 4月 30 16:40 .cachedrwxr-xr-x. 3 root root 18 4月 30 16:40 .config-rw-r--r-- 1 root root 1.9K 4月 30 16:32 file-rw-r--r--. 1 root root 176 4月 30 14:14 .bash_profile-rw-r--r--. 1 root root 176 4月 30 14:14 .bashrc-rw-r--r--. 1 root root 18 4月 30 14:14 .bash_logout-rw------- 1 root root 8.6K 4月 30 13:11 .viminfo-rw-r--r-- 1 root root 7 4月 30 10:31 .exrcdr-xr-xr-x. 18 root root 237 4月 30 10:31 ..-rw-r--r--. 1 root root 100 4月 29 10:06 .cshrc-rw-------. 1 root root 1.6K 4月 26 19:19 anaconda-ks.cfg-rw-r--r--. 1 root root 129 12月 29 2013 .tcshrc unalias [-a] 名称 [名称 …]1-a 取消所有命令别名 date（显示或设置时间）date [选项]… [+格式]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950-s 设置时间-d 显示指定的描述时间格式如下： %% 一个文字的 % %a 当前locale 的星期名缩写(例如： 日，代表星期日) %A 当前locale 的星期名全称 (如：星期日) %b 当前locale 的月名缩写 (如：一，代表一月) %B 当前locale 的月名全称 (如：一月) %c 当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25) %C 世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20) %d 按月计的日期(例如：01) %D 按月计的日期；等于%m/%d/%y %e 按月计的日期，添加空格，等于%_d %F 完整日期格式，等价于 %Y-%m-%d %g ISO-8601 格式年份的最后两位 (参见%G) %G ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用 %h 等于%b %H 小时(00-23) %I 小时(00-12) %j 按年计的日期(001-366) %k hour, space padded ( 0..23); same as %_H %l hour, space padded ( 1..12); same as %_I %m month (01..12) %M minute (00..59) %n 换行 %N 纳秒(000000000-999999999) %p 当前locale 下的"上午"或者"下午"，未知时输出为空 %P 与%p 类似，但是输出小写字母 %r 当前locale 下的 12 小时时钟时间 (如：11:11:04 下午) %R 24 小时时间的时和分，等价于 %H:%M %s 自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数 %S 秒(00-60) %t 输出制表符 Tab %T 时间，等于%H:%M:%S %u 星期，1 代表星期一 %U 一年中的第几周，以周日为每星期第一天(00-53) %V ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53) %w 一星期中的第几日(0-6)，0 代表周一 %W 一年中的第几周，以周一为每星期第一天(00-53) %x 当前locale 下的日期描述 (如：12/31/99) %X 当前locale 下的时间描述 (如：23:13:48) %y 年份最后两位数位 (00-99) %Y 年份 %z +hhmm 数字时区(例如，-0400) %:z +hh:mm 数字时区(例如，-04:00) %::z +hh:mm:ss 数字时区(例如，-04:00:00) %:::z 数字时区带有必要的精度 (例如，-04，+05:30) %Z 按字母表排序的时区缩写 (例如，EDT) 例如：12# date -d "2 days ago" +"%Y-%m-%d %H:%M:%S"2019-02-11 10:32:15 文件及目录相关命令ls（查看目录内容）ls [选项]… [文件]…12345678910111213-l 显示文件及子目录详细信息-o 不显示组，显示其他详细信息-d 只显示目录-a 显示所有包括隐藏的文件及子目录-h 友好显示文件大小-i 显示inode号-s 显示文件块大小 -S 按文件块大小倒序排序-tu 以访问时间倒序排序-r 反向排序-R 列出所有子目录下的文件-m 显示逗号分隔符-Q 用双引号引起来 pwd（查看当前bash所在目录）12# pwd/root cd（切换目录）cd [目录]12345678切换到根目录# cd /切换到家目录# cd ~切换到指定用户的家目录# cd ~user切换到上级目录# cd .. mkdir（创建目录）mkdir [选项]… 目录…12-m 设置目录权限 -p 强制创建没有的目录-v 显示创建信息 mktemp（创建临时文件/目录）mktemp [选项]… [TEMPLATE].XX…1234-d 创建一个临时目录而非文件-p 指定目录下创建-u 不创建任何东西，仅打印出名字。(仅供测试)-q 不显示执行过程 cp（复制）cp [选项]… 源文件 目标文件123456789101112-a 与"-dpR"效果相同-d 复制软链接时使用，否则复制的是指向文件-f 强制覆盖-i 覆盖前询问-p 保留源文件或目录的属性-r 递归处理，将指定目录下的所有文件与子目录一并处理-l 对源文件建立硬连接，而非复制文件-s 对源文件建立软连接，而非复制文件-u 当源文件的更改时间比目标文件更新，或目标文件不存在时，才覆盖或复制文件-b 覆盖目标文件前将其备份-S&lt;字符串&gt; 备份文件时，用指定后缀代替默认后缀~-v 显示执行过程 mv（移动）mv [选项]… 源文件 目标文件123456-f 强制覆盖-i 覆盖前询问-u 当源文件的更改时间比目标文件更新，或目标文件不存在时，才覆盖或移动文件-b 覆盖目标文件前将其备份-S&lt;字符串&gt; 备份文件时，用指定后缀代替默认后缀~-v 显示执行过程 rm（删除）rm [选项]… 文件…12345-d：删除空目录-f：强制删除文件或目录-i：删除已有文件或目录之前先询问用户-r：递归处理，将指定目录下的所有文件与子目录一并处理-v：显示指令的详细执行过程 split（切分文档）split [选项]… [源文件] [切分结果前缀]12345678-b&lt;文件大小&gt; 切分每个文件的大小，单位：1b(块，512字节) 1K 1M 1G 1T-C&lt;文件大小&gt; 切分每个文件的大小，尽量保证行完整-n&lt;个数&gt; 平均切分成N个文件-e 使用-n时，别切分出空文件-l&lt;行数&gt; 按行切分源文件。-a 指定切分结果命名序列的长度，默认是2-d 使用数字序列为切分结果命名，默认是字母--verbose 显示执行过程 file（识别文件类型）file [OPTION…] [FILE…]12345-b 列出文件类型，不显示文件名-c 详细显示指令执行过程，便于排错或分析程序执行的情形-f&lt;名称文件&gt; 指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称-L 直接显示符号连接指向文件的文件类别-z 尝试去解读压缩文件的内容 stat（显示文件状态信息）stat [选项]… 文件…123-L：支持符号连接-f：显示文件系统状态而非文件状态-t：以简洁方式输出信息 访问时间（access读文件的时间）修改时间（modify改文件内容的时间）改变时间（change修改文件属性时间） touch（改变访问/修改时间）文件不存在则创建。touch [选项]… 文件…123456-a 只更改访问时间。-m 只更改修改时间。-c 不创建任何文件。-d &lt;时间日期&gt; 使用指定的日期时间，而非现在的时间。-r &lt;参考文件或目录&gt; 把指定文件或目录的日期时间，设成和参考文件或目录的日期时间-t &lt;Pattern YYMMDDhhmm[.ss]&gt;改变访问/修改时间为指定时间 ln（链接）首先分析软硬链接的区别。1234567891011121314151617181920212223242526272829303132333435363738394041# dd if=/dev/zero of=origin-file count=4096 bs=1M记录了4096+0 的读入记录了4096+0 的写出4294967296字节(4.3 GB)已复制，1.6479 秒，2.6 GB/秒# ll -ih总用量 4.0G67639869 -rw-r--r-- 1 root root 4.0G 5月 1 10:28 origin-file# df文件系统 1K-块 已用 可用 已用% 挂载点/dev/sda1 41921540 5716328 36205212 14% /# ln origin-fie hard# ll -ih总用量 8.0G67639869 -rw-r--r-- 2 root root 4.0G 5月 1 10:28 hard67639869 -rw-r--r-- 2 root root 4.0G 5月 1 10:28 origin-file# df文件系统 1K-块 已用 可用 已用% 挂载点/dev/sda1 41921540 5716328 36205212 14% /# ln -s origin-file soft# ll -ih总用量 8.0G67639869 -rw-r--r-- 2 root root 4.0G 5月 1 10:28 hard67639869 -rw-r--r-- 2 root root 4.0G 5月 1 10:28 origin-file67639874 lrwxrwxrwx 1 root root 11 5月 1 12:06 soft -&gt; origin-file# df文件系统 1K-块 已用 可用 已用% 挂载点/dev/sda1 41921540 5716328 36205212 14% /# rm -rf origin-file# less hard"hard" may be a binary file. See it anyway?# less softsoft: 没有那个文件或目录 结论： inode：文件数据都储存在”块”中，inode储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等，中文译名为”索引节点”。 硬链接：inode相同，类似索引或引用变量，删除原文件或硬链接实际文件并未被删除，只有全部被删除时文件才被删除，不占用额外磁盘空间。 软链接（符号链接）：inode不同，类似快捷方式，指向指定绝对路径下的文件，删除源文件会使软链接失效，占用极少磁盘空间。 使用：123456789不指定 建立硬链接-s 建立软链接-f 强制覆盖-d 创建指向目录的硬链接(只适用于超级用户)-b 覆盖目标文件之前先备份，文件名结尾加~-S&lt;字尾备份字符串&gt; 指定备份结尾字符串-i 覆盖前询问-v 显示执行过程-n 把符号连接的目的目录视为一般文件 echo （标准输出）echo [选项]… 字符串…1234567891011121314-n 不输出行尾的换行符-e 允许解释转义字符-E 禁止解释转义字符转义字符：\\ 反斜线\a 报警符(BEL)\b 退格符\c 禁止尾随的换行符\f 换页符\n 换行符\r 回车符\t 水平制表符\v 纵向制表符 输出带颜色的字符串格式： echo -e “\033[字背景颜色；文字颜色m 醒目字符串 \033[0m” 字体色： 30m 黑色字 31m 红色字 32m 绿色字 33m 黄色字 34m 蓝色字 35m 紫色字 36m 天蓝字 37m 白色字 背景色： 40m 黑底 41m 红底 42m 绿底 43m 黄底 44m 蓝底 45m 紫底 46m 天蓝底 47m 白底黑 特效：\033[0m 关闭所有属性\033[1m 设置高亮度\033[4m 下划线\033[5m 闪烁\033[7m 反显\033[8m 消隐 cat（输出文件内容到标准输出）cat [选项]… [文件]…123456789-b 对非空行输出行编号-n 对所有行输出行编号-v 使用^ 和M- 引用，除了LFD和 TAB 之外（不知道什么作用）-E 在每行结束处显示$-T 将tab字符显示为^I-A 等于-vET-e 等于-vE-t 等于-vT-s 合并多空行为一行 more（分页显示查看文件）more [选项] 文件…123456-d 显示友好提示-s 多个空行压缩为一行-c 每次翻页都清屏-10 每页只显示10行+100 从100行开始显示+/str 从第一次匹配str的结果处显示 head（输出文件的开始部分）head [选项] 文件…1234-c 输出开始的n个字节-n 输出开始的n行-q 第一行不显示文件名-v 第一行显示文件名 tail（输出文件的结尾部分）tail [选项] 文件…12345678-c 输出最后的n个字节-n 输出最后的n行-f 持续输出文件内容--retry 重复尝试打开文件，与-f合用有效--pid 在PID死掉之后结束输出，与-f合用有效-s 每次输出间隔秒数，与-f合用有效-q 第一行不显示文件名-v 第一行显示文件名 wc（输出文件中的行数、单词数、字节数）wc [选项] 文件…1234-c 输出字节统计数。-l 输出换行符统计数。-L 输出最长一行的长度。-w 输出单词统计数。 diff（逐行对比文件差异）diff [选项]… FILES12345678-c：显示全部内容，并标出不同之处；-b 忽略空格-B 忽略空行-i 忽略大小写-l 将结果交由pr程序来分页；-q 若有差异，仅显示：文件 file 和 file2 不同-s 若没有差异，仅显示：文件 file 和 file3 相同-r 比较目录 find（查找）find [path…] [expression]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364表达式运算符：( expr表达式 ) 加括号表示优先执行expr前加 ! ，注意有空格，表示否定，按相反规则查找expr1 expr2 表示与，如果expr1为false 则不会执行expr2expr1 -o expr2 表示或，如果expr1为true 则不会执行expr2expr1 , expr2 表示列表，expr1和expr2都会被执行。expr1的返回值被忽略，列表的最终返回值是expr2的值属性表达式：-name &lt;pattern * ? []&gt; 按名称匹配-iname &lt;pattern * ? []&gt; 按名称匹配，忽略大小写-lname &lt;pattern * ? []&gt; 按名称匹配软链接-ilname &lt;pattern * ? []&gt; 按名称匹配软链接，忽略大小写-links &lt;number&gt;：查找指定硬连接数数的文件/目录-regex &lt;pattern&gt; 按正则匹配-iregex &lt;pattern&gt; 按正则匹配，忽略大小写-path &lt;pattern * ? []&gt; 按路径匹配-ipath &lt;pattern * ? []&gt; 按路径匹配，忽略大小写-inum &lt;inode编号&gt; 按inode编号匹配-perm &lt;权限数值&gt; 查找指定权限数值的文件/目录-size [+/-]&lt;文件大小&gt;：查找指定文件大小的文件/目录。+表示大于，-表示小于。单位：b 块（512字节），c 字节，w 字（2字节），k 千字节，M 兆字节，G 吉字节。-user &lt;String&gt; 查找属于xxx用户的文件/目录-uid &lt;number&gt; 查找属于UID用户的文件/目录-nouser：找出不属于本机用户的文件/目录-group &lt;String&gt; 查找属于xxx组的文件/目录-gid &lt;number&gt; 查找属于GID组的文件/目录-nogroup 找出不属于本机组的文件/目录-empty 查找空文件/目录-type &lt;一个文件类型编码&gt; 指定文件类型查找。文件类型编码：f 普通文件，l 符号链接，d 目录，b 特殊块文件（缓存的），c 特殊字符文件（不缓存），s 套接字，p 命名管道 (FIFO)-fstype &lt;一个文件系统类型&gt; 查找指定文件系统类型的文件/目录；逻辑表达式：-prune：与-path合用，匹配结果中排除path指定目录下的内容。-false 将表达式返回值强制设为false-true 将表达式返回值强制设为true-exec &lt;command&gt; &#123;&#125; \; 若回传值为true，对匹配结果执行命令-ok &lt;command&gt; &#123;&#125; \; 与-exec类似，在执行命令之前先询问-depth 先处理子目录再处理目录本身-maxdepth &lt;number&gt; 设置查找最大目录层级-mindepth &lt;number&gt; 设置查找最小目录层级-xdev 不进入处于其他文件系统之上的目录-follow 不检索符号链接。隐含了 -noleaf。-noleaf 不为“目录中子目录数量比硬连接数少2”这种假设做优化。这个选项在搜索那些不遵循UNIX文件系统链接约定的文件系统时用，比如CD-ROM,MS-DOS文件系统或AFS卷的加载点。在普通的UNIX文件系统中,每个目录至少有两个硬连接,它的名字和它的'.'条目。另外，它的子目录(假如有)还会各有一个'..'链接到它。在find检索一个目录时，发现子目录数比它的连接数少二时，它就知道目录中的其他条目并非目录(而是目录树中的叶(`leaf')节点)。除非需要检索的是这个叶节点，否则没必要去处理它。这样可以带来很大的搜索速度提升。输出表达式：-print 若返回值为true，列出文件/目录到标准输出，每个名称占一行-print0 若返回值为true，列出文件/目录到标准输出，每个名称紧挨着不换行-printf &lt;输出格式&gt; 若返回值为true，按指定格式列出文件/目录到标准输出-fprint &lt;file&gt; 与-print类似，把结果输出到指定文件-fprint0 &lt;file&gt; 与-print0类似，把结果输出到指定文件-fprintf &lt;file&gt; &lt;输出格式&gt; 与-printf类似，把结果输出到指定文件-ls 若返回值为true，详细列出文件/目录到标准输出-fls &lt;file&gt;：与-ls类似，把结果输出到指定文件时间表达式：-atime &lt;number&gt; 对文件的最近一次访问是在n*24小时之前-ctime &lt;number&gt; 对文件状态的最近一次修改是在n*24小时之前-mtime &lt;number&gt; 对文件数据的最近一次修改是在n*24小时之前-amin &lt;number&gt; 对文件的最近一次访问是在n分钟之前-cmin &lt;number&gt; 对文件状态的最近一次修改是在n分钟之前-mmin &lt;number&gt; 对文件数据的最近一次修改是在n分钟之前-daystart 从当日起始时开始而不是从24小时之前，计算时间(for -amin, -atime, -cmin, -ctime, -mmin, and -mtime)-anewer &lt;file&gt; 对文件的最近一次访问比file修改时间要晚。如果命令行中-follow在-anewer之前，(也只有在这种情况下)-anewer会受-follow的影响-cnewer &lt;file&gt; 对文件状态的最近一次修改比file修改时间要晚。如果命令行中-follow在-cnewer之前，(也只有在这种情况下)-cnewer会受-follow的影响-newer &lt;file&gt; 对文件的最近一次修改比file修改时间要晚。如果命令行中-follow在-newer之前，(也只有在这种情况下)-newer会受-follow的影响 grep（文本过滤）grep [选项]… PATTERN [FILE]…12345678910111213141516171819202122-r 指定目录下所有文本-A &lt;行数&gt; 显示匹配结果行，并显示该行之后的N行。-b 在显示符合范本样式的那一行之外，并显示该行之前的内容。-n 显示行数-c 显示匹配行数-i 忽略大小写-w 完全匹配。-x 只显示全行符合的行。-E 可以使用正则。-e 指定匹配字符串-f 指定匹配字符串文件（每个字符串占一行）-v 反转查找。-o 只输出文件中匹配到的部分。-q 不显示任何信息。-s 不显示错误信息。-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。-H 在显示符合范本样式的那一列之前，标示该列的文件名称。-l 列出文件内容符合指定的范本样式的文件名称。-L 列出文件内容不符合指定的范本样式的文件名称。 xargs（传递参数）xargs [选项] 命令12345678-t 显示将要执行的命令-I 配合&#123;&#125;使用，将结果行赋给变量&#123;&#125;，之后可以对&#123;&#125;进行操作-0 解决换行分隔符问题，可配合find -print0使用-n 分组执行，每组n个参数，适用于参数过长的场景-l 分组执行，每次读n行做参数-r 遇到空行，停止执行，一般没有任何内容也会执行一次。-s 限制每个参数的长度-p 执行前确认 压缩相关命令zip/unzip/zipinfo（zip格式）zip [选项] 压缩包[.zip] 文件… -xi 文件…123456789101112131415161718192021222324-0 不压缩，只存储-1 压缩速度更快（compress faster）-9 压缩质量更高（compress better）-r 递归处理，将指定目录下的所有文件和子目录一并处理-P &lt;密码&gt; 加密压缩包-z 压缩时添加注释-u 更新压缩包中的文件，不存在则添加进压缩文件-f 只更新压缩包中存在的文件，不存在则不执行-d 从压缩包中删除指定文件-m 将文件移动到压缩文件中，存在则覆盖-D 压缩不添加目录-i &lt;files&gt; 压缩指定文件列表-x &lt;files&gt; 压缩排除指定文件列表-l 把换行转成回车换行-ll 把回车换行转成换行-o 将压缩包内文件的最新更改时间，作为压缩包的更改时间-t &lt;date yyyy-mm-dd&gt; 压缩更改时间大于指定时间的文件-tt &lt;date yyyy-mm-dd&gt; 压缩更改时间小于指定时间的文件 -y 压缩符号链接而不是符号链接指向的实际文件-T 测试压缩包完整性-F 尝试修复已损坏的压缩文件-FF 更努力地尝试修复-q 不显示执行过程-v 显示执行过程 unzip [选项] 压缩包[.zip]12345678910111213141516171819-P &lt;密码&gt; 解密压缩包-x &lt;files&gt; 解压缩时，排除解压的文件列表-d &lt;目录&gt; 解压到指定目录-z 显示压缩包注释-t 检查压缩包完整性-l 列出压缩包内文件信息-v 显示压缩包详细信息-n 解压缩不覆盖目录内原有文件-o 解压缩强制覆盖目录内原有文件-f 更新目录内存在的文件，没有则无操作-q 不显示执行信息-j 解压缩丢弃目录结构-a 自动转换所有的文本文件的字符集为系统字符集-aa 将所有文件视为文本-b 将所有文件视为二进制-LL 解压缩时将所有文件名小写-X 解压缩保持原来的UID/GID；-M 将输出结果交给more处理-Z 相当于执行zipinfo zipinfo [选项] 参数1234567891011-x &lt;files&gt; 排除的文件列表-1 只列出文件名称；-2 与-1”类似，但可搭配“-h”，“-t”和“-z”参数使用-h 只列出压缩包内的文件名称-t 只列出压缩包内的文件数，压缩前后的文件大小和压缩率-z 显示压缩包注释-s 用类似执行“ls-l”指令的效果列出压缩文件内容-m 与-s类似，但多会列出每个文件的压缩率-l 与-m类似，但会列出原始文件的大小而非压缩率-v 详细显示压缩包内每一个文件的信息-M 将输出结果交给more处理 gzip/gunzip（gz格式）只能压缩文件gzip [OPTION]… [FILE]…1234567891011-1 压缩速度更快（compress faster）-9 压缩质量更高（compress better）-d 解压缩，相当于gunzip-f 强制压缩文件和链接-l 列出压缩包的相关信息-r 递归处理，将指定目录下的所有文件及子目录一并处理-n 压缩文件时，不保存原来的文件名称及时间戳记-N 压缩文件时，保存原来的文件名称及时间戳记-t 检查压缩包完整性-q 不显示执行过程-v 显示执行过程 bzip2/bunzip2（bz2格式）只能压缩文件bzip2 [OPTION]… [FILE]…123456789-1 压缩速度更快（compress faster）-9 压缩质量更高（compress better）-d 解压缩，相当于bunzip2-k 压缩且不删除被压缩文件-f 强制覆盖-s 降低执行压缩时内存使用量（最多2500k）-t 检查压缩包完整性-q 不显示执行过程-v 显示执行过程 tar（归档压缩工具）tar [选项…] [FILE]…12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152-c 新建归档-x 展开归档-C &lt;目录&gt; 解压到指定目录-z 使用gzip压缩归档-j 使用bzip2压缩归档-J 使用xz压缩归档-Z 使用compress压缩归档-f 指定归档文件名，f必须放在选项最后-t 列出归档内容-v 显示执行过程--exclude &lt;文件名&gt; 排除指定文件-w 每次操作都需要询问-k 保留原有文件不覆盖-m --touch 不要原有文件的修改时间-P 保留归档文件的绝对路径-N &lt;日期格式&gt; 只将比指定日期更新的文件归档-d 比较归档内与系统内的文件差异以下选项对压缩后归档无效：-A 合并归档-r 追加文件到归档-u 仅追加比归档中副本更新的文件--delete 从归档删除文件使用gzip压缩当前目录所有文件到pack.tar.gz归档# tar czvf pack.tar.gz ./*使用gzip解压缩pack.tar.gz归档到./temp目录# tar xzvf pack.tar.gz -C ./temp查看归档中文件内容# tar tvf pack.tar.gz查看归档与系统内的文件差异# tar dvf pack.tar.gz *file1file2tar: all.tar.gz：归档中找不到tar: file3：归档中找不到tar: filedir：归档中找不到tar: file.txt：归档中找不到tar: one.tar：归档中找不到tar: one.tar.gz：归档中找不到tar: pack.tar：归档中找不到tar: pack.tar.gz：归档中找不到tar: 由于前次错误，将以上次的错误状态退出以下操作对未压缩的归档可用：添加指定文件到归档# tar -rvf pack.tar file3从归档中删除指定文件# tar --delete -vf pack.tar file3合并归档# tar -Avf one-file.tar pack.tar 用户及组相关命令su（切换用户）su [选项] [-] [USER [参数]…]1234不指定用户默认切换为root用户- 加载要切换的用户的环境-c 运行指定命令然后退出-m 切换用户，但不改变环境变量 sudo（以其他用户执行命令）sudo命令用来以其他身份来执行命令，预设的身份为root。在/etc/sudoers中设置了可执行sudo指令的用户。若其未经授权的用户企图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先输入密码，之后有5分钟的有效期限，超过期限则必须重新输入密码。 1234567-b：在后台执行指令；-H：将HOME环境变量设为新身份的HOME环境变量；-l：列出目前用户可执行与无法执行的指令；-s&lt;shell&gt;：执行指定的shell；-u&lt;用户&gt;：以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份；-v：延长密码有效期限5分钟；-k：结束密码的有效期限，也就是下次再执行sudo时便需要输入密码； 在登录到普通用户之后，su - root和sudo -s 都可以切换为root用户。 who（显示当前登录到系统的用户）123456-a 列出所有信息-b 列出系统最近启动的日期时间-H 显示各栏位的标题信息列-u 额外显示空闲时间、进程号，若该用户在一分钟之内有进行任何动作，将标示成"."号，如果该用户已超过24小时没有任何动作，则标示出"old"字符串-m 此参数和直接敲"who am i"效果相同-q 只显示登入系统的用户名和总用户数 w（显示已经登陆系统的用户列表）1234567-h 不显示标题-s 短格式显示&lt;user&gt; 指定用户指标含义：JCPU 表示该终端上所有进程及子进程使用系统的总时间PCPU 当前活动进程使用系统的时间 last（查看登录用户记录）1# last -a groupadd/groupdel（组操作）groupadd [选项] 组123456-g 指定GID-r 创建系统组，系统组的GID小于500-o 允许添加重复GID的组-p 为组设置密码# groupadd -g 1999 monitor groupdel 组1# groupdel monitor useradd/userdel/usermod（用户操作）useradd [选项] 用户名1234567891011-u 指定UID-g 指定所属默认组-G 指定所属附加组-d 指定用户主目录-s 指定用户登录默认shell-c 用户备注-o 允许添加重复UID的用户-p 为用户设置密码，存放在/etc/shadow，必须是加密后的-r 创建系统用户-e 用户过期时间-f 用户密码失效时间 userdel [选项] 用户名12-f 强制删除-r 删除主目录、主组和邮件池等用户相关数据 usermod [选项] 用户名123456789101112131415-u 指定UID-g 指定主GID，组必须存在-G 指定主组名-aG 追加到附加组中-d 指定主目录-dm 将主目录移动到新目录-s 指定用户登录默认shell-c 修改用户备注-l 修改用户名-e 修改用户过期时间-f 修改用户密码失效时间-L 锁定用户-U 解锁用户-o 允许使用重复UID-p 为用户设置密码，存放在/etc/shadow，必须是加密后的 passwd（设置用户密码）passwd [选项…] 用户名1234567891011-k 保持密码永不过期-d 删除用户密码-l 锁定用户-u 解锁用户-e 设置用户密码为过期-f 强制执行-x, --maximum=DAYS 密码的最长有效时限-n, --minimum=DAYS 密码的最短有效时限-w, --warning=DAYS 在密码过期前多少天开始提醒用户-i, --inactive=DAYS 当密码过期后经过多少天该帐号会被禁用-S, --status 报告已命名帐号的密码状态(只有根用户才能进行此操作) chown/chmod（文件权限设置）chown [选项] 所属用户:所属组 文件…123-R 递归操作目录文件及子目录-v 显示执行过程-h 只修改符号链接所属，不修改指向文件 chmod [选项…] 模式 文件123456789101112-R 递归操作目录文件及子目录-v 显示执行过程# chmod 755 file# ll总用量 0-rwxr-xr-x 1 root root 0 2月 16 13:42 file模式：rwx 421 可读可写可执行第一个-/d表示文件还是目录其余三个一组，分别代表：owner group other 磁盘相关命令df（查看系统的磁盘使用情况）df [选项]…123456789-a 列出所有文件系统分区；-h 友好显示-H 与-h类似，但在计算时是以1000 Bytes为换算单位而非1024 Bytes；-i 显示inode信息-l 仅显示本地端的文件系统-k 以KB为单位查看-m 以MB为单位查看-T 显示文件系统类型-x &lt;文件系统类型&gt; 排除指定文件系统类型 du（查看目录的磁盘使用情况）du [选项]… [文件]…12345678-a 显示目录中所有文件的大小-s 显示总计大小-h 友好显示-H 与-h相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes；-b 以byte为单位显示-k 以KB为单位显示-m 以MB为单位显示-L &lt;符号链接&gt; 显示符号链接指向文件的大小 sync（强迫将内存数据写入磁盘，并更新超级块）eject（弹出设备）eject [选项] [&lt;设备&gt;|&lt;挂臷点&gt;]123456789101112131415161718-a, --auto &lt;on|off&gt; 打开/关闭自动弹出功能-c, --changerslot &lt;slot&gt; 在 CD-ROM 更换器上换盘-d, --default 显示默认设备-f, --floppy 弹出软盘-F, --force 无视设备类型-i, --manualeject &lt;on|off&gt; 切换手动弹出保护开/关-m, --no-unmount 不卸载设备，即使它已挂臷-M, --no-partitions-unmount 不卸载另外的分区-n, --noop 不弹出，只显示找到的设备-p, --proc 使用 /proc/mounts 代替 /etc/mtab-q, --tape 弹出磁带-r, --cdrom 弹出 CD-ROM-s, --scsi 弹出 SCSI 设备-t, --trayclose 关闭托盘-T, --traytoggle 开关托盘-v, --verbose 启用详尽输出-x, --cdspeed &lt;speed&gt; 设置 CD-ROM 最高速度-X, --listspeed 列出 CD-ROM 可用速度 网络相关命令ifconfig（显示网络接口信息）ifconfigifconfig 网卡名 telnet（使用telnet协议探测主机端口）telnet 主机IP 端口 netstat（查看网络连接状态）netstat [选项]1234567891011121314151617181920212223242526272829303132333435363738394041424344-a 显示所有连接-n 显示IP，而非域名-o 显示存活计时器-l 显示状态为LISTENING监听的连接-p 显示进程ID和进程名-e 显示其他扩展信息-t 显示TCP协议的连接-u 显示UDP协议的连接-w 显示RAW协议的连接-A 显示指定网络类型的连接-x 与"-A unix"效果相同--ip 与"-A inet"效果相同-r 显示路由表-i 显示网络接口表，-ie与ifconfig效果相同-g 显示多重广播功能群组组员名单-s 显示网络协议的统计信息-c &lt;秒数&gt; 持续输出网络连接状态显示字段：Proto：当前连接的协议；如TCP、UDP；Recv-Q：网络接收队列；Send-Q：网络发送队列；接收队列和发送队列一般都应该是0，如果不是则表示数据包正在队列中堆积，但是这种情况比较少见；Local Address：本机的ip:port（注意此处127.0.0.1默认显示主机名，0.0.0.0默认显示*，端口可能显示别名。若强制显示数字，加-n参数）Foreign Address：对端ip:port；与Local Address规则相同State：当前套接字的网络状态，有以下几种状态：LISTEN：监听来自其它TCP端口的连接请求SYN-SENT：再发送连接请求后等待匹配的连接请求（如果有大量这样的状态包，检查是否中招了）SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（如有大量此状态，估计被flood攻击了）ESTABLISHED：代表一个打开的连接FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认FIN-WAIT-2：从远程TCP等待连接中断请求CLOSE-WAIT：等待从本地用户发来的连接中断请求CLOSING：等待远程TCP对连接中断的确认LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认（不是什么好东西，此项出现，检查是否被攻击）TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认CLOSED：没有任何连接状态查看nginx的网络连接# netstat -anp | grep nginx查看所有监听中的tcp连接# netstat -lt查看所有监听中的udp连接# netstat -lu wget（从指定URL下载文件）wget [选项]… [URL]…12345678-b 后台下载-c 断点续传-S 显示服务器响应信息-t 设置失败重试次数-T 设置超时时间-w 重试间隔时间-o &lt;文件名&gt; 将下载信息创建并添加到日志文件-a &lt;文件名&gt; 将下载信息追加到指定日志文件 scp（远程复制）scp [选项] 本机目录/远程主机目录 远程主机目录/本机目录123456789101112-r 递归复制目录-P 指定远程主机的端口-p 保留文件的修改时间，访问时间和权限模式-F 指定ssh配置文件-o 指定ssh选项-l 指定宽带限制-q 不显示复制过程从本机目录复制到远程主机目录scp -r local root@192.168.1.249:/root/practise从远程主机复制目录到本机目录scp -r root@192.168.1.249:/root/practise/local . 软件安装相关命令rpm（软件包安装）rpm [选项…] [参数]1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677-i 安装-U 升级更新-e 删除-v 显示执行过程-vv 显示详细执行过程，用于排错-h 显示安装进度-V 验证软件完整性--test 测试安装过程，不实际安装--nodeps 不检查依赖关系--force 强制安装，忽略依赖、冲突及旧版本--replacepkgs 强制重新安装已安装的软件包-q 查询信息-a 查询所有软件包-f 查询指定文件-p 查询指定软件包-l 列出指定软件包的文件列表-i 查询软件概要信息-d 查询说明文件、用户手册--provides 查询软件提供功能--requires 查询软件依赖关系-g 查询系统已安装的某个软件分类下有哪些软件安装软件# rpm -ivh tree升级软件# rpm -Uvh tree卸载软件# rpm -evh tree查询nginx版本# rpm -qa | grep nginxnginx-1.16.0-1.el7.ngx.x86_64查询指定文件属于哪个软件包# rpm -qf /bin/bashbash-4.2.46-31.el7.x86_64查询指定软件包# rpm -qp tree-1.8.0-26.5.x86_64.rpm警告：tree-1.8.0-26.5.x86_64.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID e2c0098c: NOKEYtree-1.8.0-26.5.x86_64列出指定软件包的文件列表# rpm -qpl tree-1.8.0-26.5.x86_64.rpm警告：tree-1.8.0-26.5.x86_64.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID e2c0098c: NOKEY/usr/bin/tree/usr/share/doc/packages/tree/usr/share/doc/packages/tree/CHANGES/usr/share/doc/packages/tree/LICENSE/usr/share/doc/packages/tree/README/usr/share/man/man1/tree.1.gz查询指定软件包的概要信息# rpm -qip tree-1.8.0-26.5.x86_64.rpm警告：tree-1.8.0-26.5.x86_64.rpm: 头V3 RSA/SHA256 Signature, 密钥 ID e2c0098c: NOKEYName : treeVersion : 1.8.0Release : 26.5Architecture: x86_64Install Date: (not installed)Group : Productivity/File utilitiesSize : 122506License : GPL-2.0-or-laterSignature : RSA/SHA256, 2019年02月09日 星期六 07时06分31秒, Key ID 88eb5d66e2c0098cSource RPM : tree-1.8.0-26.5.src.rpmBuild Date : 2019年02月09日 星期六 07时06分24秒Build Host : lamb25Relocations : (not relocatable)Vendor : obs://build.opensuse.org/Base:SystemURL : http://mama.indstate.edu/users/ice/tree/Summary : File listing as a treeDescription :Tree is a recursive directory listing command that produces a depthindented listing of files, which is colorized ala dircolors if theLS_COLORS environment variable is set and output is to tty. RPM包搜索网站 pkg搜索网站 CentOS官方镜像 中科大CentOS镜像 yum（repo源安装）较rpm安装方式更方便易用，为解决复杂的依赖关系而生。所有repo源（也可以叫仓库）都放在/etc/yum.repos.d/目录下，/etc/yum.repos.d/CentOS-Base.repo这是基础源。添加自定义源的格式如下：12345678# vim /etc/yum.repos.d/nginx.repo[nginx-stable] # 源名称name=nginx stable repo # 源备注baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ # 源地址gpgcheck=1 # 1表示启用GPG校验 0表示不校验enabled=1 # 是否启用这个源gpgkey=https://nginx.org/keys/nginx_signing.key # GPG密钥地址 yum [options] COMMAND123456789101112131415161718192021222324252627282930313233参数：-y 对所有询问都设置yes--assumeno 对所有询问都设置no-c 指定配置文件-q 不显示执行过程-v 显示执行过程-t 忽略错误-d 设置调试级别（0-10）-e 设置错误级别（0-10）-R 设置yum处理一个命令的最大等待时间-C 完全从系统缓存运行，不升级缓存--enablerepo 启用源--disablerepo 禁用源-x 排除某软件包命令：install 安装软件包reinstall 重新安装软件包update 升级软件包，默认obsoletes为true，所以使用上和upgrade没区别upgrade 升级软件包，相当于update --obsoletesdowngrade 降级软件包check-update 检查可用更新的软件包remove 删除指定的软件包list 列出所有软件包search 搜索匹配软件包info 显示指定软件包的详细信息clean 清理yum元数据缓存makecache 创建yum元数据缓存deplist 列出软件包的所有依赖关系provides 显示软件包的提供来源repolist 显示已配置的源history 显示操作历史version 显示可用的源版本。 进程相关命令crontab（任务调度工具）禁止使用任务调度的用户列表：/etc/cron.deny系统任务调度配置文件：/etc/crontab用户任务调度目录：/var/spool/cron/ crontab [选项]12345678910111213141516171819-u &lt;user&gt; 定义某用户，不指定则使用当前用户-e 编辑任务-l 列出任务-r 删除任务文件-i 删除前提示 给当前登录用户设置任务# crontab -e*/3 * * * * echo `date` &gt;&gt; ~/date-file格式：minute hour day month week command0-59 0-23 1-31 1-12 0-7特殊值：*：所有值， 如 00 03 * * * 代表每天3:00执行,：并列取值，如 1,2,3,4,5,6-：范围取值，如 1-6/：周期取值，如 */3 每三分钟执行 nohup 和 &amp; （后台运行）nohup（no hang up）命令运行由其后面指定的command参数和args参数，并将其控制台输出默认追加到nohup.out。要使其后台运行，在尾部添加 &amp;。通常这么玩1# nohup java -jar test.jar &gt; /dev/null 2&gt;&amp;1 &amp; kill（关闭进程）kill [信号] PID123456789101112131415161718192021222324252627不指定信号，默认就是15。常用信号：1 SIGHUP 挂起进程2 SIGINT 终止进程（同 Ctrl + C）3 SIGQUIT 退出进程（同 Ctrl + \）9 SIGKILL 无条件终止进程15 SIGTERM 尽可能终止进程17 SIGSTOP 无条件停止进程18 SIGTSTP 停止或暂停进程（同 Ctrl + Z）19 SIGCONT 继续运行停止的进程（与SIGTSTP相反， fg/bg命令）全部信号：# kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR111) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+338) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+843) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+1348) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-1253) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-758) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-263) SIGRTMAX-1 64) SIGRTMAX lsof（进程查看工具）lsof [选项] [参数]123456789101112131415161718192021222324252627282930313233343536373839404142434445-a：使用AND逻辑，合并选项输出内容-c：列出名称以指定名称开头的进程打开的文件-d：列出打开指定文件描述的进程+d：列出目录下被打开的文件+D：递归列出目录下被打开的文件-n：列出使用NFS的文件-u：列出指定用户打开的文件-p：列出指定进程号所打开的文件-i：列出打开的套接字（4、6、协议:端口、 @ip ）# lsof -i :80COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnginx 10112 root 6u IPv4 56628 0t0 TCP *:http (LISTEN)nginx 10113 nginx 6u IPv4 56628 0t0 TCP *:http (LISTEN)字段含义:COMMAND 进程名PID 进程IDUSER 进程执行者FD 文件描述符/文件打开模式/文件锁类型TYPE 文件关联类型DEVICE 占用磁盘的名称SIZE/OFF 文件的大小NODE inode/协议NAME 打开文件/套接字的名称举例：列出80端口TCP协议的所有连接# lsof -i tcp:80列出25端口UDP协议的所有连接# lsof -i udp:25列出以ngin开头的进程打开的文件列表# lsof -c nginx列出指定进程打开的文件列表# lsof -p 10112列出指定用户打开的文件列表# lsof -u nitaoge将所有的TCP网络连接信息和指定用户打开的文件列表信息一起输出# lsof -u nitaoge -i tcp将指定用户打开的文件列表信息，同时是TCP网络连接信息的一起输出# lsof -a -u nitaoge -i tcp列出目录下被进程打开的文件列表# lsof +d /usr/sbin/递归搜索目录下被进程打开的文件列表# lsof +D /usr/sbin/ ps（查看进程状态）常用选项组合就两个1234567891011121314151617181920212223242526272829显示进程的执行用户、进程ID、父进程ID、CPU利用率（整数百分比）、启动时间、执行终端、运行时长、执行命令# ps -ef UID PID PPID C STIME TTY TIME CMDroot 1 0 0 15:19 ? 00:00:00 /usr/lib/systemd/systemd --switched-root --system --deserialize 22root 2 0 0 15:19 ? 00:00:00 [kthreadd]root 3 2 0 15:19 ? 00:00:00 [ksoftirqd/0]显示进程的执行用户、进程ID、CPU使用率、内存使用率、使用虚拟内存量、使用物理内存量、执行终端、进程状态、启动时间、运行时长、执行命令# ps axuUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.2 190964 3820 ? Ss 15:19 0:00 /usr/lib/systemd/systemd --switched-root --system --deserialize 22root 2 0.0 0.0 0 0 ? S 15:19 0:00 [kthreadd]其中stat进程状态包括：D = uninterruptible sleep 不可中断休眠，不接受任何控制信号。R = running 正在运行。S = sleeping 正在休眠。T = stopped by job control signal 被控制信号停止。t = stopped by debugger during trace 被追踪调试停止。Z = zombie 僵尸进程。&lt; high-priority (not nice to other users) 高优先级，对其他用户进程不友好。N low-priority (nice to other users) 低优先级，对其他用户进程友好。L has pages locked into memory (for real-time and custom IO) 有些页被锁进内存，用于实时和自定义IO。s is a session leader 包含子进程。l is multi-threaded (using CLONE_THREAD, like NPTL pthreads do) 多线程进程，使用clone()创建的Native POSIX Thread Library（NPTL）线程，+ is in the foreground process group 位于前台的进程组。 详细选项如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162-a：显示所有终端机下执行的程序，除了阶段作业领导者之外。a：显示现行终端机下的所有程序，包括其他用户的程序。-A：显示所有程序。-c：显示CLS和PRI栏位。c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。-C&lt;指令名称&gt;：指定执行指令的名称，并列出该指令的程序的状况。-d：显示所有程序，但不包括阶段作业领导者的程序。-e：此选项的效果和指定"A"选项相同。e：列出程序时，显示每个程序所使用的环境变量。-f：显示UID,PPIP,C与STIME栏位。f：用ASCII字符显示树状结构，表达程序间的相互关系。-g&lt;群组名称&gt;：此选项的效果和指定"-G"选项相同，当亦能使用阶段作业领导者的名称来指定。g：显示现行终端机下的所有程序，包括群组领导者的程序。-G&lt;群组识别码&gt;：列出属于该群组的程序的状况，也可使用群组名称来指定。h：不显示标题列。-H：显示树状结构，表示程序间的相互关系。-j或j：采用工作控制的格式显示程序状况。-l或l：采用详细的格式来显示程序状况。L：列出栏位的相关信息。-m或m：显示所有的执行绪。n：以数字来表示USER和WCHAN栏位。-N：显示所有的程序，除了执行ps指令终端机下的程序之外。-p&lt;程序识别码&gt;：指定程序识别码，并列出该程序的状况。p&lt;程序识别码&gt;：此选项的效果和指定"-p"选项相同，只在列表格式方面稍有差异。r：只列出现行终端机正在执行中的程序。-s&lt;阶段作业&gt;：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。s：采用程序信号的格式显示程序状况。S：列出程序时，包括已中断的子程序资料。-t&lt;终端机编号&gt;：指定终端机编号，并列出属于该终端机的程序的状况。t&lt;终端机编号&gt;：此选项的效果和指定"-t"选项相同，只在列表格式方面稍有差异。-T：显示现行终端机下的所有程序。-u&lt;用户识别码&gt;：此选项的效果和指定"-U"选项相同。u：以用户为主的格式来显示程序状况。-U&lt;用户识别码&gt;：列出属于该用户的程序的状况，也可使用用户名称来指定。U&lt;用户名称&gt;：列出属于该用户的程序的状况。v：采用虚拟内存的格式显示程序状况。-V或V：显示版本信息。-w或w：采用宽阔的格式来显示程序状况。 x：显示所有程序，不以终端机来区分。X：采用旧式的Linux i386登陆格式显示程序状况。-y：配合选项"-l"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位 。-&lt;程序识别码&gt;：此选项的效果和指定"p"选项相同。--cols&lt;每列字符数&gt;：设置每列的最大字符数。--columns&lt;每列字符数&gt;：此选项的效果和指定"--cols"选项相同。--cumulative：此选项的效果和指定"S"选项相同。--deselect：此选项的效果和指定"-N"选项相同。--forest：此选项的效果和指定"f"选项相同。--headers：重复显示标题列。--help：在线帮助。--info：显示排错信息。--lines&lt;显示列数&gt;：设置显示画面的列数。--no-headers：此选项的效果和指定"h"选项相同，只在列表格式方面稍有差异。--group&lt;群组名称&gt;：此选项的效果和指定"-G"选项相同。--Group&lt;群组识别码&gt;：此选项的效果和指定"-G"选项相同。--pid&lt;程序识别码&gt;：此选项的效果和指定"-p"选项相同。--rows&lt;显示列数&gt;：此选项的效果和指定"--lines"选项相同。--sid&lt;阶段作业&gt;：此选项的效果和指定"-s"选项相同。--tty&lt;终端机编号&gt;：此选项的效果和指定"-t"选项相同。--user&lt;用户名称&gt;：此选项的效果和指定"-U"选项相同。--User&lt;用户识别码&gt;：此选项的效果和指定"-U"选项相同。--version：此选项的效果和指定"-V"选项相同。--widty&lt;每列字符数&gt;：此选项的效果和指定"-cols"选项相同。 top （系统实时监控工具）选项参数：1234567-c 显示完整的命令路径-d 屏幕刷新间隔时间-i 不显示空闲或僵尸进程-s 安全模式，不能使用交互命令-n 指定刷新次数，到达次数退出-u&lt;用户名&gt; 指定用户名-p&lt;进程号&gt; 指定进程 交互命令：1234567891011121314151617h或? 显示帮助画面k 终止一个进程i 切换是否忽略闲置和僵死进程q 退出r 重新设置一个进程的优先级别；S：切换到累计模式；s：改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；f或者F：从当前显示中添加或者删除项目；o或者O：改变显示项目的顺序；l：切换显示平均负载和启动时间信息；m：切换显示内存信息；t：切换显示进程和CPU状态信息；c：切换显示命令名称和完整命令行；M：根据驻留内存大小进行排序；P：根据CPU使用百分比大小进行排序；T：根据时间/累计时间进行排序；w：将当前设置写入~/.toprc文件中。 显示字段说明：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758top - 20:36:45 up 5:16, 3 users, load average: 0.00, 0.01, 0.02Tasks: 117 total, 1 running, 116 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.2 us, 0.2 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1877572 total, 1624236 free, 90456 used, 162880 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 1621872 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 3801 root 20 0 573820 17240 6076 S 0.0 0.9 0:02.64 tuned top - 20:36:45[当前系统时间]up 5:16[系统已经运行了5小时16分钟]3 users[当前登录3个用户]load average: 0.00, 0.01, 0.02[平均负载，即任务队列的平均长度]Tasks: 117 total[总进程数]1 running[正在运行的进程数]116 sleeping[睡眠的进程数]0 stopped[停止进程数]0 zombie[僵尸进程数]%Cpu(s): us, user : time running un-niced user processes[用户空间CPU使用率]sy, system : time running kernel processes[内核空间CPU使用率]ni, nice : time running niced user processes[用户空间内改变过优先级的进程的CPU使用率]id, idle : time spent in the kernel idle handler[CPU空闲率]wa, IO-wait : time waiting for I/O completion[等待输入输出完成的CPU使用率]hi : time spent servicing hardware interrupts[硬件中断的CPU使用率]si : time spent servicing software interrupts[软件中断的CPU使用率]st : time stolen from this vm by the hypervisor[被Hypervisor偷去给其它虚拟机使用的CPU使用率]KiB Mem :1877572 total[物理内存总量]1624236 free[空闲内存总量]90456 used[已使用的物理内存总量]162880 buff/cache[用作内核缓冲区/缓存的内存量]0 total, 0 free, 0 used. 1621872 avail MemKiB Swap:0 total[交换分区总量]0 free[空闲交换分区总量]0 used[已使用交换分区总量]1621872 avail Mem[可用]Head:PID[进程ID]USER[执行用户]PR[进程优先级]NI[友好程度-nice值]VIRT[占用虚拟内存量KB]RES[占用物理内存量KB]SHR[共享内存量KB]S[状态码同ps]%CPU[CPU使用率]%MEM[内存使用率]TIME+[运行时长]COMMAND[执行程序] priority和nice的关系：有个一般公式，PRI(new) = PRI(old) + NI，所以PRI和NI都会影响进程执行的优先级（值越低，优先级越高），但PRI的最终值还需要由OS分析决定。Priority/PRI：由OS内核动态调整，用户不能调整。Nice/NI：用户可以自己调整。 nice/renice（设置进程友好程度）nice值是反应一个进程友好程度的值，值越大，表示进程对其他进程更友好，“优先级”越低。值越小，”优先级”越高，其取值范围是-20至19，超过范围设置成最值。123456789以设定nice值执行命令# nice -n 100 top &amp;[1] 6179重设nice值# renice -n 100 61316131 (进程 ID) 旧优先级为 -20，新优先级为 19# renice -n -100 61316131 (进程 ID) 旧优先级为 19，新优先级为 -20 系统相关命令uname（显示操作系统相关信息）12# uname -aLinux vhosttest 3.10.0-957.el7.x86_64 #1 SMP Thu Nov 8 23:39:32 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux uptime（显示系统负载）12# uptime 18:48:28 up 3:28, 3 users, load average: 0.00, 0.01, 0.01 load average平均负载: 分别是1分钟、5分钟、15分钟内系统的平均负载 那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。 dmesg（查看开机信息）1# dmesg | more free（查看内存使用情况）123-b -k -m -g 以B、KB、MB、GB为单位显示-s&lt;间隔秒数&gt; 周期显示内存使用情况-t 显示所有内存的总和列 硬件设备相关命令查看PCI设备1234567891011121314151617# lspci00:00.0 Host bridge: Intel Corporation 82P965/G965 Memory Controller Hub (rev 02)00:01.0 PCI bridge: Intel Corporation 82G35 Express PCI Express Root Port (rev 02)00:03.0 Unassigned class [ff00]: Parallels, Inc. Virtual Machine Communication Interface00:05.0 Ethernet controller: Red Hat, Inc. Virtio network device00:0a.0 PCI bridge: Digital Equipment Corporation DECchip 2115000:0e.0 RAM memory: Red Hat, Inc. Virtio memory balloon00:1d.0 USB controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1 (rev 02)00:1d.6 USB controller: NEC Corporation uPD720200 USB 3.0 Host Controller (rev 04)00:1d.7 USB controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB2 EHCI Controller (rev 02)00:1e.0 PCI bridge: Intel Corporation 82801 PCI Bridge (rev f2)00:1f.0 ISA bridge: Intel Corporation 82801HB/HR (ICH8/R) LPC Interface Controller (rev 02)00:1f.1 IDE interface: Intel Corporation 82801BA IDE U100 Controller (rev 05)00:1f.2 SATA controller: Intel Corporation 82801HR/HO/HH (ICH8R/DO/DH) 6 port SATA Controller [AHCI mode] (rev 02)00:1f.3 SMBus: Intel Corporation 82801H (ICH8 Family) SMBus Controller (rev 02)00:1f.4 Multimedia audio controller: Intel Corporation 82801BA/BAM AC'97 Audio Controller (rev 02)01:00.0 VGA compatible controller: Parallels, Inc. Accelerated Virtual Video Adapter 查看CPU信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# cat /proc/cpuinfoprocessor : 0vendor_id : GenuineIntelcpu family : 6model : 158model name : Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHzstepping : 9microcode : 0x9acpu MHz : 2904.000cache size : 8192 KBphysical id : 0siblings : 2core id : 0cpu cores : 2apicid : 0initial apicid : 0fpu : yesfpu_exception : yescpuid level : 22wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx rdtscp lm constant_tsc nopl xtopology nonstop_tsc eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 invpcid mpx rdseed adx smap clflushopt xsaveopt xsavec dtherm arat pln ptsbogomips : 5808.00clflush size : 64cache_alignment : 64address sizes : 36 bits physical, 48 bits virtualpower management:processor : 1vendor_id : GenuineIntelcpu family : 6model : 158model name : Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHzstepping : 9microcode : 0x9acpu MHz : 2904.000cache size : 8192 KBphysical id : 0siblings : 2core id : 1cpu cores : 2apicid : 1initial apicid : 1fpu : yesfpu_exception : yescpuid level : 22wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx rdtscp lm constant_tsc nopl xtopology nonstop_tsc eagerfpu pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 invpcid mpx rdseed adx smap clflushopt xsaveopt xsavec dtherm arat pln ptsbogomips : 5808.00clflush size : 64cache_alignment : 64address sizes : 36 bits physical, 48 bits virtualpower management: 物理cpu个数12# cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l1 逻辑CPU个数12# cat /proc/cpuinfo| grep "processor"| wc -l2 每个CPU核数12# cat /proc/cpuinfo| grep "cpu cores"| uniqcpu cores : 2 CPU型号12# cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 2 Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz 查看内存信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546# cat /proc/meminfoMemTotal: 1877572 kBMemFree: 1570208 kBMemAvailable: 1597404 kBBuffers: 2184 kBCached: 149452 kBSwapCached: 0 kBActive: 95488 kBInactive: 110824 kBActive(anon): 55056 kBInactive(anon): 8744 kBActive(file): 40432 kBInactive(file): 102080 kBUnevictable: 0 kBMlocked: 0 kBSwapTotal: 0 kBSwapFree: 0 kBDirty: 0 kBWriteback: 0 kBAnonPages: 54720 kBMapped: 24512 kBShmem: 9124 kBSlab: 50680 kBSReclaimable: 31664 kBSUnreclaim: 19016 kBKernelStack: 2576 kBPageTables: 5660 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 938784 kBCommitted_AS: 250416 kBVmallocTotal: 34359738367 kBVmallocUsed: 31016 kBVmallocChunk: 34359678972 kBHardwareCorrupted: 0 kBAnonHugePages: 12288 kBCmaTotal: 0 kBCmaFree: 0 kBHugePages_Total: 0HugePages_Free: 0HugePages_Rsvd: 0HugePages_Surp: 0Hugepagesize: 2048 kBDirectMap4k: 59312 kBDirectMap2M: 2037760 kB 参考资料 《循序渐进Linux-第2版》 《鸟哥的Linux私房菜-基础篇第四版》 《Linux命令行与shell脚本编程大全-第3版》 《Linux Shell编程艺术》 《学习vi和vim编辑器-第7版》 《Linux性能优化大师》 《曝光：Linux企业运维实战》 Linux命令大全 // 不是太全]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>看破Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破CentOS 2.安装KVM虚拟机、VNC远程桌面]]></title>
    <url>%2Fp%2F3756abdd%2F</url>
    <content type="text"><![CDATA[安装vnc远程桌面准备关闭防火墙 安装1# yum install tigervnc-server tigervnc-server-module 修改配置文件拷贝&amp;配置123456789101112# cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service# vim /etc/systemd/system/vncserver@:1.service[Service]Type=forking# Clean any existing files in /tmp/.X11-unix environmentExecStartPre=/bin/sh -c '/usr/bin/vncserver -kill :1 &gt; /dev/null 2&gt;&amp;1 || :'ExecStart=/usr/sbin/runuser -l nitaoge -c "/usr/bin/vncserver :1"PIDFile=/home/nitaoge/.vnc/%H%i.pidExecStop=/bin/sh -c '/usr/bin/vncserver -kill :1 &gt; /dev/null 2&gt;&amp;1 || :' 需要将所有%1替换为:1，即你要启动的vncserver@1.server将所有 USER替换为当前的用户 开机启动12# systemctl start vncserver@:1.service# systemctl enable vncserver@:1.service 切换到指定用户&amp;设置访问密码12# sudo - nitaoge# vncpasswd 启动&amp;查看端口12# vncserver :1# netstat -lnt | grep 590* 查看日志1# grep vnc /var/log/messages 停止VNC1# vncserver -kill :1 VNC viewer下载vnc viewer 连接目标主机 问题解决当出现以下问题时1PID file /home/nitaoge/.vnc/realhost1:1.pid not readable (yet?) after start 修改配置文件即可解决12345678910# vim /etc/systemd/system/vncserver@:1.service[Unit]Description=Remote desktop service (VNC)After=syslog.target network.target[Service]# Type=forking# 把forking改为simpleType=simple 安装KVM虚拟机（使用virt-manager图形管理）准备kvm相关包qemu-kvm 主要的KVM程序包python-virtinst 创建虚拟机所需要的命令行工具和程序库virt-manager GUI虚拟机管理工具virt-top 虚拟机统计命令virt-viewer GUI连接程序，连接到已配置好的虚拟机libvirt C语言工具包，提供libvirt服务libvirt-client 虚拟客户机提供的C语言工具包virt-install 基于libvirt服务的虚拟机创建命令bridge-utils 创建和管理桥接设备的工具 检查cpu是否支持虚拟化1# grep vmx /proc/cpuinfo 查看系统是否加载kvm模块，没有则手动加载123456# modprobe kvm# modprobe kvm-intel# lsmod | grep kvmkvm_intel 170086 0kvm 566340 1 kvm_intelirqbypass 13503 1 kvm 内核模块导出了一个名为/dev/kvm的设备，这个设备将虚拟机的的地址空间独立于内核或者任何应用程序的地址空间。12# ll /dev/kvmcrw-rw-rw-. 1 root kvm 10, 232 2月 12 11:56 /dev/kvm 安装安装kvm相关包1234# yum -y install bridge-utils libcanberra-gtk2 qemu-kvm.x86_64 qemu-kvm-tools.x86_64 \libvirt.x86_64 libvirt-cim.x86_64 libvirt-client.x86_64 \libvirt-java.noarch libvirt-python.x86_64 libiscsi-1.7.0-5.el6.x86_64 dbus-devel \virt-clone tunctl virt-manager libvirt libvirt-python python-virtinst 安装中文字符，解决界面乱码问题12# yum install -y dejavu-lgc-sans-fonts# yum groupinstall -y "Fonts" 启用libvirt12# systemctl enable libvirtd# systemctl start libvirtd 将CentOS的ISO镜像传入目标主机123# ll /disk2/sysiso/总用量 4481024-rwxr-xr-x. 1 qemu qemu 4588568576 2月 12 15:03 CentOS-7-x86_64-DVD-1810.iso 使用VNC连接目标主机&amp;使用virt-manager图形管理工具创建虚拟机1# virt-manager 参考资料Centos7 安装VNC Centos7.4安装kvm虚拟机（使用virt-manager管理）]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>看破CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破CentOS 1.系统配置]]></title>
    <url>%2Fp%2F4b580ca%2F</url>
    <content type="text"><![CDATA[防火墙关闭防火墙12systemctl stop firewalldsystemctl disable firewalld SELINUX关闭selinux123vi /etc/selinux/configSELINUX=disabled 网卡查看网卡属性12$ ifconfig$ ifconfig 网卡名 网卡文件路径1$ vi /etc/sysconfig/network-scripts/ifcfg-ens33 配置属性说明1234567891011121314151617181920212223TYPE=Ethernet 接口类型，常见的有ETHERNET（以太网）、Bridge(桥接接口)BOOTPROTO=dhcp 激活此接口使用什么协议来配置接口属性：dhcp，boot，static，noneDEFROUTE=yes PEERDNS=yes 如果BOOTPROTO的值为“dhcp”，是否允许dhcpDNS1：第一DNS服务器指向；若/etc/resolve的配置文件也有，则此处优先DNS2：备用DNS服务器指向；PEERROUTES=yesIPV4_FAILURE_FATAL=noIPV6INIT=yes 是否初始化IPV6IPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=0ea5507b-feab-4d8a-b582-e1874ca0bb97 此设备的唯一标识DEVICE=ens33 此配置文件对应的设备名称ONBOOT=yes 操作系统启动时，在系统引导过程中，是否激活此接口IPADDR： 指明IP地址；NETMASK：子网掩码；CentOS 7支持使用PREFIX以长度方式指明子网掩码；GATEWAY：默认网关；USERCTL：是否允许普通用户控制此设备； 举例： 1234567891011121314151617181920TYPE="Ethernet"PROXY_METHOD="none"BROWSER_ONLY="no"BOOTPROTO="none"DEFROUTE="yes"IPV4_FAILURE_FATAL="no"IPV6INIT="yes"IPV6_AUTOCONF="yes"IPV6_DEFROUTE="yes"IPV6_FAILURE_FATAL="no"IPV6_ADDR_GEN_MODE="stable-privacy"NAME="ens33"UUID="1db89cb7-a94b-43b5-94ef-3bc7b2dd2f4d"DEVICE="ens33"ONBOOT="yes"IPADDR="192.168.2.61"PREFIX="24"GATEWAY="192.168.2.2" DNS1="192.168.2.2"IPV6_PRIVACY="no" 重启网络服务1$ systemctl restart network 修改主机名12$ vi /etc/hostname$ hostname 主机名]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>看破CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朝花夕拾，五味杂陈]]></title>
    <url>%2Fp%2Fnote666%2F</url>
    <content type="text"><![CDATA[声明本博客使用GitPages+hexo+nexT开源组件搭建，除了网费电费域名及手工费其余没花一分钱。 只为本人在开发和学习过程中做知识总结，并且未做SEO优化，不为任何盈利性质活动，也不接受任何广告与合作。 （如果觉得我的文章对你有帮助，赞助我点网费也不失为一种积德行善，好人一生平安……） 如博客中文章有转载忘了加出处，请及时指出并邮件本人nitaogetech@gmail.com。 看破系列Java Development看破设计模式 看破Java 看破并发 看破Netty 看破JVM 看破调优 Spring Framework and Open-Source Components看破Spring 看破SpringBoot 看破SpringCloud 看破SpringSecurity 看破Activiti 看破Apollo 看破Elastic-job 看破GoogleGuava Linux &amp; DevOps看破Linux 看破Nginx 看破SaltStack 看破Docker+k8s 看破Gradle 看破Jenkins Database看破MySQL 看破ShardingSphere Cache &amp; MQ看破Redis 看破RabbitMQ 看破Kafka Bigdata看破Zookeeper 看破Scala 看破Hadoop 看破Hbase 看破Hive 看破Spark 看破Storm 看破Flume 看破博主中华郑六（1992.11 - ?），籍贯辽宁沈阳辽中区。 一个游过祖国大好河山，喜欢广结天下英雄豪杰，乐观看待社会发展，相信自己可以在北京定居，为了来北京做真正的技术把车卖了的年轻人……]]></content>
      <categories>
        <category>other</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[看破SaltStack 1.快速安装及使用]]></title>
    <url>%2Fp%2F409c9a33%2F</url>
    <content type="text"><![CDATA[准备安装 安装最新版本 安装SaltStack源1# yum install -y https://repo.saltstack.com/yum/redhat/salt-repo-latest.el7.noarch.rpm 清除过期缓存1# yum clean expire-cache 安装相关组件12# yum install -y salt-master salt-minion salt-ssh salt-syndic \salt-cloud salt-api 配置123# vim /etc/salt/minionmaster: vh11.ntg 启动在主节点启动salt-master1# systemctl start salt-master 在从节点启动salt-minion1# systemctl start salt-minion 授权查看授权123456789# salt-key# salt-key -LAccepted Keys:Denied Keys:Unaccepted Keys:vhost11vhost12Rejected Keys: 添加授权12345678910# salt-key -a vhost*# salt-key -AThe following keys are going to be accepted:Unaccepted Keys:vhost11vhost12Proceed? [n/Y] yKey for minion vhost11 accepted.Key for minion vhost12 accepted. 删除授权12345678910# salt-key -d vhost*# salt-key -DThe following keys are going to be deleted:Accepted Keys:vhost11vhost12Proceed? [N/y] yKey for minion vhost11 deleted.Key for minion vhost12 deleted. 测试12345678910111213141516# salt '*' test.pingvhost11: Truevhost12: True# salt '*' cmd.run 'w'vhost12: 12:53:02 up 54 min, 1 user, load average: 0.02, 0.02, 0.05 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root pts/0 192.168.1.50 12:01 10:46 0.06s 0.06s -bashvhost11: 12:53:02 up 54 min, 1 user, load average: 0.32, 0.09, 0.12 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root pts/0 192.168.1.50 12:01 6.00s 0.57s 0.21s /usr/bin/python /usr/bin/salt * cmd.run w sls任务入门配置任务路径1234567# vim /etc/salt/masterfile_roots: base: - /disk1/saltstack/srv/salt/state_top: top.sls 重启master1# systemctl restart salt-master 写任务然后发布执行12345678910111213141516171819202122232425# vim /disk1/saltstack/srv/salt/web/apache.slsapache-install: pkg.installed: - names: - httpd - httpd-develapache-service: service.running: - name: httpd - enable: true# salt 'vhost11' state.sls web.apache test=true# salt 'vhost11' state.sls web.apache# vim /disk1/saltstack/srv/salt/top.slsbase: 'vhost11': - web.apache 'vhost12': - web.apache# salt 'vhost11' state.highstate test=true# salt 'vhost11' state.highstate 参考资料 官方文档 中国SaltStack组 《精通SaltStack》]]></content>
      <categories>
        <category>saltstack</category>
      </categories>
      <tags>
        <tag>看破SaltStack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看破Markdown 语法收录]]></title>
    <url>%2Fp%2F7baf6824%2F</url>
    <content type="text"><![CDATA[背景迁到GitPages之后得拿这东西写博客，形式上跟写邮件没什么区别，正好最近学习RedHat时接触了vi，顺便玩玩vi编辑器。但不掌握md语法还是不行啊，写博客绊绊磕磕的。 首先看下Markdown的历史 Markdown是什么？Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。Markdown也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。 谁创造了它？它由Aaron Swartz和John Gruber共同设计，Aaron Swartz就是那位于去年（2013年1月11日）自杀,有着开挂一般人生经历的程序员。维基百科对他的介绍是：软件工程师、作家、政治组织者、互联网活动家、维基百科人。 他有着足以让你跪拜的人生经历：14岁参与RSS 1.0规格标准的制订。2004年入读斯坦福，之后退学。2005年创建Infogami，之后与Reddit合并成为其合伙人。2010年创立求进会（Demand Progress），积极参与禁止网络盗版法案（SOPA）活动，最终该提案被撤回。2011年7月19日，因被控从MIT和JSTOR下载480万篇学术论文并以免费形式上传于网络被捕。2013年1月自杀身亡。 停，我不想往下看了。谢谢作者，再见！ 语法简介转义想用特殊符号需转义。1234567\\\*\`\~\_\+\- 效果如下：\*`~_+- 目录每个编译器生成目录的标准不同，这里不做说明。[TOC](目录)或@[TOC](目录) 标题123456# h1级标题## h2级标题### h3级标题#### h4级标题##### h5级标题###### h6级标题 效果如下：影响目录了，不展示了…… 字体1234*斜体***粗体**_下划线_~~删除线~~ 效果如下：斜体粗体下划线删除线 代码块行内式`Object obj = null;`效果如下：Object obj = null; 多行式```Object obj = null;```效果如下：1Object obj = null; 列表注意： *下面需空一行，否则下面内容会与上面粘连。 无序列表1234567891011+ 1+ 2 + 3 + 4- a- b - c - d* a* o* e 效果如下： 1 2 3 4 a b c d a o e 有序列表注意：实际上乱序没什么用，就是把序号顺序改回来了，怎么来都是顺序1.2..x。12345676. 我是69. 我是83. 我是32. 我是21. 我是14. 我是45. 我是5 效果如下： 我是6 我是8 我是3 我是2 我是1 我是4 我是5 块引用注意：支持嵌套，&gt;下面需空一行，否则下面内容会与上面粘连。1234567&gt; 东北往事之你瞅我就不好使&gt;&gt; + 你瞅啥？&gt;&gt; - 瞅你咋的！&gt;&gt; * 瞅我就削你！&gt;&gt; * ！&amp;￥……@#&amp;%&gt;&gt;&gt; 发生混战&gt; 打输住院，打赢判刑；武功不相上下——派出所拘留罚款和解…… 效果如下： 东北往事之你瞅我就不好使 你瞅啥？ 瞅你咋的！ 瞅我就削你！ ！&amp;￥……@#&amp;% 发生混战打输住院，打赢判刑；武功不相上下——派出所拘留罚款和解…… 分割线如果一行中只有三个以上的连字符, 星号, 或者下划线则会在该位置生成一个 &lt;hr /&gt; 标签. 星号和连字符之间的空格也是允许的。注意：记那么多有什么用，直接---就完事了。123456* * *********---- - ---------------------------------------- 效果如下： 超链接行内式1试试[点我](https://tech.nitaoge.com)访问中华郑六的技术博客 效果如下：试试点我访问中华郑六的技术博客 常量式写成常量，适合多处使用相同链接的场景。参数定义时，以下写法都可以：12345[siteA]: https://tech.nitaoge.com "Title"[siteB]: https://tech.nitaoge.com 'Title'[siteC]: https://tech.nitaoge.com (Title)[点我]: &lt;https://tech.nitaoge.com&gt; "Title"试试点击[siteA]、[siteB]、[siteC]、[点我]访问中华郑六的技术博客 效果如下： 试试点击siteA、siteB、siteC、点我访问中华郑六的技术博客 图片与超链接形式一样，前面加个！感叹号。注意：目前没找到好用的能控制宽度的方法，每个编辑器都有自己的标准，那就算了，真想控制就用CSS就行。1![阿里要饭码](https://tech.nitaoge.com/images/aliredpack.png) 效果如下： 表格12345id_lalala|real_name|phone_num:---|---:|:---:1|张三|1102|赵四|1193|王五|120 效果如下： id_lalala real_name phone_num 1 张三 110 2 赵四 119 3 王五 120 最后说说两个精神病反人类语法注意：===最好别用，---和上面内容空一行就行了。12345一级标题=== 二级标题---]]></content>
      <categories>
        <category>devtool</category>
      </categories>
      <tags>
        <tag>看破Markdown</tag>
      </tags>
  </entry>
</search>
